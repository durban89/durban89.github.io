[{"title":"Objective-C与Smalltalk类似的动态类型","date":"2025-06-04T09:14:58.000Z","path":"2025/06/04/Objective-C与Smalltalk类似的动态类型.html","text":"动态类型类似于Smalltalk，Objective-C具备动态类型： 即消息可以发送给任何对象实体，无论该对象实体的公开接口中有没有对应的方法。在C++这种静态类型的语言里，不可能对一个(void*)指针调用任何方 法，编译器会挡下该调用行为。但在Objective-C中，你可以对id发送任何信息(id很像void*，但是被严格限制只能使用在对象上)，编译器 仅会发出“该对象可能无法回应信息”的警告，程序同样可以通过编译，而实际发生的事则取决于运行期该对象的真正形态，若该对象的确可以回应消息，则依旧运 行对应的方法。 这种特性可以增加语言的灵活性，因为它允许对象“捕捉”消息，再将消息转送到另一个可以正确处理该消息的对象，形同消息“转发”给另一个对象。 一个对象收到信息之后，他有三种处理信息的可能手段，第一是回应该消息并运行方法，若无法回应，则可以转发消息给其他对象，若以上两者均无，就要处 理无法回应而抛出的例外。只要进行三者之其一，该消息就算完成任务而被丢弃。若对“nil”（空对象指针）发送消息，该消息通常会被忽略，取决于编译器选 项可能会抛出例外。 虽然Objective-C具备动态类型的能力，但编译期的静态类型检查依旧可以应用到变量上。以下三种声明在运行时效力是完全相同的，但是三种声明提供了一个比一个更明显的类型信息，附加的类型信息让编译器在编译时可以检查变量类型，并对类型不符的变量提出警告。 下面三个方法，差异仅在于参数的形态： 1- setMyValue:(id) foo; id形态表示参数“foo”可以是任何类的实例。 1- setMyValue:(id &lt;aProtocol&gt;) foo; id &lt;aProtocol&gt;表示“foo”可以是任何类的实例，但必须采纳“aProtocol”协议。 1- setMyValue:(NSNumber*) foo; 该声明表示“foo”必须是“NSNumber”的实例。 动态类型是一种强大的特性。在缺少泛型的静态类型语言（如Java 5以前的版本）中实现容器类时，程序员需要写一种针对通用类型对象的容器类，然后在通用类型和实际类型中不停的强制类型转换。无论如何，类型转换会破坏静态类型，例如写入一个“整数”而将其读取为“字符串”会产生运行时错误。这样的问题被泛型解决，但容器类需要其内容对象的类型一致，而对于动态类型语言则完全没有这方面的问题。 [资料：维基百科]","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C对象发送消息[转发]","date":"2025-06-04T08:54:17.000Z","path":"2025/06/04/Objective-C对象发送消息-转发.html","text":"Objective-C允许对一个对象发送消息，不管它是否能够响应之。除了响应或丢弃消息以外，对象也可以将消息转发到可以响应该消息的对象。转发可以用于简化特定的设计模式，例如观测器模式或代理模式。 Objective-C运行时在Object中定义了一对方法： A.转发方法: 12- (retval_t) forward:(SEL) sel :(arglist_t) args; // with GCC- (id) forward:(SEL) sel :(marg_list) args; // with NeXT/Apple systems B.响应方法: 12- (retval_t) performv:(SEL) sel :(arglist_t) args; // with GCC- (id) performv:(SEL) sel :(marg_list) args; // with NeXT/Apple systems 希望实现转发的对象只需用新的方法覆盖以上方法来定义其转发行为。无需重写响应方法performv::，由于该方法只是单纯的对响应对象发送消息并传递参数。其中，SEL类型是Objective-C中消息的类型。 例子 这里包括了一个演示转发的基本概念的程序示例。(代码来源：维基百科Objective-C) Forwarder.h123456789#import &lt;objc/Object.h&gt; @interface Forwarder : Object&#123; id recipient; //该对象是我们希望转发到的对象。&#125; @property (assign, nonatomic) id recipient; @end Forwarder.m1234567891011121314151617#import &quot;Forwarder.h&quot; @implementation Forwarder @synthesize recipient; - (retval_t) forward: (SEL) sel : (arglist_t) args&#123; /* *检查转发对象是否响应该消息。 *若转发对象不响应该消息，则不会转发，而产生一个错误。 */ if([recipient respondsTo:sel]) return [recipient performv: sel : args]; else return [self error:&quot;Recipient does not respond&quot;];&#125; Recipient.h1234567#import &lt;objc/Object.h&gt; // A simple Recipient object.@interface Recipient : Object- (id) hello;@end Recipient.m123456789101112#import &quot;Recipient.h&quot; @implementation Recipient - (id) hello&#123; printf(&quot;Recipient says hello!\\n&quot;); return self;&#125; @end main.m1234567891011121314151617#import &quot;Forwarder.h&quot;#import &quot;Recipient.h&quot; int main(void)&#123; Forwarder *forwarder = [Forwarder new]; Recipient *recipient = [Recipient new]; forwarder.recipient = recipient; //Set the recipient. /* *转发者不响应hello消息！该消息将被转发到转发对象。 * (若转发对象响应该消息) */ [forwarder hello]; return 0;&#125; 脚注 利用GCC编译时，编译器报告： 1234$ gcc -x objective-c -Wno-import Forwarder.m Recipient.m main.m -lobjcmain.m: In function `main&#x27;:main.m:12: warning: `Forwarder&#x27; does not respond to `hello&#x27; 如前文所提到的，编译器报告Forwarder类不响应hello消息。在这种情况下，由于实现了转发，可以忽略这个警告。 运行该程序产生如下输出： 12$ ./a.outRecipient says hello!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Golang新版本安装吐槽","date":"2025-06-03T09:14:58.000Z","path":"2025/06/03/Golang新版本安装吐槽.html","text":"我是打算使用一下最新版本的Golang，然后使用下Hugo，结果安装的时候提示要安装上一个版本，我感觉没啥问题，我就安装了要求安装的版本，结果还是有问题继续安装要求安装的版本结果就是一个套着一个，我服了 这个机制头一次见到 123456789101112131415161718192021222324252627282930313233343536373839404142$ gvm install go1.24.3Updating Go source...Installing go1.24.3... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.24.3-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:01] C:130$ tail -f -n 100 ~/.gvm/logs/go-go1.24.3-compile.log Building Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_22_6_or_later (notgo122.go) in /home/durban/.gvm/gos/go1.24.3/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:25] C:130$ gvm install go1.22.6 Installing go1.22.6... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.22.6-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:35] C:1$ tail -f -n 100 ~/.gvm/logs/go-go1.22.6-compile.logBuilding Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_20_6_or_later (notgo120.go) in /home/durban/.gvm/gos/go1.22.6/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:49] C:130$ gvm install go1.20.6 Installing go1.20.6... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.20.6-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:53] C:1$ tail -f -n 100 ~/.gvm/logs/go-go1.20.6-compile.logBuilding Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_17_13_or_later (notgo117.go) in /home/durban/.gvm/gos/go1.20.6/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:14:02] C:130$ gvm install go1.17.13 Installing go1.17.13... * Compiling...go1.17.13 successfully installed! 笑死人 这个安装逻辑就是按照这个顺序依次安装 1234gvm install go1.17.13gvm install go1.20.6gvm install go1.22.6gvm install go1.24.3 为了体验下新版本我这是招谁了","tags":[{"name":"Golang","slug":"Golang","permalink":"https://blog.gowhich.com/tags/Golang/"}]},{"title":"Objective-C 创建对象","date":"2025-06-03T09:03:50.000Z","path":"2025/06/03/Objective-C-创建对象.html","text":"Objective-C中创建对象的方法：Objective-C 创建对象需通过 alloc 以及 init。alloc的作用是分配内存，init 则是初始化对象。 init 与 alloc 都是定义在 NSObject 里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。以下为范例： 1MyObject * my = [[MyObject alloc] init]; 在 Objective-C 2.0 里，若创建对象不需要参数，则可直接使用 new 1MyObject * my = [MyObject new]; 这仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写 init 方法，来添加额外的工作。(用途类似 C++ 的构造函数 constructor) 123456- (id) init &#123; if ( self=[super init] ) &#123; // 必须调用父类的 init // do something here ... &#125; return self;&#125;","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C 协议(Protocol)","date":"2025-06-03T08:54:11.000Z","path":"2025/06/03/Objective-C-协议-Protocol.html","text":"协议是一组尚未实现的方法列表，任何的类均可采纳该协议并给出方法的具体实现。 Objective-C在NeXT时期曾经试图引入多重继承的概念，但由于协议的出现而没有实现。协议的功能类似于C++中的多重抽象基类继承或是Java与C#语言中的“接口”。在Objective-C中，包括两种定义协议的方式：由编译器保证的“正式协议”，以及为特定目的设定的“非正式协议”。 非正式协议为一个可以选择性实现的一系列方法列表。非正式协议虽名为协议，但实际上是挂于NSObject上的未实现分类 (Unimplemented Category)的一种称谓，Objetive-C语言机制上并没有非正式协议这种东西，OSX 10.6版本之后由于正式协议也可以通过@optional关键字达成相同功用，所以非正式协议已经被废弃不再使用。 正式协议则类似于Java中的”接口”，它是一系列方法的列表，任何类都可以声明自身实现了某个协议。在Objective-C 2.0之前，一个类必须实现它声明符合的协议中的所有方法，否则编译器会报告一个错误，表明这个类没有实现它声明符合的协议中的全部方法。 Objective-C 2.0版本允许标记协议中某些方法为可选的(Optional)，这样编译器就不会强制实现这些可选的方法。 协议经常应用于Cocoa 中的委托及事件触发。例如文本框类通常会包括一个委托 (delegate)对象，该对象可以实现一个协议，该协议中可能包含一个实现文字输入的自动完成方法。若这个委托对象实现了这个方法，那么文本框类就会在适当的时候触发自动完成事件，并调用这个方法用于自动完成功能。 Objective-C中协议的概念与Java中接口的概念并不完全相同，即一个类可以在不声明它符合某个协议的情况下，实现这个协议所包含的方 法，也即实质上符合这个协议，而这种差别对外部代码而言是不可见的。正式协议的声明不提供实现，它只是简单地表明符合该协议的类实现了该协议的方法，保证 调用端可以安全调用方法。 语法 协议以关键字@protocol作为区段起始，@end退出，中间为方法列表。 1234@protocol Locking- (void)lock;- (void)unlock;@end 这是一个协议的例子，多线程编程中经常要确保一份共享资源同时只有一个线程可以使用，会在使用前给该资源挂上锁 ，以上即为一个表明有“锁”的概念的协议，协议中有两个方法，只有名称但尚未实现。 下面的SomeClass宣称他采纳了Locking协议： 123456789101112@interface SomeClass : SomeSuperClass &lt;Locking&gt;@end一旦SomeClass表明他采纳了Locking协议，SomeClass就有义务实现Locking协议中的两个方法。@implementation SomeClass- (void)lock &#123; // 实现lock方法...&#125;- (void)unlock &#123; // 实现unlock方法...&#125;@end 由于SomeClass已经确实遵从了Locking协议，故调用端可以安全的发送lock或unlock信息给SomeClass实体变量，不需担心他没有办法回应信息。 插件是另一个使用抽象定义的例子，可以在不关心插件的实现的情况下定义其希望的行为。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C 类型的声明与实现","date":"2025-06-03T08:45:02.000Z","path":"2025/06/03/Objective-C-类型的声明与实现.html","text":"Objective-C 类型要求区分接口（interface）与实现（implementation）为两个程序区块，这是强制性的。 类型的接口通常放置于头文件内，依C语言的惯例以.h作为扩展名；类型的实现则放于以.m为扩展名。 Interface接口区段里头清楚定义了类型的名称，实体变量（instance variable），以及方法。 以关键字@interface作为区段起头，@end退出区段。 12345678910@interface MyObject : NSObject &#123; int memberVar1; // 实体变量 id memberVar2;&#125;+(return_type) class_method; // 类别分类 -(return_type) instance_method1; // 实体方法-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 方法前面的+&#x2F;-号代表方法的类型：加号（+）代表类型方法（class method），不需要实体就可以调用，近于C++的静态成员函数（static member function）。减号（-）即是一般的实体方法（instance method）。 这里提供了一份意义相近的C++语法对照，如下： 123456789101112class MyObject : public NSObject &#123; protected: int memberVar1; // 实体变量 void * memberVar2; public: static return_type class_method(); // 类别方法 return_type instance_method1(); // 实体方法 return_type instance_method2( int p1 ); return_type instance_method3( int p1, int p2 );&#125; Objective-C定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C方法的参数也不必全部都附缀于方法名称的尾端，也可以夹杂于名称中间，提高程序可读性。以一个设置颜色RGB值的方法为例: 123- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法 */[myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法 */ 这个方法的全名是setColorToRed:Green:Blue:。每个冒号后面都带着一个形态为float的参数，分别代表红，绿，蓝三色。 Implementation实现区段则撰写方法实际运行的程序。以关键字@implementation作为区段起头，@end结尾。 1234567891011121314151617@implementation MyObject &#123; int memberVar3; //私有实体变量&#125; +(return_type) class_method &#123; .... //method implementation&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 值得一提的是不只interface区段开头可以声明实体变量，implementation区段开头也可以声明实体变量，两者的差别在于成员访问权限， 声明于interface区段内的实体变量默认权限为protected，声明于implementation区段的实体变量则默认为private，基 于面向对象的封装原则，仅供类型内部使用的变量请尽可能声明于implementation区段(.m档)内，不需要曝露于interface(.h档) 中。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"iOS开发是否应该使用ARC","date":"2025-06-03T08:43:01.000Z","path":"2025/06/03/iOS开发是否应该使用ARC.html","text":"关于ARC的介绍文章网上已经很多，苹果的官方文档也不少。担心使用ARC会带来问题的同学主要的理由有以下5点: 1.担心这个技术方案不靠谱。苹果大多数时候的技术方案都是比较靠谱的，但也有一些技术方案有很多坑，例如storyboard。 2.原有的项目在非ARC环境下运行良好，担心迁移成本或引入新的问题。 3.苹果以前手工管理内存需要非常小心，稍微不注意应用程序就崩溃了。有过这段经历的iOS开发老手，心里上还是觉得自己手工管理内存更踏实一些。 4.使用ARC需要了解ARC的一些细节，还需要引入_bridge等新的关键字，学习成本还是有的。 5.以为ARC只能支持iOS5.0以上（这是非常大的误解）。 对于上面提到5点问题，我认为相应的回答如下: 1.ARC是WWDC2011大会时提出的技术，离现在已经快2年了，而且苹果现在将MacOS上的垃圾回收机制废弃(Deprecated)，采用ARC替代，无疑证明了ARC是成熟的了。 2.确实有一些迁移成本，但苹果在Xcode中专门集成了迁移工具，成本已经非常小了。如下图就是Xcode集成的将非ARC工程转换成ARC工程的工具。另外，为了兼容第三方的非ARC开源库，你也可以在工程中随意使用编译参数：-fno-objc-arc ,这个参数允许对部分文件关闭ARC。 3.手工管理内存虽然踏实，但是泄露很容易发生。常常开发完成后，需要使用Instruments来检测泄露。但用了ARC后，基本不会出现泄露了，我在 开发粉笔网iPhone客户端时，由于使用了ARC，花三个月开发完的应用，用instruments检测后，没有发现任何内存泄漏问题。这在没有使用 ARC的工程中是不可想象的。 4.确实有学习成本。但是非常值得学习，能省不少开发精力。 5.虽然ARC是与iOS5一同推出，但是由于ARC的实现机制是在编译期完成，所以使用ARC之后App仍然可以支持iOS4.3。稍微需要注意的是， 如果要在ARC开启的情况下支持iOS4.3，需要将weak关键字换成 __unsafe_unretained，另外还有一些细节需要处理 所以，希望大家都能在项目中使用ARC，一旦你感受到它带来的好处，你就离不开它了。它也能让你从繁琐的内存管理代码中解放出来，将精力更多关注于代码结构、设计模式而不是底层的内存管理。","tags":[{"name":"ios","slug":"ios","permalink":"https://blog.gowhich.com/tags/ios/"}]},{"title":"Yii Widget的使用","date":"2025-06-03T07:18:28.000Z","path":"2025/06/03/Yii-Widget的使用.html","text":"小插件解决大问题，做网站，最喜欢使用这种东西，不需要重写代码，直接调用，传递参数，就得到想要的模块，yii也有次功能，看代码： 12345678910111213141516$this-&gt;beginWidget(&#x27;CBootStrapPortlet&#x27;, [ &#x27;title&#x27; =&gt; &#x27;博文分类&#x27;, //导航标题 &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;nav nav-pills nav-stacked&#x27;], //样式定义 &#x27;tagName&#x27; =&gt; &#x27;ul&#x27;, // &#x27;decorationCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;titleCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;contentCssClass&#x27; =&gt; &#x27;&#x27;,]);$this-&gt;widget(&#x27;CBootStrapMenu&#x27;, [ &#x27;items&#x27; =&gt; $this-&gt;blogType, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;],]);$this-&gt;endWidget(); 上面的代码是我的列表的小插件，样式我已经定义好了，只要给变量，传递参数就好了s","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Objective-C 信息传递","date":"2025-06-03T07:14:54.000Z","path":"2025/06/03/Objective-C-信息传递.html","text":"Objective-C最大的特色是承自Smalltalk的信息传递模型（message passing），与今日主流的C++差异甚大。Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递信息更为精确。此二种风格的差异主要在于程序如何看待调用方法&#x2F;传送信息这个动作。C++里类型与方法的关系非常严格清楚，一个方法必定属于一个类型，而且在编译时（compile time）就已经紧密绑定，你不可能去调用一个不存在类型里的方法。但在Objective-C，类型与信息的关系比较松散，调用方法视为对对象发送信息，所有方法都被视为对信息的回应。所有信息处理直到运行时（runtime）才会动态决定，并交由类型自行决定如何处理收到的信息。也就是说，一个类型不保证一定会回应收到的信息，如果类型收到了一个无法处理的信息，程序只会抛出一个Exception，不会出错或当掉。 C++里，送一个信息给对象（或者说调用一个方法）的语法如下: 1obj-&gt;method(argument); Objective-C则写成: 1[obj method: argument]; 此二者并不仅仅是语法上的差异，还有基本行为上的不同。 这里以一个汽车类（car class）的简单例子来解释Objective-C的信息传递特性： 1[car fly]; 典型的C++意义解读是“调用car类型的fly方法”。若car类型里头没有定义fly方法，那编译肯定不会通过。但是Objective-C里，我们应当解读为“发提交一个fly的信息给car对象”，fly是信息，而car是信息的接收者。car收到信息后会决定如何回应这个信息，若car类型内定义有fly方法就运行此段程序，若car内不存在fly方法，这里不会产生编译错误，它仅仅是抛出Exception。 此二种风格各有优劣。C++的编译期绑定使得函数调用非常快速，强制要求所有的方法都必须有对应的动作。缺点是不支持动态绑定（除非手动加上 virtual关键字）。Objective-C天生即是动态绑定，运行期才处理信息，允许传送未知信息给对象。可以送信息给整个对象集合而不需要一一检 查每个对象的型态，天生具备消息转送机制。同时空对象nil也可以接受信息，但是默认不做事，所以送信息给nil也不用担心程序崩溃。 Objective-C的方法调用因为运行期才动态解析信息，一开始信息比C++ virtual成员函数调用速度慢上三倍。但经由IMP高速缓存改善，目前已经比C++的virtual function快上50％。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C Hello World实例","date":"2025-06-03T07:12:55.000Z","path":"2025/06/03/Objective-C-Hello-World实例.html","text":"这里示范一个基础的Hello World程序。 12345678910#import&lt;Foundation/Foundation.h&gt; int main(int argc, char *argv[])&#123; NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; NSLog(@&quot;Hello World!&quot;); [pool drain]; return 0;&#125; 以上是Xcode的旧版”Hello World”程序代码，在4.3.1 xcode的代码为: 12345678#import &lt;Foundation/Foundation.h&gt; int main(int argc, char *argv[])&#123; @autoreleasepool&#123; NSLog(@&quot;Hello World!&quot;); &#125; return 0;&#125;","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Yii CRUD操作","date":"2025-06-03T07:11:26.000Z","path":"2025/06/03/Yii-CRUD操作.html","text":"对于喜欢操作sql语句的人来说和对于sql语句基础不是很好的，能够明白每个CRUD操作是什么意思很重要，简单的介绍个例子，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?phpclass Post extends CActiveRecord&#123; public $fixtures = [ &#x27;posts&#x27; =&gt; &#x27;Post&#x27;, &#x27;tags&#x27; =&gt; &#x27;Tag&#x27;, ]; public function findPost() &#123; //调用find时，我们使用$condition和$params指定查询条件。 //此处$condition可以是SQL语句中的WHERE字符串，$params则是一个参数数组， //其中的值应绑定到$condation中的占位符。 $post = $this-&gt;posts(&#x27;post1&#x27;); $fPost = Post::model()-&gt;find(&#x27;id=:id&#x27;, [&#x27;:id&#x27; =&gt; $post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=1 LIMIT 1 $fPost = Post::model()-&gt;find(&#x27;?&#x27;, [$post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE &#x27;1&#x27; LIMIT 1 //find返回符合条件的第一条记录，而findAll会返回符合条件的所有行。 $fAllPost = Post::model()-&gt;findAll(&#x27;id=:id&#x27;, [&#x27;:id&#x27; =&gt; $post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; $fAllPost = Post::model()-&gt;findAll(&#x27;?&#x27;, [$post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE &#x27;1&#x27; $criteria = new CDbCriteria(); $criteria-&gt;condition = &#x27;id=:id AND title=:title&#x27;; $criteria-&gt;params = [&#x27;:id&#x27; =&gt; $post-&gt;id, &#x27;:title&#x27; =&gt; $post-&gt;title]; $fPost = Post::model()-&gt;find($criteria); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; LIMIT 1 $fAllPost = Post::model()-&gt;findAll($criteria); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; $fPost = Post::model()-&gt;findByPk($post-&gt;id, &#x27;title=:title&#x27;, [&#x27;:title&#x27; =&gt; $post-&gt;title]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=1 AND (title = &#x27;post1&#x27;) LIMIT 1 $fPost = Post::model()-&gt;findByAttributes([&#x27;id&#x27; =&gt; $post-&gt;id, &#x27;title&#x27; =&gt; $post-&gt;title]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=&#x27;1&#x27; AND `t`.`title`=&#x27;post1&#x27; LIMIT 1 $sql = &#x27;SELECT id, title from &#123;&#123;post&#125;&#125; WHERE id = ? AND title = ?&#x27;; //必须设置表前缀 $fPost = Post::model()-&gt;findBySql($sql, [$post-&gt;id, $post-&gt;title]); $sql = &#x27;SELECT id, title from &#123;&#123;post&#125;&#125; WHERE id = :id AND title = :title&#x27;; $fPost = Post::model()-&gt;findBySql($sql, [&#x27;:id&#x27; =&gt; $post-&gt;id, &#x27;:title&#x27; =&gt; $post-&gt;title]); //如果没有找到符合条件的行，find返回null，findAll返回array()。 &#125; public function countPost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $cPost = Post::model()-&gt;count(&#x27;?&#x27;, [$post-&gt;title]); //SELECT COUNT(*) FROM `tbl_post` `t` WHERE &#x27;post1&#x27; 无意义 $cPost = Post::model()-&gt;countByAttributes([&#x27;title&#x27; =&gt; $post-&gt;title, &#x27;content&#x27; =&gt; $post-&gt;content]); //SELECT COUNT(*) FROM `tbl_post` `t` WHERE `t`.`title`=&#x27;post1&#x27; AND `t`.`content`=&#x27;content1&#x27; $sql = &quot;SELECT title from &#123;&#123;post&#125;&#125; WHERE title LIKE &#x27;%&quot; . $post-&gt;title . &quot;%&#x27;&quot;; $cPost = Post::model()-&gt;countBySql($sql); //至少有一条记录符合查询条件 $ePost = Post::model()-&gt;exists(&#x27;id=?ANDtitle=?&#x27;, [$post-&gt;id, $post-&gt;title]); //SELECT 1 FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; LIMIT 1 &#125; public function updatePost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $post-&gt;title = &#x27;updatepost1&#x27;; if ($post-&gt;isNewRecord) &#123; $post-&gt;create_time = $post-&gt;update_time = new CDbExpression(&#x27;NOW()&#x27;); //UPDATE `tbl_post` SET `id`=1, `title`=&#x27;update post 1&#x27;, `content`=&#x27;content1&#x27;, `tags`=NULL, `status`=1, `create_time`=NULL, `update_time`=1302161123, `author_id`=1 WHERE `tbl_post`.`id`=1 &#125; else &#123; $post-&gt;update_time = time(); &#125; $post-&gt;save(); //updateAll $sql = &quot;SELECT * FROM &#123;&#123;post&#125;&#125; WHERE title LIKE &#x27;%&quot; . &quot;post&quot; . &quot;%&#x27;&quot;; //SELECT * FROM tbl_post WHERE title LIKE &#x27;%post%&#x27; $post = Post::model()-&gt;findBySql($sql); $post-&gt;updateAll([&#x27;update_time&#x27; =&gt; time()], &#x27;id&lt;=?&#x27;, [&#x27;2&#x27;]); //UPDATE `tbl_post` SET `update_time`=1302161123 WHERE id &lt;= &#x27;2&#x27; $post-&gt;updateByPk($post-&gt;id + 2, [&#x27;title&#x27; =&gt; &#x27;updatepost3&#x27;]); $post-&gt;updateByPk($post-&gt;id, [&#x27;title&#x27; =&gt; &#x27;updatepost3&#x27;], &#x27;id=?&#x27;, [&#x27;3&#x27;]); //updateCounter更新某个字段的数值，一般是计数器(+/-)。 $tag = $this-&gt;tags(&#x27;tag1&#x27;); $uTag = Tag::model()-&gt;updateCounters([&#x27;frequency&#x27; =&gt; &#x27;3&#x27;], &#x27;id=?&#x27;, [&#x27;1&#x27;]); &#125; public function deletePost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $post-&gt;delete(); $this-&gt;assertEquals(1, $post-&gt;id); //删除数据库表中的记录，但是post的这个实例还在。 $post2 = Post::model()-&gt;findByPk($post-&gt;id); $this-&gt;assertEquals(null, $post2); //多条记录 $delete = Post::model()-&gt;deleteAll(&#x27;(id = ? AND title = ?) || (id = \\&#x27;4\\&#x27;) &#x27;, [1, &#x27;post1&#x27;]); $this-&gt;assertEquals(0, $delete); $delete = Post::model()-&gt;deleteAllByAttributes([&#x27;id&#x27; =&gt; &#x27;2&#x27;], &#x27;content=?&#x27;, [&#x27;content2&#x27;]); //DELETE FROM `tbl_post` WHERE `tbl_post`.`id`=&#x27;2&#x27; AND (content = &#x27;content2&#x27;) $this-&gt;assertEquals(1, $delete); &#125;&#125;","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii在IIS下的伪静态处理","date":"2025-06-03T07:09:10.000Z","path":"2025/06/03/Yii在IIS下的伪静态处理.html","text":"Yii在IIS下的伪静态处理是，在根目录建立httpd.ini文件，然后使用IIS的伪静态规则，写入自己需要的规则： 我购买的虚拟主机在香港，因为windows的主机比较多，于是我也中招了，于是四处寻求方法，四处尝试，终于找到了适合Yii的伪静态规则： 代码如下： 12345678910111213[ISAPI_Rewrite]# 3600 = 1 hourCacheClockRate 3600RepeatLimit 32RewriteEngine On#伪静态规则RewriteBase /RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)/(.*)$ $1/index.php?$2RewriteRule !\\.(js|ico|gif|jpe?g|bmp|png|css)$ index.php [L]我在虚拟机上测试通过了，哈哈，希望对你也有用","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii-Gii的安装和配置","date":"2025-06-03T07:05:48.000Z","path":"2025/06/03/Yii-Gii的安装和配置.html","text":"Gii 是基于 web 的 Yii framework 代码生成器。 开始配置 可以在你的应用程序配置文件中增加以下代码以使用该模块： 1234567&#x27;modules&#x27; =&gt; [ &#x27;gii&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;system.gii.GiiModule&#x27;, &#x27;username&#x27; =&gt; &#x27;dev&#x27;, &#x27;password&#x27; =&gt; &#x27;yiidev&#x27;, ],], 运行 打开浏览器，输入 http://localhost/yourapp/index.php?r=gii，使用刚才在配置文件中填的 username 和 password 登录。","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii分页设置","date":"2025-06-03T07:03:26.000Z","path":"2025/06/03/Yii分页设置.html","text":"yii自己是带有自动分页功能的。只要在对应的controller里面，类似下面这样鞋代码，就会实现的 1234567$dataProvider = new CActiveDataProvider( &#x27;Blog&#x27;, [ &#x27;pagination&#x27; =&gt; [&#x27;pageSize&#x27; =&gt; 10], &#x27;criteria&#x27; =&gt; [&#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;], ]); 但是样式还是yii中已经写好的，那么对于我，我要改掉这个样式，使用我提供的样式，可以像我下面这样写 1234567891011121314151617181920&lt;?php$this-&gt;widget(&#x27;zii.widgets.CListView&#x27;, [ &#x27;dataProvider&#x27; =&gt; $dataProvider, &#x27;itemView&#x27; =&gt; &#x27;_view&#x27;, &#x27;summaryCssClass&#x27; =&gt; &#x27;hide&#x27;, &#x27;pagerCssClass&#x27; =&gt; &#x27;pagination&#x27;, &#x27;pager&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLinkPager&#x27;, &#x27;nextPageLabel&#x27; =&gt; &#x27;&amp;raquo;&#x27;, &#x27;prevPageLabel&#x27; =&gt; &#x27;&amp;laquo;&#x27;, &#x27;firstPageLabel&#x27; =&gt; &#x27;最前&#x27;, &#x27;lastPageLabel&#x27; =&gt; &#x27;最后&#x27;, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;], &#x27;header&#x27; =&gt; &#x27;&#x27;, &#x27;hiddenPageCssClass&#x27; =&gt; &#x27;disabled&#x27;, &#x27;selectedPageCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;previousPageCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;nextPageCssClass&#x27; =&gt; &#x27;&#x27;, ],]); 其实只要添加自己对应的class属性就可以了，因为yii有自己默认的class属性，这个是比较简单。 下次我们可以看看，如何修改侧边下拉框，改为自己的喜欢的样式。","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii CDbCriteria常用方法","date":"2025-06-03T07:01:08.000Z","path":"2025/06/03/Yii-CDbCriteria常用方法.html","text":"Yii的Active Recorder包装了很多。 特别是把SQL中 把where,order,limit,IN&#x2F;not IN,like等常用短句都包含进CDbCriteria这个类中去，这样整个代码会比较规范，一目了然。 1234567891011121314151617181920212223$criteria = newCDbCriteria;$criteria-&gt;addCondition(&quot;id=1&quot;); //查询条件，即where id =1$criteria-&gt;addInCondition(&#x27;id&#x27;, [1, 2, 3, 4, 5]); //代表where id IN (1,23,,4,5,);$criteria-&gt;addNotInCondition(&#x27;id&#x27;, [1, 2, 3, 4, 5]); //与上面正好相法，是NOT IN$criteria-&gt;addCondition(&#x27;id=1&#x27;, &#x27;OR&#x27;); //这是OR条件，多个条件的时候，该条件是OR而非AND$criteria-&gt;addSearchCondition(&#x27;name&#x27;, &#x27;分类&#x27;); //搜索条件，其实代表了。。where name like ‘%分类%’$criteria-&gt;addBetweenCondition(&#x27;id&#x27;, 1, 4); //between1 and 4$criteria-&gt;compare(&#x27;id&#x27;, 1); //这个方法比较特殊，他会根据你的参数自动处理成addCondition或者addInCondition，//即如果第二个参数是数组就会调用addInCondition$criteria-&gt;addCondition(&quot;id = :id&quot;);$criteria-&gt;params[&#x27;:id&#x27;] = 1;$criteria-&gt;select = &#x27;id,parentid,name&#x27;; //代表了要查询的字段，默认select=’*&#x27;;$criteria-&gt;join = &#x27;xxx&#x27;; //连接表$criteria-&gt;with = &#x27;xxx&#x27;; //调用relations$criteria-&gt;limit = 10; //取1条数据，如果小于0，则不作处理$criteria-&gt;offset = 1; //两条合并起来，则表示 limit 10 offset1,或者代表了。limit 1,10$criteria-&gt;order = &#x27;xxx DESC,XXX ASC&#x27;; //排序条件$criteria-&gt;group = &#x27;group 条件&#x27;;$criteria-&gt;having = &#x27;having 条件 &#x27;;$criteria-&gt;distinct = false; //是否唯一查询","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii开启错误日志","date":"2025-06-03T06:56:27.000Z","path":"2025/06/03/Yii开启错误日志.html","text":"生产环境中的 Web 应用常需要具有完善的事件日志功能。在我们的博客应用中，我们想记录它在使用时发生的错误。这些错误可能是程序错误或者是用户对系统的不当使用导致的错误。记录这些错误可以帮助我们完善此博客应用。 为启用错误日志功能，我们修改 应用配置 如下, 1234567891011121314151617181920212223242526return [ &#x27;preload&#x27; =&gt; [&#x27;log&#x27;], // ...... &#x27;components&#x27; =&gt; [ &#x27;log&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLogRouter&#x27;, &#x27;routes&#x27; =&gt; [ [ &#x27;class&#x27; =&gt; &#x27;CFileLogRoute&#x27;, &#x27;levels&#x27; =&gt; &#x27;error, warning&#x27;, ], [ &#x27;class&#x27; =&gt; &#x27;CProfileLogRoute&#x27;, //显示页面加载的整个流程，包括mysql语句 &#x27;levels&#x27; =&gt; &#x27;profile&#x27;, ], [ &#x27;class&#x27; =&gt; &#x27;CWebLogRoute&#x27;, &#x27;levels&#x27; =&gt; &#x27;profile,trace&#x27;, ], ], ], //...... ],]; 通过上述配置，如果有错误（error）或警告（warning）发生，其详细信息将被记录并保存到位于&#x2F;wwwroot&#x2F;blog&#x2F;protected&#x2F;runtime目录的文件中。 log组件还提供了更多的高级功能，例如将日志信息发送到一个 Email 列表，在 JavaScript 控制台窗口中显示日志信息等。更多详情，请参考指南。","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"hexo默认处理heading的标题为id的异常解决方案","date":"2025-05-29T09:08:34.000Z","path":"2025/05/29/hexo默认处理heading的标题为id的异常解决方案.html","text":"hexo在处理markdown文档的时候，默认将heading的内容作为了id来处理锚点，如果是英文是没有问题的。 1## 我的标题 处理后的html内容 1&lt;h2 id=&quot;我的标题&quot;&gt;&lt;a href=&quot;#我的标题&quot; class=&quot;headerlink&quot; title=&quot;我的标题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#我的标题&quot;&gt;我的标题&lt;/a&gt;&lt;/h2&gt; 但是作为标题是中文的话就会有问题，以为在js的代码中，id是中文是不支持的，这会导致很多js库无法正常运行 找了很多资料，其中就有安装hexo-renderer-markdown-it 但是我自己亲自测试下来，还是很复杂，然后也没有解决我的问题，于是我思考这个hexo不会烂到这个程度吧 于是我看到了一种写法 1## [我的标题](#custom-id) 处理后的html内容 1&lt;h2 id=&quot;custom-id&quot;&gt;&lt;a href=&quot;#custom-id&quot; class=&quot;headerlink&quot; title=&quot;我的标题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#custom-id&quot;&gt;我的标题&lt;/a&gt;&lt;/h2&gt; 哎，可以，就这么轻松的解决了，不需要什么卸载安装什么的","tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.gowhich.com/tags/hexo/"}]},{"title":"Yii简单的基于角色的访问控制","date":"2025-05-29T07:28:14.000Z","path":"2025/05/29/Yii简单的基于角色的访问控制.html","text":"123456789101112131415161718192021function filters()&#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations ];&#125;function accessRules()&#123; return [ [ &#x27;allow&#x27;, &#x27;action&#x27; =&gt; [&#x27;admin&#x27;], &#x27;roles&#x27; =&gt; [&#x27;staff&#x27;, &#x27;devel&#x27;], ], [ &#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ];&#125; 用户模型在用户表中新增一列，列名 roles。建立相应的模型。在这里它将被命名为 “User”。 当添加用户可以给他们分配角色 “管理员”，“用户”，“员工”等等。 验证在文件 protected&#x2F;components&#x2F;UserIdentity.php 添加如下内容： 123456789101112131415161718192021222324class UserIdentity extends CUserIdentity&#123; private $id; public function authenticate() &#123; $record = User::model()-&gt;findByAttributes([&#x27;email&#x27; =&gt; $this-&gt;username]); if (null === $record) &#123; $this-&gt;errorCode = self::ERROR_USERNAME_INVALID; &#125; else if (md5($this-&gt;password) !== $record-&gt;password) &#123; $this-&gt;errorCode = self::ERROR_PASSWORD_INVALID; &#125; else &#123; $this-&gt;id = $record-&gt;id; $this-&gt;setState(&#x27;roles&#x27;, $record-&gt;roles); $this-&gt;errorCode = self::ERROR_NONE; &#125; return !$this-&gt;errorCode; &#125; public function getId() &#123; return $this-&gt;id; &#125;&#125; 重要的一行是 1$this-&gt;setState(&#x27;roles&#x27;, $record-&gt;roles); 他给会话增加了用户角色。你可以使用如下代码获取用户角色。 1Yii:app()-&gt;user-&gt;getState(&quot;roles&quot;) 或 1Yii::app()-&gt;user-&gt;roles 检查权限:结构在 protected&#x2F;components 文件夹下修改并创建文件 WebUser.php ,然后重写 checkAccess() 方法。 123456789101112131415161718192021222324&lt;?phpclass WebUser extends CWebUser&#123; /** * Overrides a Yii method that is used for roles in controllers (accessRules). * * @param string $operation Name of the operation required (here, a role). * @param mixed $params (opt) Parameters for this operation, usually the object to access. * @return bool Permission granted? */ public function checkAccess($operation, $params = []) &#123; if (empty($this-&gt;id)) &#123; // Not identified =&gt; no rights return false; &#125; $role = $this-&gt;getState(&quot;roles&quot;); if (&#x27;admin&#x27; === $role) &#123; return true; // admin role has access to everything &#125; // allow access if the operation request is the current user&#x27;s role return ($operation === $role); &#125;&#125; 在 checkAccess() 方法中你可以定义自己的逻辑。确保类可以被yii使用配置文件 “protected&#x2F;config&#x2F;main.php” 必须包含以下内容: 123456&#x27;components&#x27; =&gt; [ // ... &#x27;user&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;WebUser&#x27;, ],] 旁注:[CWebUser::checkAccess()] 通常连接yii的验证系统。这里我们使用一个简单的处理角色的系统来替换[CAuthManager] 定义的分级系统。详细教程参加 Role-Based Access Control 检查权限: 使用在你的 PHP 代码中使用 Yii::app()-&gt;user-&gt;checkAccess(&#39;admin&#39;) 来检查当前用户是否有 ‘admin’ 角色。 当用户拥有 “staff” 或 “admin” 角色时，调用 Yii::app()-&gt;user-&gt;checkAccess(&quot;staff&quot;) 将会返回 true。 在控制器中你可以使用 accessRules() 中的 “roles” 属性进行过滤。 见下面的例子。 怎样过滤动作 控制器必须包含以下代码： 123456789101112131415161718192021function filters()&#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations ];&#125;function accessRules()&#123; return [ [ &#x27;allow&#x27;, &#x27;action&#x27; =&gt; [&#x27;admin&#x27;], &#x27;roles&#x27; =&gt; [&#x27;staff&#x27;, &#x27;devel&#x27;], ], [ &#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ];&#125; 这里对控制器中的 “admin” 动作进行了限制访问: 只有拥有 “staff” 或 “devel” 角色才可以访问。 像API文档中描述的那样 CAccessRule, “roles” 属性实际上调用的是 Yii::app()-&gt;user-&gt;checkAccess() 方法。 怎样根据角色显示不同菜单 你只需使用一个基于用户角色的菜单。例如 12345678910&lt;?php$user = Yii::app()-&gt;user; // just a convenience to shorten expressions$this-&gt;widget(&#x27;zii.widgets.CMenu&#x27;, [ &#x27;items&#x27; =&gt; [ [&#x27;label&#x27; =&gt; &#x27;Users&#x27;, &#x27;url&#x27; =&gt; [&#x27;/manageUser/admin&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;checkAcces(&#x27;staff&#x27;)], [&#x27;label&#x27; =&gt; &#x27;Your Ideas&#x27;, &#x27;url&#x27; =&gt; [&#x27;/userarea/ideaList&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;checkAcces(&#x27;normal&#x27;)], [&#x27;label&#x27; =&gt; &#x27;Login&#x27;, &#x27;url&#x27; =&gt; [&#x27;/site/login&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;isGuest], [&#x27;label&#x27; =&gt; &#x27;Logout (&#x27; . Yii::app()-&gt;user-&gt;name . &#x27;)&#x27;, &#x27;url&#x27; =&gt; [&#x27;/site/logout&#x27;], &#x27;visible&#x27; =&gt; !$user-&gt;isGuest], ],]); 更进一步: 访问上下文一个通常的需求，用户只能够修改自己的数据。在这种情况下，用户的角色是没有任何意义的：将要修改的数据。 这就是为什么 [CWebUser::checkAccess()] 有一个可选的参数 “$param” 。现在假设我们要检查的是一个用户是否有权更新Post记录的权限。我们可以这样写： 123if (Yii::app()-&gt;user-&gt;checkAccess(&#x27;normal&#x27;, $post)) &#123; // .....&#125; 当然 WebUser::checkAccess() 必须被扩展来使用 “$params” 参数。这将取决于你的应用程序的逻辑。比如, 这可能是非常简单的 $post-&gt;userId == $this-&gt;id。","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii扩展类可以放在extensions目录下面","date":"2025-05-29T07:25:04.000Z","path":"2025/05/29/Yii扩展类可以放在extensions目录下面.html","text":"下面举个例子： 如果我想写个截取字符串长度的函数功能，可以在extensions目录下面新建一个文件，命名为Helper.php 代码如下： 123456789101112131415161718192021222324252627&lt;?phpclass Helper extends CController&#123; public static function truncate_utf8_string($string, $length, $etc = &#x27;...&#x27;) &#123; $result = &#x27;&#x27;; $string = html_entity_decode(trim(strip_tags($string)), ENT_QUOTES, &#x27;UTF-8&#x27;); $strlen = strlen($string); for ($i = 0; (($i &lt; $strlen) &amp;&amp; ($length &gt; 0)); $i++)&#123; if ($number = strpos(str_pad(decbin(ord(substr($string, $i, 1))), 8, &#x27;0&#x27;, STR_PAD_LEFT), &#x27;0&#x27;))&#123; if ($length &lt; 1.0)&#123; break; &#125; $result .= substr($string, $i, $number); $length -= 1.0; $i += $number - 1; &#125;else&#123; $result .= substr($string, $i, 1); $length -= 0.5; &#125; &#125; $result = htmlspecialchars($result, ENT_QUOTES, &#x27;UTF-8&#x27;); if ($i &lt; $strlen)&#123; $result .= $etc; &#125; return $result; &#125;&#125; 然后就可以在自己的代码中引用了Helper::truncate_utf8_string(&#39;XXXXXXXXXXX&#39;,10,&#39;.......&#39;); 如果出现问题可以在config/main.php中加入在import引入要加载扩展的目录 类似： 123456&#x27;import&#x27;=&gt; array( &#x27;application.models.*&#x27;, &#x27;application.components.*&#x27;, &#x27;application.extensions.*&#x27;, // 新加 &#x27;application.extensions.yii-mail.*&#x27;,),","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"Yii中urlManager的配置","date":"2025-05-29T06:30:29.000Z","path":"2025/05/29/Yii中urlManager的配置.html","text":"第一步： 在main.php配置文件的component域中添加urlManager模块，并加入urlrules. 引入rule文件，代码如下 123456789$urls = include(dirname(__FILE__) . &#x27;/urlrules.php&#x27;);urlManager配置修改如下&#x27;urlManager&#x27;=&gt;array( &#x27;urlFormat&#x27; =&gt; &#x27;path&#x27;, &#x27;showScriptName&#x27; =&gt; false,//隐藏index.php &#x27;urlSuffix&#x27; =&gt; &#x27;.html&#x27;,//后缀 &#x27;rules&#x27; =&gt; $urls,), 第二步:在同级目录下写urlrules.php.如： 12345return array( &#x27;/index.html&#x27; =&gt; &#x27;site/index&#x27;, //首页 &#x27;search&#x27; =&gt; &#x27;search/index&#x27;，); 第三步，当然是配置服务器的rewrite模块，使得入口为index.php 1)apache下，在网站根目录下建立.htaccess如下: 12345678910Options +FollowSymLinks IndexIgnore */* RewriteEngine on # if a directory or a file exists, use it directly RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . index.php nginx下在php配置模块和location模块添加rewrite如下： 123456789101112131415161718location / &#123; root /home/george/workspace/EclipsePHP/webroot; index index.html index.php index.htm; #try_files $uri $uri/ @rewrite; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125;&#125;location ~ \\.php$ &#123; root /home/george/workspace/EclipsePHP/webroot; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/george/workspace/EclipsePHP/webroot$fastcgi_script_name; include fastcgi_params; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125;&#125; 完了，再看看你的网站的url 是不是漂亮了不少，同行努力！","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"}]},{"title":"ubuntu和centos的时间更新操作","date":"2025-05-29T02:38:04.000Z","path":"2025/05/29/ubuntu和centos的时间更新操作.html","text":"在Ubuntu Server上，设置NTP时间同步非常简单，就如下几步： 第一，可以先进行手动更新一次时间（可选）： sudo ntpdate ntp.ubuntu.com 第二，创建一个定时执行的文件： sudo vim /etc/cron.daily/ntpdate 然后在其中添加一行：ntpdate ntp.ubuntu.com，保存退出。 第三，修改这个定时执行文件的权限，使其变成可执行文件： sudo chmod 755 /etc/cron.daily/ntpdate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 下面解析一下,第一句是把当前时区调整为上海就是+8区,想改其他时区也可以去看看&#x2F;usr&#x2F;share&#x2F;zoneinfo目录; 然后第二句是利用ntpdate同步标准时间. 没有安装ntpdate的可以yum一下: yum install -y ntpdate 加入定时计划任务，每隔10分钟同步一下时钟 crontab -e 0-59/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP 这样，我们就可以来解决在CentOS系统中时间不准确的问题了。 如果执行命令出现一下错误 1.提示：7 Dec 19:24:55 ntpdate[2120]: the NTP socket is in use, exiting 这个是你linux机器上已经存在这个进程，输入：ps -ef | grep ntpd Kill掉ntp的进程 2.提示：No Server suitable for synchronization found 这个是最容易出现的问题，比较常见的是配置好服务器并启动服务器进程后，马上 启动客户进程，那么客户进程就会报错。解决方法是，在大约3-5分钟以后启动进程就行","tags":[{"name":"linux","slug":"linux","permalink":"https://blog.gowhich.com/tags/linux/"}]},{"title":"Hello World","date":"2025-05-28T08:10:14.000Z","path":"2025/05/28/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.gowhich.com/tags/hexo/"}]},{"title":"开始第一篇记录","date":"2025-05-28T08:10:14.000Z","path":"2025/05/28/开始第一篇记录.html","text":"这是第一篇记录","tags":[{"name":"php","slug":"php","permalink":"https://blog.gowhich.com/tags/php/"},{"name":"linux","slug":"linux","permalink":"https://blog.gowhich.com/tags/linux/"}]}]