[{"title":"iOS CGFloat CGPoint CGSize和CGRect","date":"2025-06-06T02:35:44.000Z","path":"2025/06/06/iOS-CGFloat-CGPoint-CGSize和CGRect.html","text":"CGGeometry类定义几何元素的结构和操作几何元素的函数。 1、数据类型：CGFloat: 浮点值的基本类型 CGPoint: 表示一个二维坐标系中的点 CGSize: 表示一个矩形的宽度和高度 CGRect: 表示一个矩形的位置和大小 1234567891011121314151617typedef float CGFloat;// 32-bittypedef double CGFloat;// 64-bitstruct CGPoint &#123; CGFloat x; CGFloat y;&#125;;typedef struct CGPoint CGPoint;struct CGSize &#123; CGFloat width; CGFloat height;&#125;;typedef struct CGSize CGSize;struct CGRect &#123; CGPoint origin; CGSize size;&#125;;typedef struct CGRect CGRect; 注意：CGRect数据结构的高度和宽度可以是负数。例如，一个矩形的原点是[0.0，0.0]和大小是[10.0,10.0]。这个矩形完全等同原点是[10.0，10.0]和大小是[-10.0，-10.0]的矩形。 2、使用值来创建几何元素的方法CGPointMake、CGRectMake、CGSizeMake12345678910111213141516171819202122232425CGPoint CGPointMake ( CGFloat x, CGFloat y );CGSize CGSizeMake ( CGFloat width, CGFloat height );CGRect CGRectMake ( CGFloat x, CGFloat y, CGFloat width, CGFloat height );CGFloat ten=10.0f;CGPoint point = CGPointMake(0.0f, 0.0f);CGSize size = CGSizeMake(10.0f, 10.0f);CGRect rect = CGRectMake(point.x, point.y, size.width, size.height);NSLog(@&quot;ten: %f&quot;, ten);NSLog(@&quot;point: %@&quot;, NSStringFromCGPoint(point));NSLog(@&quot;size: %@&quot;, NSStringFromCGSize(size));NSLog(@&quot;rect: %@&quot;, NSStringFromCGRect(rect));","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS UIScreen（屏幕）UIWindow（画框)UIView(画布)didFinishLaunchingWithOptions的概念","date":"2025-06-06T02:33:47.000Z","path":"2025/06/06/iOS-UIScreen（屏幕）UIWindow（画框-UIView-画布-didFinishLaunchingWithOptions的概念.html","text":"didFinishLaunchingWithOptions 方法：顾名思义。在app开始运行时会调用里面的方法。 12345678910111213141516171819202122232425262728- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; //返回的是带有状态栏的矩形 self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease]; CGRect bound = [[UIScreen mainScreen]bounds]; //返回的是不带有状态栏的Rect NSLog(@&quot;boundwith:%f boundheight:%f&quot;,bound.size.width,bound.size.height); NSLog(@&quot;boundx:%f boundy:%f&quot;,bound.origin.x,bound.origin.y); //2012-08-03 23:21:45.716 DinkMixer[599:c07] boundwith:320.000000 boundheight:480.000000 //2012-08-03 23:21:45.719 DinkMixer[599:c07] boundx:0.000000 boundy:0.000000 CGRect appBound = [[UIScreen mainScreen]applicationFrame]; //返回的是带有状态栏的Rect NSLog(@&quot;appBoundwith:%f boundheight:%f&quot;,appBound.size.width,appBound.size.height); NSLog(@&quot;appBoundx:%f boundy:%f&quot;,appBound.origin.x,appBound.origin.y); //2012-08-03 23:21:45.720 DinkMixer[599:c07] appBoundwith:320.000000 boundheight:460.000000 //2012-08-03 23:21:45.720 DinkMixer[599:c07] appBoundx:0.000000 boundy:20.000000 //很明显状态栏占用了空间20像素 MasterViewController *masterViewController = [[[MasterViewController alloc] initWithNibName:@&quot;MasterViewController&quot; bundle:nil] autorelease];//根据nib文件的名称来创建一个视图控制器 self.navigationController = [[[UINavigationController alloc] initWithRootViewController:masterViewController] autorelease];//创建一个导航控制器，并指定该导航控制器的根视图控制器为上面建立的masterViewController self.window.rootViewController = self.navigationController;//窗体（window）有一个根视图控制器——这个视图控制器负责配置当窗体显示时最先显示的视图。要让你的视图控制器的内容显示在窗体中，需要去设置窗体的根视图控制器为你的视图控制器。 [self.window makeKeyAndVisible];//这行代码会让包含了视图控制器视图的Window窗口显示在屏幕上。 return YES;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"Linux查看文件系统类型","date":"2025-06-06T02:27:33.000Z","path":"2025/06/06/Linux查看文件系统类型.html","text":"1. mount123456789101112131415161718:~$ mount/dev/sda1 on / type ext4 (rw,errors=remount-ro,user_xattr)proc on /proc type proc (rw,noexec,nosuid,nodev)none on /sys type sysfs (rw,noexec,nosuid,nodev)none on /sys/fs/fuse/connections type fusectl (rw)none on /sys/kernel/debug type debugfs (rw)none on /sys/kernel/security type securityfs (rw)none on /dev type devtmpfs (rw,mode=0755)none on /dev/pts type devpts (rw,noexec,nosuid,gid=5,mode=0620)none on /dev/shm type tmpfs (rw,nosuid,nodev)none on /var/run type tmpfs (rw,nosuid,mode=0755)none on /var/lock type tmpfs (rw,noexec,nosuid,nodev)none on /lib/init/rw type tmpfs (rw,nosuid,mode=0755)none on /var/lib/ureadahead/debugfs type debugfs (rw,relatime)none on /proc/fs/vmblock/mountPoint type vmblock (rw)binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,noexec,nosuid,nodev)gvfs-fuse-daemon on /home/kysnail/.gvfs type fuse.gvfs-fuse-daemon (rw,nosuid,nodev,user=kysnail):~$ 2. df12345678910:~$ df -lhT文件系统 类型 容量 已用 可用 已用% 挂载点/dev/sda1 ext4 19G 11G 7.8G 57% /none devtmpfs 498M 248K 497M 1% /devnone tmpfs 502M 252K 501M 1% /dev/shmnone tmpfs 502M 96K 502M 1% /var/runnone tmpfs 502M 0 502M 0% /var/locknone tmpfs 502M 0 502M 0% /lib/init/rwnone debugfs 19G 11G 7.8G 57% /var/lib/ureadahead/debugfs:~$ 3. fdisk123456789101112131415161718192021222324252627:~$ sudo fdisk /dev/sdaWARNING: DOS-compatible mode is deprecated. It&#x27;s strongly recommended to switch off the mode (command &#x27;c&#x27;) and change display units to sectors (command &#x27;u&#x27;).Command (m for help): cDOS Compatibility flag is not setCommand (m for help): uChanging display/entry units to sectorsCommand (m for help): pDisk /dev/sda: 21.5 GB, 21474836480 bytes heads, 63 sectors/track, 2610 cylinders, total 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x00077544Device Boot Start End Blocks Id System/dev/sda1 * 2048 40105983 20051968 83 Linux/dev/sda2 40108030 41940991 916481 5 Extended/dev/sda5 40108032 41940991 916480 82 Linux swap / SolarisCommand (m for help): q 4. file12345:~$ sudo file -s /dev/sda/dev/sda: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 40103936 sectors; partition 2: ID=0x5, starthead 254, startsector 40108030, 1832962 sectors, code offset 0x63kysnail@ubunkysnail:~$ sudo file -s /dev/sda1/dev/sda1: Linux rev 1.0 ext4 filesystem data, UUID=4942da40-8a49-4bfd-9dc2-45c906d48413 (needs journal recovery) (extents) (large files) (huge files):~$ 5. parted12345678910111213141516:~$ sudo partedGNU Parted 2.2使用 /dev/sda欢迎使用 GNU Parted! 输入 &#x27;help&#x27;可获得命令列表.(parted) p Model: VMware, VMware Virtual S (scsi)磁盘 /dev/sda: 21.5GBSector size (logical/physical): 512B/512B分区表：msdos数字 开始： End 大小 类型 文件系统 标志 1049kB 20.5GB 20.5GB primary ext4 启动 20.5GB 21.5GB 938MB extended 20.5GB 21.5GB 938MB logical linux-swap(v1)(parted) 6. 查看 fstab12345678910111213# /etc/fstab: static file system information.## Use &#x27;blkid -o value -s UUID&#x27; to print the universally unique identifier# for a device; this may be used with UUID= as a more robust way to name# devices that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;proc /proc proc nodev,noexec,nosuid 0 0# / was on /dev/sda1 during installationUUID=4942da40-8a49-4bfd-9dc2-45c906d48413 / ext4 errors=remount-ro,user_xattr 0 1# swap was on /dev/sda5 during installationUUID=935fb95d-771f-448e-9d23-4820106e1783 none swap sw 0 0/dev/fd0 /media/floppy0 auto rw,user,noauto,exec,utf8 0 0","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"}]},{"title":"Can't connect to MySQL server on 'xxx.xxx.xxx.xxx' (61)","date":"2025-06-05T09:37:45.000Z","path":"2025/06/05/Can-t-connect-to-MySQL-server-on-xxx-xxx-xxx-xxx-61.html","text":"我要在本机链接我本机上虚拟机的mysql，我使用mac下的workbench，就就是连接不上，报错信息为：“Can’t connect to MySQL server on ‘10.211.55.5’ (61)”，查了好多资料，有一种方法解决了我的问题： 第一步：查看是都3306端口开启使用ufw（不会安装的，请与我联系）， 1sudo ufw status 或者直接使用命令 1netstat -an | grep 3306 如果结果显示类似： 1tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN 从结果可以看出3306端口只是在IP 127.0.0.1上监听，所以拒绝了其他IP的访问。 第二步：修改配置文件修改文件 &#x2F;etc&#x2F;mysql&#x2F;my.cnf文件，打开文件，找到下面内容： 123# Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.bind-address = 127.0.0.1 把上面这一行注释掉或者把127.0.0.1换成合适的IP，建议注释掉。重新启动后，重新使用netstat检测： 12~# netstat -an | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 第三步： 使用创建的用户登录一下，成功。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.gowhich.com/tags/MySQL/"}]},{"title":"Centos下SVN的配置","date":"2025-06-05T09:31:37.000Z","path":"2025/06/05/centos下svn的配置.html","text":"在终端运行svn命令.如果没有安装,系统会提示安装 1.首先需要安装Subversion软件： 1sudo apt-get install subversion 2.建立一个文件夹作为版本库的根目录 1mkdir /var/svnroot/ 这个目录本身不是版本库，只是拿来装版本库的目录 3.进入这个目录，创建版本库 12cd /var/svnroot/svnadmin create mysvn 以后如果有多个项目，可以继续在&#x2F;var&#x2F;svnroot&#x2F;下面create新的版本库 4.配置vlink 12cd /var/svnroot/vlink/conf/ls 将会看到以下文件 1authz passwd svnserve.conf 首先编辑 svnserve.conf 1vim svnserve.conf 其中 anon-access 表示 匿名用户的权限，auth-access 表示经过认证的用户的权限。去掉前面的#注释，顶格写。一般说来像这样就可以了： 12anon-access = noneauth-access = write 然后看到下面有 password-db 这个配置项。 这个是配置使用的密码文件。 1password-db = passwd 为了以后多个版本库同时运行，建议改这个文件到 &#x2F;var&#x2F;svnroot&#x2F;下面。比如： &#x2F;var&#x2F;svnroot&#x2F;passed 1password-db =/var/svnroot/passed 同理，authz-db这个也是，像这样： 1/var/svnroot/authz 然后有个东西叫做realm，这个貌似是连接svn服务器的时候的提示句子。。不过设置成vlink的名字肯定没错。比如 vlink 1realm = vlink 其他的不管。保存退出。 5.编辑 &#x2F;var&#x2F;svnroot&#x2F;passwd这个简单，像这样就可以了： 123[users]username=passwordusername=password 6.启动svnserve 1sudo svnserve -d -r /var/svnroot/ -r 后面的参数是svnroot位置，而不是某个版本库的位置要关闭svnserve可以直接用 kill 结束掉那个进程 7.Configure iptables如果服务器上设置了iptables的话,你需要开启3690端口. 12iptables -A INPUT -p tcp -i eth0 --dport 3690 -j ACCEPT/sbin/iptables -A INPUT -p tcp -i eth0 --dport 3690 -j ACCEPT 查看ipatbles: iptables -L 如果出现下面一行表示设置成功了: 1… ACCEPT tcp – anywhere anywhere tcp dpt:svn 8.测试 在本地 svn co svn://xxx.xxx.xxx.xxx/vlink –username xxx –password xxx如果还有问题的我建议是将svnserve.conf文件中的有关authz注释掉，在测试。我做的时候是有上面的问题，后来师兄注释掉后就好了，具体我也不明白什么原因如何将想要的svn库中文件备份导出和导入呢（这里我没有测试过，大家可以测试一下，我们共同探讨） 9.将原来的Repository导出为一个文件dumpfile 1svnadmin dump path/to/old-repo &gt; dumpfile.svn 10.将dumpfile导入到新的Repository 1svnadmin load path/to/new-repo &lt; dumpfile.svn 11.本机svn的快速迁移方法: 1svnadmin hotcopy old_rep_path new_rep_path 12.将原先服务器的配置文件备份后复制到新服务器中/etc/httpd/conf.d/subversion.conf还有repository目录下的authfile、auth.conf也需要备份后复制到新服务器中 13.linux下重新定位SVN URL方法:如果更换了SVN服务器，就需要重新定位，指向新的SVN URL。重新定位命令：svn switch --relocate 原svn地址 新svn地址如何查看原svn地址？查看原svn路径方法：svn info","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://blog.gowhich.com/tags/Centos/"}]},{"title":"iOS存储方式","date":"2025-06-05T03:06:45.000Z","path":"2025/06/05/iOS存储方式.html","text":"第一种:NSKeyedArchiver（加密形式）代码很简单就不多解释了直接上代码： 123456789101112131415161718//=================NSKeyedArchiver========================NSString *saveStr1 = @ &quot;我是&quot; ;NSString *saveStr2 = @ &quot;数据&quot; ;NSArray *array = [NSArray arrayWithObjects:saveStr1, saveStr2, nil];//----Save//这一句是将路径和文件名合成文件完整路径NSString *Path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSString *filename = [Path stringByAppendingPathComponent:@ &quot;saveDatatest&quot; ];[NSKeyedArchiver archiveRootObject:array toFile:filename];//用于测试是否已经保存了数据saveStr1 = @ &quot;hhhhhhiiii&quot; ;saveStr2 =@ &quot;mmmmmmiiii&quot; ;//----Loadarray = [NSKeyedUnarchiver unarchiveObjectWithFile: filename];saveStr1 = [array objectAtIndex:0];saveStr2 = [array objectAtIndex:1];NSLog(@ &quot;str:%@&quot; ,saveStr1);NSLog(@ &quot;astr:%@&quot; ,saveStr2); 第二种:NSUserDefaults举个简单的例子 1234567891011121314151617//=================NSUserDefaults========================NSString *saveStr1 = @ &quot;我是&quot; ;NSString *saveStr2 = @ &quot;数据&quot; ;NSArray *array = [NSArray arrayWithObjects:saveStr1, saveStr2, nil];//SaveNSUserDefaults *saveDefaults = [NSUserDefaults standardUserDefaults];[saveDefaults setObject:array forKey:@ &quot;SaveKey&quot; ];//用于测试是否已经保存了数据saveStr1 = @ &quot;hhhhhhiiii&quot; ;saveStr2 =@ &quot;mmmmmmiiii&quot; ;//---Loadarray = [saveDefaults objectForKey:@ &quot;SaveKey&quot; ];saveStr1 = [array objectAtIndex:0];saveStr2 = [array objectAtIndex:1];NSLog(@ &quot;str:%@&quot; ,saveStr1);NSLog(@ &quot;astr:%@&quot; ,saveStr2); 第三种:Write写入方式举个例子，也很简单的 123456789101112131415161718192021222324252627//=================Write写入方式========================NSString *saveStr1 = @ &quot;我是&quot; ;NSString *saveStr2 = @ &quot;数据&quot; ;NSArray *array = [NSArray arrayWithObjects:saveStr1, saveStr2, nil];//----SaveNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];if (!documentsDirectory) &#123; NSLog(@ &quot;没找到&quot; );&#125;NSMutableArray *saveDataArray=nil;NSString *appFile = [documentsDirectory stringByAppendingPathComponent:@ &quot;Savedatas.plist&quot; ];[[NSArray arrayWithObjects:array,nil] writeToFile:appFile atomically:NO];//用于测试是否已经保存了数据saveStr1 = @ &quot;hhhhhhiiii&quot; ;saveStr2 =@ &quot;mmmmmmiiii&quot; ;//----Loadif ([[NSFileManager defaultManager] fileExistsAtPath:appFile])&#123; saveDataArray = [NSMutableArray arrayWithContentsOfFile:appFile];&#125;else&#123; saveDataArray = [NSMutableArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@ &quot;Savedatas&quot; ofType:@ &quot;plist&quot; ]];&#125;NSArray *strArray = [saveDataArray objectAtIndex:0];saveStr1 = [strArray objectAtIndex:0];saveStr2 = [strArray objectAtIndex:1];NSLog(@ &quot;str:%@&quot; ,saveStr1);NSLog(@ &quot;astr:%@&quot; ,saveStr2); 第四种:SQLite3在使用sqlite3之前 你需要将libsqlite3.dylib这个类库加入到你的项目中 123456789- (NSString *)dataFilePath&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; return [documentsDirectory stringByAppendingPathComponent:kFilename];&#125;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0]; //首先得到应用程序沙盒中Document文件夹的路径return [documentsDirectory stringByAppendingPathComponent:kFilename]//返回你指定文件的路径 打开数据库 12345sqlite3 *database;if(sqlite3_open([filePath UTF8String], &amp;database)) &#123; sqlite3_close(database); NSAssert(0,@&quot;Failed to open database&quot;);&#125; 创建数据库 123456char *errorMsg;NSString *createSQL = @&quot;CREATE TABLE IF NOT EXISTS FIELDS (ROW INTEGER PRIMARY KEY,FIELD_DATA TEXT);&quot;;if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg)!=SQLITE_OK) &#123; sqlite3_close(database); NSAssert1(0,@&quot;Error creating table:%s&quot;,errorMsg);&#125; 数据查询 123456789101112131415161718NSString *query = @&quot;SELECT ROW, FIELD_DATA FROM FIELDS ORDER BY ROW&quot;;sqlite3_stmt *statement;if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil)==SQLITE_OK) &#123; while (sqlite3_step(statement)==SQLITE_ROW) &#123; int row = sqlite3_column_int(statement, 0); char *rowData = (char *)sqlite3_column_text(statement, 1); //NSString *fieldName = [[NSString alloc] initWithFormat:@&quot;field&amp;d&quot;,row]; //NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData]; //UITextField *field = [self valueForKey:fieldName]; //field.text = fieldValue; //[fieldName release]; //[fieldValue release]; &#125; sqlite3_finalize(statement);&#125;sqlite3_close(database); 数据插入／更新 12345678910111213141516171819202122232425sqlite3 *database;if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database)) &#123; sqlite3_close(database); NSAssert(0,@&quot;Failed to open database&quot;);&#125; for (int i=1; i&lt;=4; i++) &#123; NSString *fieldName = [[NSString alloc] initWithFormat:@&quot;field%d&quot;,i]; UITextField *field = [self valueForKey:fieldName]; [fieldName release]; char *errorMsg; char *update = &quot;INSERT OR REPLACE INTO FIELDS (ROW,FIELD_DATA) VALUES(?,?);&quot;; //这里插入的值可以用nsstring替换，但是最好的做法是使用绑定，如果遇到特殊字符 这是不二选择 sqlite3_stmt *stmt; if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil)==SQLITE_OK) &#123; sqlite3_bind_int(stmt, 1, i); sqlite3_bind_text(stmt, 2, [[field text] UTF8String], -1, NULL); &#125; if (sqlite3_step(stmt)!=SQLITE_DONE) &#123; NSAssert(0,@&quot;Error updating table:%s&quot;,errorMsg); &#125; sqlite3_finalize(stmt);&#125;sqlite3_close(database); #######################可爱分割线############################# 对Write写入方式保存数据和读取数据封装了两个方法： 封装的函数如下： 1234567891011121314151617181920212223242526//保存游戏数据 //参数介绍： // (NSMutableArray *)data ：保存的数据 // (NSString *)fileName ：存储的文件名 -(BOOL) saveGameData:(NSMutableArray *)data saveFileName:(NSString *)fileName &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; if (!documentsDirectory) &#123; NSLog(@&quot;Documents directory not found!&quot;); return NO; &#125; NSString *appFile = [documentsDirectory stringByAppendingPathComponent:fileName]; return ([data writeToFile:appFile atomically:YES]); &#125; //读取游戏数据 //参数介绍： // (NSString *)fileName ：需要读取数据的文件名 -(id) loadGameData:(NSString *)fileName &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSString *appFile = [documentsDirectory stringByAppendingPathComponent:fileName]; NSMutableArray *myData = [[[NSMutableArray alloc] initWithContentsOfFile:appFile] autorelease]; return myData; &#125; 可以使用类似下面的例子进行使用 123456NSString *saveStr1 = @&quot;测试保存读取&quot;; NSString *saveStr2 = @&quot;两个函数&quot;; NSMutableArray *array = [NSMutableArray arrayWithObjects:saveStr1, saveStr2, nil]; [self saveGameData:array saveFileName:@&quot;Himi&quot;]; NSMutableArray*temp =(NSMutableArray*)[self loadGameData:@&quot;Himi&quot;]; NSLog(@&quot;%@--%@&quot;,[temp objectAtIndex:0],[temp objectAtIndex:1]); 有两点需要注意的地方： 1，取出数据的时候需要注意 12NSUserDefaults *saveDefaults = [NSUserDefaults standardUserDefaults]; NSMutableArray *arraySaveData =[saveDefaults objectForKey:@&quot;OhSaveData&quot;]; //NSMutableArray *arraySaveData=[NSMutableArray arrayWithArray:[saveDefaults objectForKey:@&quot;OhSaveData&quot;]]; 第二句代码是通过一个文件名获取你存储的数据，返回数据数组，但是！一定要注意这里返回的数据数组是不可修改的！及时你将读取的数据赋给一个可修改的数组中也一样无法修改其中的数据，所以如果你想将取出的数据进行修改那么这里需要要使用第三行代码来获取 2，修改已经的存储文件 12NSUserDefaults *saveDefaults = [NSUserDefaults standardUserDefaults]; [saveDefaults setObject:arraySaveData forKey:@&quot;已经存在的文件名&quot;];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"Yii使用model进行设置查询规则/模型/控制器","date":"2025-06-05T02:52:51.000Z","path":"2025/06/05/Yii使用model进行设置查询规则-模型-控制器.html","text":"yii有个查询数据的便利的地方，就是可以在model层设置查询规则，然后在controller层，直接调用，进行数据查询： 举个例子说明一下： 先从model层说起：model名称叫做Blog，继承自CActiveRecord 123456789101112131415function scopes()&#123; return [ &#x27;published&#x27; =&gt; [ &#x27;condition&#x27; =&gt; &#x27;status=1&#x27;, ], &#x27;recently&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, &#x27;limit&#x27; =&gt; 5, ], &#x27;createDateDesc&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, ], ];&#125; 在上面的代码中，继承函数scopes,然后在里面命名自己想要使用的规则名称。 我这里使用了 published，recently，createCateDesc，分别对应sql语句的一部分，这个在调用controller的时候会合并到总的sql语句里面去的。 下面看在controller里面怎么使用 12345678910111213//最近的博文$rawData = Blog::model()-&gt;recently()-&gt;findAll();$rawData = new CArrayDataProvider($rawData, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;title&#x27;, ], ], &#x27;pagination&#x27; =&gt; [ &#x27;pageSize&#x27; =&gt; 10, ],]); 我在自己的BlogController控制器，action为actionView的方法中引用了这样一个代码： 注意其中的recently部分 1$rawData=Blog::model()-&gt;recently()-&gt;findAll(); 这个就是我们在model层设置的规则，在这里作为方法被调用了。 是不是很方便呀。 详细的代码我贴到下面： model123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?php/** * This is the model class for table &quot;tbl_blog&quot;. * * The followings are the available columns in table &#x27;tbl_blog&#x27;: * @property integer $id * @property string $title * @property string $description * @property string $create_date * @property string $update_date */class Blog extends CActiveRecord&#123; /** * Returns the static model of the specified AR class. * @param string $className active record class name. * @return Blog the static model class */ public static function model($className = __CLASS__) &#123; return parent::model($className); &#125; /** * @return string the associated database table name */ public function tableName() &#123; return &#x27;tbl_blog&#x27;; &#125; /** * @return array validation rules for model attributes. */ public function rules() &#123; // NOTE: you should only define rules for those attributes that // will receive user inputs. return [ [&#x27;title&#x27;, &#x27;required&#x27;, &#x27;message&#x27; =&gt; &#x27;标题不能为空&#x27;], [&#x27;description&#x27;, &#x27;required&#x27;, &#x27;message&#x27; =&gt; &#x27;内容不能为空&#x27;], [&#x27;title&#x27;, &#x27;length&#x27;, &#x27;max&#x27; =&gt; 255], [&#x27;tag&#x27;, &#x27;safe&#x27;], [&#x27;type_id&#x27;, &#x27;safe&#x27;], [&#x27;update_date&#x27;, &#x27;safe&#x27;], // The following rule is used by search(). // Please remove those attributes that should not be searched. [&#x27;id, title, description, create_date, update_date&#x27;, &#x27;safe&#x27;, &#x27;on&#x27; =&gt; &#x27;search&#x27;], ]; &#125; /** * @return array relational rules. */ public function relations() &#123; // NOTE: you may need to adjust the relation name and the related // class name for the relations automatically generated below. return [ ]; &#125; /** * @return array customized attribute labels (name=&gt;label) */ public function attributeLabels() &#123; return [ &#x27;id&#x27; =&gt; &#x27;ID序号&#x27;, &#x27;title&#x27; =&gt; &#x27;标题&#x27;, &#x27;description&#x27; =&gt; &#x27;内容&#x27;, &#x27;tag&#x27; =&gt; &#x27;标签(使用逗号进行分割)&#x27;, &#x27;type_id&#x27; =&gt; &#x27;分类类型&#x27;, &#x27;create_date&#x27; =&gt; &#x27;创建时间&#x27;, &#x27;update_date&#x27; =&gt; &#x27;更新时间&#x27;, ]; &#125; /** * Retrieves a list of models based on the current search/filter conditions. * @return CActiveDataProvider the data provider that can return the models based on the search/filter conditions. */ public function search() &#123; // Warning: Please modify the following code to remove attributes that // should not be searched. $criteria = new CDbCriteria(); $criteria-&gt;compare(&#x27;id&#x27;, $this-&gt;id); $criteria-&gt;compare(&#x27;title&#x27;, $this-&gt;title, true); $criteria-&gt;compare(&#x27;description&#x27;, $this-&gt;description, true); $criteria-&gt;compare(&#x27;create_date&#x27;, $this-&gt;create_date, true); $criteria-&gt;compare(&#x27;update_date&#x27;, $this-&gt;update_date, true); $criteria-&gt;scopes = &#x27;createDateDesc&#x27;; return new CActiveDataProvider($this, [ &#x27;criteria&#x27; =&gt; $criteria, ]); &#125; /** * 行为操作 */ public function behaviors() &#123; return [ &#x27;CTimestampBehavior&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;zii.behaviors.CTimestampBehavior&#x27;, &#x27;createAttribute&#x27; =&gt; &#x27;create_date&#x27;, &#x27;updateAttribute&#x27; =&gt; &#x27;update_date&#x27;, &#x27;setUpdateOnCreate&#x27; =&gt; &#x27;true&#x27;, ], ]; &#125; //查询范围 public function scopes() &#123; return [ &#x27;published&#x27; =&gt; [ &#x27;condition&#x27; =&gt; &#x27;status=1&#x27;, ], &#x27;recently&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, &#x27;limit&#x27; =&gt; 5, ], &#x27;createDateDesc&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, ], ]; &#125;&#125; controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263&lt;?phpclass BlogController extends Controller&#123; /** * @var string the default layout for the views. Defaults to &#x27;//layouts/column2&#x27;, meaning * using two-column layout. See &#x27;protected/views/layouts/column2.php&#x27;. */ public $layout = &#x27;//layouts/column2&#x27;; /** * @return array action filters */ public function filters() &#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations &#x27;postOnly + delete&#x27;, // we only allow deletion via POST request ]; &#125; /** * Specifies the access control rules. * This method is used by the &#x27;accessControl&#x27; filter. * @return array access control rules */ public function accessRules() &#123; return [ [&#x27;allow&#x27;, // allow all users to perform &#x27;index&#x27; and &#x27;view&#x27; actions &#x27;actions&#x27; =&gt; [&#x27;view&#x27;], &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], [&#x27;allow&#x27;, // allow authenticated user to perform &#x27;create&#x27; and &#x27;update&#x27; actions &#x27;actions&#x27; =&gt; [&#x27;create&#x27;, &#x27;update&#x27;, &#x27;index&#x27;], &#x27;users&#x27; =&gt; [&#x27;@&#x27;], ], [&#x27;allow&#x27;, // allow admin user to perform &#x27;admin&#x27; and &#x27;delete&#x27; actions &#x27;actions&#x27; =&gt; [&#x27;admin&#x27;, &#x27;delete&#x27;], &#x27;user&#x27; =&gt; [&#x27;admin&#x27;], ], [&#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ]; &#125; /** * Displays a particular model. * @param integer $id the ID of the model to be displayed */ public function actionView($id) &#123; //最近的博文 $rawData = Blog::model()-&gt;recently()-&gt;findAll(); $rawData = new CArrayDataProvider($rawData, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;title&#x27;, ], ], &#x27;pagination&#x27; =&gt; [ &#x27;pageSize&#x27; =&gt; 10, ], ]); $recentBlogMenu = []; foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $recentBlogMenu[] = [ &#x27;label&#x27; =&gt; $value-&gt;title, &#x27;url&#x27; =&gt; [&#x27;blog/view&#x27;, &#x27;id&#x27; =&gt; $value-&gt;id], ]; &#125; //博文的分类 $rawData = Type::model()-&gt;findAll(); $rawData = new CArrayDataProvider($rawData, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;name&#x27;, ], ], ]); $blogType = []; foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $blogType[] = [ &#x27;label&#x27; =&gt; $value-&gt;name, &#x27;url&#x27; =&gt; [&#x27;type/search/&#x27; . $value-&gt;id], ]; &#125; $this-&gt;render(&#x27;view&#x27;, [ &#x27;model&#x27; =&gt; $this-&gt;loadModel($id), &#x27;blogType&#x27; =&gt; $blogType, &#x27;recentBlogMenu&#x27; =&gt; $recentBlogMenu, ]); &#125; /** * Creates a new model. * If creation is successful, the browser will be redirected to the &#x27;view&#x27; page. */ public function actionCreate() &#123; $model = new Blog; // Uncomment the following line if AJAX validation is needed // $this-&gt;performAjaxValidation($model); if (isset($_POST[&#x27;Blog&#x27;])) &#123; $model-&gt;attributes = $_POST[&#x27;Blog&#x27;]; if ($model-&gt;save()) &#123; $this-&gt;redirect([&#x27;view&#x27;, &#x27;id&#x27; =&gt; $model-&gt;id]); &#125; &#125; $rawData = new CActiveDataProvider( &#x27;Type&#x27;, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;name&#x27;, ], ], ] ); foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $type[$value-&gt;id] = $value-&gt;name; &#125; $this-&gt;render(&#x27;create&#x27;, [ &#x27;model&#x27; =&gt; $model, &#x27;type&#x27; =&gt; $type, ]); &#125; /** * Updates a particular model. * If update is successful, the browser will be redirected to the &#x27;view&#x27; page. * @param integer $id the ID of the model to be updated */ public function actionUpdate($id) &#123; $model = $this-&gt;loadModel($id); // Uncomment the following line if AJAX validation is needed // $this-&gt;performAjaxValidation($model); if (isset($_POST[&#x27;Blog&#x27;])) &#123; $model-&gt;attributes = $_POST[&#x27;Blog&#x27;]; if ($model-&gt;save()) &#123; $this-&gt;redirect([&#x27;view&#x27;, &#x27;id&#x27; =&gt; $model-&gt;id]); &#125; &#125; $rawData = new CActiveDataProvider( &#x27;Type&#x27;, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;name&#x27;, ], ], ] ); foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $type[$value-&gt;id] = $value-&gt;name; &#125; $this-&gt;render(&#x27;update&#x27;, [ &#x27;model&#x27; =&gt; $model, &#x27;type&#x27; =&gt; $type, ]); &#125; /** * Deletes a particular model. * If deletion is successful, the browser will be redirected to the &#x27;admin&#x27; page. * @param integer $id the ID of the model to be deleted */ public function actionDelete($id) &#123; $this-&gt;loadModel($id)-&gt;delete(); // if AJAX request (triggered by deletion via admin grid view), we should not redirect the browser if (!isset($_GET[&#x27;ajax&#x27;])) &#123; $this-&gt;redirect(isset($_POST[&#x27;returnUrl&#x27;]) ? $_POST[&#x27;returnUrl&#x27;] : [&#x27;admin&#x27;]); &#125; &#125; /** * Lists all models. */ public function actionIndex() &#123; $dataProvider = new CActiveDataProvider( &#x27;Blog&#x27;, [ &#x27;pagination&#x27; =&gt; [&#x27;pageSize&#x27; =&gt; 10], &#x27;criteria&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, ], ] ); $this-&gt;render(&#x27;index&#x27;, [ &#x27;dataProvider&#x27; =&gt; $dataProvider, ]); &#125; /** * Manages all models. */ public function actionAdmin() &#123; $model = new Blog(&#x27;search&#x27;); $model-&gt;unsetAttributes(); // clear any default values if (isset($_GET[&#x27;Blog&#x27;])) &#123; $model-&gt;attributes = $_GET[&#x27;Blog&#x27;]; &#125; $this-&gt;render(&#x27;admin&#x27;, [ &#x27;model&#x27; =&gt; $model, ]); &#125; /** * Returns the data model based on the primary key given in the GET variable. * If the data model is not found, an HTTP exception will be raised. * @param integer the ID of the model to be loaded */ public function loadModel($id) &#123; $model = Blog::model()-&gt;findByPk($id); if (null === $model) &#123; throw new CHttpException(404, &#x27;请求的页面不存在.&#x27;); &#125; return $model; &#125; /** * Performs the AJAX validation. * @param CModel the model to be validated */ protected function performAjaxValidation($model) &#123; if (isset($_POST[&#x27;ajax&#x27;]) &amp;&amp; &#x27;blog-form&#x27; === $_POST[&#x27;ajax&#x27;]) &#123; echo CActiveForm::validate($model); Yii::app()-&gt;end(); &#125; &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"},{"name":"Yii","slug":"Yii","permalink":"https://blog.gowhich.com/tags/Yii/"}]},{"title":"Objective-C分类(Category)借用Smalltalk实现中的“分类”概念","date":"2025-06-05T02:26:00.000Z","path":"2025/06/05/Objective-C分类-Category-借用Smalltalk实现中的“分类”概念.html","text":"在Objective-C的设计中，一个主要的考虑即为大型代码框架的维护。结构化编程的经验显示，改进代码的一种主要方法即为将其分解为更小的片段。Objective-C借用并扩展了Smalltalk实现中的“分类”概念，用以帮助达到分解代码的目的。[1] 一个分类可以将方法的实现分解进一系列分离的文件。程序员可以将一组相关的方法放进一个分类，使程序更具可读性。举例来讲，可以在字符串类中增加一个名为“拼写检查”的分类，并将拼写检查的相关代码放进这个分类中。 进一步的，分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法，而无需持有原有的代码，或是重新编译原有的类。例如若系统提供的字符串类的实现中不包含拼写检查的功能，可以增加这样的功能而无需更改原有的字符串类的代码。 在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。 若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。 其它语言也尝试了通过不同方法增加这一语言特性。TOM在这方面走的更远，不仅允许增加方法，更允许增加成员变量。也有其它语言使用面向声明的解决方案，其中最值得注意的是Self语言。 C#与Visual Basic.NET语言以扩展函数的与不完全类的方式实现了类似的功能。Ruby与一些动态语言则以”monkey patch”的名字称呼这种技术。 使用分类的例子 这个例子创建了Integer类，其本身只定义了integer属性，然后增加了两个分类Arithmetic与Display以扩展类的功能。虽然分类可以访问类的私有成员，但通常利用属性的访问方法来访问是一种更好的做法，可以使得分类与原有类更加独立。这是分类的一种典型应用—另外的应用是利用分类来替换原有类中的方法，虽然用分类而不是继承来替换方法不被认为是一种好的做法。 Integer.h123456789101112#import &lt;objc/Object.h&gt; @interface Integer : Object&#123;@private int integer;&#125; @property (assign, nonatomic) integer; @end Integer.m12345678#import &quot;Integer.h&quot; @implementation Integer @synthesize integer; @end Arithmetic.h1234567#import &quot;Integer.h&quot; @interface Integer (Arithmetic)- (id) add: (Integer *) addend;- (id) sub: (Integer *) subtrahend;@end Arithmetic.m12345678910111213#import &quot;Arithmetic.h&quot;@implementation Integer (Arithmetic)- (id) add: (Integer *) addend&#123; self.integer = self.integer + addend.integer; return self;&#125; - (id) sub: (Integer *) subtrahend&#123; self.integer = self.integer - subtrahend.integer; return self;&#125;@end Display.h12345678 #import &quot;Integer.h&quot;@interface Integer (Display)- (id) showstars;- (id) showint;@end Display.m123456789101112131415161718#import &quot;Display.h&quot;@implementation Integer (Display)- (id) showstars&#123; int i, x = self.integer; for(i=0; i &lt; x; i++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); return self;&#125; - (id) showint&#123; printf(&quot;%d\\n&quot;, self.integer); return self;&#125;@end main.m12345678910111213141516171819202122232425262728 #import &quot;Integer.h&quot;#import &quot;Arithmetic.h&quot;#import &quot;Display.h&quot;int main(void)&#123; Integer *num1 = [Integer new], *num2 = [Integer new]; int x; printf(&quot;Enter an integer: &quot;); scanf(&quot;%d&quot;, &amp;x); num1.integer = x; [num1 showstars]; printf(&quot;Enter an integer: &quot;); scanf(&quot;%d&quot;, &amp;x); num2.integer = x; [num2 showstars]; [num1 add:num2]; [num1 showint]; return 0;&#125; 注释 可以利用以下命令来编译： 1gcc -x objective-c main.m Integer.m Arithmetic.m Display.m -lobjc 在编译时间，可以利用省略#import &quot;Arithmetic.h&quot;与[num1 add:num2]命令，以及Arithmetic.m文件来实验。程序仍然可以运行，这表明了允许动态的、按需的加载分类；若不需要某一分类提供的功能，可以简单的不编译之。 源自：维基百科","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C与Smalltalk类似的动态类型","date":"2025-06-04T09:14:58.000Z","path":"2025/06/04/Objective-C与Smalltalk类似的动态类型.html","text":"动态类型类似于Smalltalk，Objective-C具备动态类型： 即消息可以发送给任何对象实体，无论该对象实体的公开接口中有没有对应的方法。在C++这种静态类型的语言里，不可能对一个(void*)指针调用任何方 法，编译器会挡下该调用行为。但在Objective-C中，你可以对id发送任何信息(id很像void*，但是被严格限制只能使用在对象上)，编译器 仅会发出“该对象可能无法回应信息”的警告，程序同样可以通过编译，而实际发生的事则取决于运行期该对象的真正形态，若该对象的确可以回应消息，则依旧运 行对应的方法。 这种特性可以增加语言的灵活性，因为它允许对象“捕捉”消息，再将消息转送到另一个可以正确处理该消息的对象，形同消息“转发”给另一个对象。 一个对象收到信息之后，他有三种处理信息的可能手段，第一是回应该消息并运行方法，若无法回应，则可以转发消息给其他对象，若以上两者均无，就要处 理无法回应而抛出的例外。只要进行三者之其一，该消息就算完成任务而被丢弃。若对“nil”（空对象指针）发送消息，该消息通常会被忽略，取决于编译器选 项可能会抛出例外。 虽然Objective-C具备动态类型的能力，但编译期的静态类型检查依旧可以应用到变量上。以下三种声明在运行时效力是完全相同的，但是三种声明提供了一个比一个更明显的类型信息，附加的类型信息让编译器在编译时可以检查变量类型，并对类型不符的变量提出警告。 下面三个方法，差异仅在于参数的形态： 1- setMyValue:(id) foo; id形态表示参数“foo”可以是任何类的实例。 1- setMyValue:(id &lt;aProtocol&gt;) foo; id &lt;aProtocol&gt;表示“foo”可以是任何类的实例，但必须采纳“aProtocol”协议。 1- setMyValue:(NSNumber*) foo; 该声明表示“foo”必须是“NSNumber”的实例。 动态类型是一种强大的特性。在缺少泛型的静态类型语言（如Java 5以前的版本）中实现容器类时，程序员需要写一种针对通用类型对象的容器类，然后在通用类型和实际类型中不停的强制类型转换。无论如何，类型转换会破坏静态类型，例如写入一个“整数”而将其读取为“字符串”会产生运行时错误。这样的问题被泛型解决，但容器类需要其内容对象的类型一致，而对于动态类型语言则完全没有这方面的问题。 [资料：维基百科]","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C对象发送消息[转发]","date":"2025-06-04T08:54:17.000Z","path":"2025/06/04/Objective-C对象发送消息-转发.html","text":"Objective-C允许对一个对象发送消息，不管它是否能够响应之。除了响应或丢弃消息以外，对象也可以将消息转发到可以响应该消息的对象。转发可以用于简化特定的设计模式，例如观测器模式或代理模式。 Objective-C运行时在Object中定义了一对方法： A.转发方法: 12- (retval_t) forward:(SEL) sel :(arglist_t) args; // with GCC- (id) forward:(SEL) sel :(marg_list) args; // with NeXT/Apple systems B.响应方法: 12- (retval_t) performv:(SEL) sel :(arglist_t) args; // with GCC- (id) performv:(SEL) sel :(marg_list) args; // with NeXT/Apple systems 希望实现转发的对象只需用新的方法覆盖以上方法来定义其转发行为。无需重写响应方法performv::，由于该方法只是单纯的对响应对象发送消息并传递参数。其中，SEL类型是Objective-C中消息的类型。 例子 这里包括了一个演示转发的基本概念的程序示例。(代码来源：维基百科Objective-C) Forwarder.h123456789#import &lt;objc/Object.h&gt; @interface Forwarder : Object&#123; id recipient; //该对象是我们希望转发到的对象。&#125; @property (assign, nonatomic) id recipient; @end Forwarder.m1234567891011121314151617#import &quot;Forwarder.h&quot; @implementation Forwarder @synthesize recipient; - (retval_t) forward: (SEL) sel : (arglist_t) args&#123; /* *检查转发对象是否响应该消息。 *若转发对象不响应该消息，则不会转发，而产生一个错误。 */ if([recipient respondsTo:sel]) return [recipient performv: sel : args]; else return [self error:&quot;Recipient does not respond&quot;];&#125; Recipient.h1234567#import &lt;objc/Object.h&gt; // A simple Recipient object.@interface Recipient : Object- (id) hello;@end Recipient.m123456789101112#import &quot;Recipient.h&quot; @implementation Recipient - (id) hello&#123; printf(&quot;Recipient says hello!\\n&quot;); return self;&#125; @end main.m1234567891011121314151617#import &quot;Forwarder.h&quot;#import &quot;Recipient.h&quot; int main(void)&#123; Forwarder *forwarder = [Forwarder new]; Recipient *recipient = [Recipient new]; forwarder.recipient = recipient; //Set the recipient. /* *转发者不响应hello消息！该消息将被转发到转发对象。 * (若转发对象响应该消息) */ [forwarder hello]; return 0;&#125; 脚注 利用GCC编译时，编译器报告： 1234$ gcc -x objective-c -Wno-import Forwarder.m Recipient.m main.m -lobjcmain.m: In function `main&#x27;:main.m:12: warning: `Forwarder&#x27; does not respond to `hello&#x27; 如前文所提到的，编译器报告Forwarder类不响应hello消息。在这种情况下，由于实现了转发，可以忽略这个警告。 运行该程序产生如下输出： 12$ ./a.outRecipient says hello!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Golang新版本安装吐槽","date":"2025-06-03T09:14:58.000Z","path":"2025/06/03/Golang新版本安装吐槽.html","text":"我是打算使用一下最新版本的Golang，然后使用下Hugo，结果安装的时候提示要安装上一个版本，我感觉没啥问题，我就安装了要求安装的版本，结果还是有问题继续安装要求安装的版本结果就是一个套着一个，我服了 这个机制头一次见到 123456789101112131415161718192021222324252627282930313233343536373839404142$ gvm install go1.24.3Updating Go source...Installing go1.24.3... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.24.3-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:01] C:130$ tail -f -n 100 ~/.gvm/logs/go-go1.24.3-compile.log Building Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_22_6_or_later (notgo122.go) in /home/durban/.gvm/gos/go1.24.3/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:25] C:130$ gvm install go1.22.6 Installing go1.22.6... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.22.6-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:35] C:1$ tail -f -n 100 ~/.gvm/logs/go-go1.22.6-compile.logBuilding Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_20_6_or_later (notgo120.go) in /home/durban/.gvm/gos/go1.22.6/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:49] C:130$ gvm install go1.20.6 Installing go1.20.6... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.20.6-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:53] C:1$ tail -f -n 100 ~/.gvm/logs/go-go1.20.6-compile.logBuilding Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_17_13_or_later (notgo117.go) in /home/durban/.gvm/gos/go1.20.6/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:14:02] C:130$ gvm install go1.17.13 Installing go1.17.13... * Compiling...go1.17.13 successfully installed! 笑死人 这个安装逻辑就是按照这个顺序依次安装 1234gvm install go1.17.13gvm install go1.20.6gvm install go1.22.6gvm install go1.24.3 为了体验下新版本我这是招谁了","tags":[{"name":"Golang","slug":"Golang","permalink":"https://blog.gowhich.com/tags/Golang/"}]},{"title":"Objective-C 创建对象","date":"2025-06-03T09:03:50.000Z","path":"2025/06/03/Objective-C-创建对象.html","text":"Objective-C中创建对象的方法：Objective-C 创建对象需通过 alloc 以及 init。alloc的作用是分配内存，init 则是初始化对象。 init 与 alloc 都是定义在 NSObject 里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。以下为范例： 1MyObject * my = [[MyObject alloc] init]; 在 Objective-C 2.0 里，若创建对象不需要参数，则可直接使用 new 1MyObject * my = [MyObject new]; 这仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写 init 方法，来添加额外的工作。(用途类似 C++ 的构造函数 constructor) 123456- (id) init &#123; if ( self=[super init] ) &#123; // 必须调用父类的 init // do something here ... &#125; return self;&#125;","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C 协议(Protocol)","date":"2025-06-03T08:54:11.000Z","path":"2025/06/03/Objective-C-协议-Protocol.html","text":"协议是一组尚未实现的方法列表，任何的类均可采纳该协议并给出方法的具体实现。 Objective-C在NeXT时期曾经试图引入多重继承的概念，但由于协议的出现而没有实现。协议的功能类似于C++中的多重抽象基类继承或是Java与C#语言中的“接口”。在Objective-C中，包括两种定义协议的方式：由编译器保证的“正式协议”，以及为特定目的设定的“非正式协议”。 非正式协议为一个可以选择性实现的一系列方法列表。非正式协议虽名为协议，但实际上是挂于NSObject上的未实现分类 (Unimplemented Category)的一种称谓，Objetive-C语言机制上并没有非正式协议这种东西，OSX 10.6版本之后由于正式协议也可以通过@optional关键字达成相同功用，所以非正式协议已经被废弃不再使用。 正式协议则类似于Java中的”接口”，它是一系列方法的列表，任何类都可以声明自身实现了某个协议。在Objective-C 2.0之前，一个类必须实现它声明符合的协议中的所有方法，否则编译器会报告一个错误，表明这个类没有实现它声明符合的协议中的全部方法。 Objective-C 2.0版本允许标记协议中某些方法为可选的(Optional)，这样编译器就不会强制实现这些可选的方法。 协议经常应用于Cocoa 中的委托及事件触发。例如文本框类通常会包括一个委托 (delegate)对象，该对象可以实现一个协议，该协议中可能包含一个实现文字输入的自动完成方法。若这个委托对象实现了这个方法，那么文本框类就会在适当的时候触发自动完成事件，并调用这个方法用于自动完成功能。 Objective-C中协议的概念与Java中接口的概念并不完全相同，即一个类可以在不声明它符合某个协议的情况下，实现这个协议所包含的方 法，也即实质上符合这个协议，而这种差别对外部代码而言是不可见的。正式协议的声明不提供实现，它只是简单地表明符合该协议的类实现了该协议的方法，保证 调用端可以安全调用方法。 语法 协议以关键字@protocol作为区段起始，@end退出，中间为方法列表。 1234@protocol Locking- (void)lock;- (void)unlock;@end 这是一个协议的例子，多线程编程中经常要确保一份共享资源同时只有一个线程可以使用，会在使用前给该资源挂上锁 ，以上即为一个表明有“锁”的概念的协议，协议中有两个方法，只有名称但尚未实现。 下面的SomeClass宣称他采纳了Locking协议： 123456789101112@interface SomeClass : SomeSuperClass &lt;Locking&gt;@end一旦SomeClass表明他采纳了Locking协议，SomeClass就有义务实现Locking协议中的两个方法。@implementation SomeClass- (void)lock &#123; // 实现lock方法...&#125;- (void)unlock &#123; // 实现unlock方法...&#125;@end 由于SomeClass已经确实遵从了Locking协议，故调用端可以安全的发送lock或unlock信息给SomeClass实体变量，不需担心他没有办法回应信息。 插件是另一个使用抽象定义的例子，可以在不关心插件的实现的情况下定义其希望的行为。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C 类型的声明与实现","date":"2025-06-03T08:45:02.000Z","path":"2025/06/03/Objective-C-类型的声明与实现.html","text":"Objective-C 类型要求区分接口（interface）与实现（implementation）为两个程序区块，这是强制性的。 类型的接口通常放置于头文件内，依C语言的惯例以.h作为扩展名；类型的实现则放于以.m为扩展名。 Interface接口区段里头清楚定义了类型的名称，实体变量（instance variable），以及方法。 以关键字@interface作为区段起头，@end退出区段。 12345678910@interface MyObject : NSObject &#123; int memberVar1; // 实体变量 id memberVar2;&#125;+(return_type) class_method; // 类别分类 -(return_type) instance_method1; // 实体方法-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 方法前面的+&#x2F;-号代表方法的类型：加号（+）代表类型方法（class method），不需要实体就可以调用，近于C++的静态成员函数（static member function）。减号（-）即是一般的实体方法（instance method）。 这里提供了一份意义相近的C++语法对照，如下： 123456789101112class MyObject : public NSObject &#123; protected: int memberVar1; // 实体变量 void * memberVar2; public: static return_type class_method(); // 类别方法 return_type instance_method1(); // 实体方法 return_type instance_method2( int p1 ); return_type instance_method3( int p1, int p2 );&#125; Objective-C定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C方法的参数也不必全部都附缀于方法名称的尾端，也可以夹杂于名称中间，提高程序可读性。以一个设置颜色RGB值的方法为例: 123- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法 */[myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法 */ 这个方法的全名是setColorToRed:Green:Blue:。每个冒号后面都带着一个形态为float的参数，分别代表红，绿，蓝三色。 Implementation实现区段则撰写方法实际运行的程序。以关键字@implementation作为区段起头，@end结尾。 1234567891011121314151617@implementation MyObject &#123; int memberVar3; //私有实体变量&#125; +(return_type) class_method &#123; .... //method implementation&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 值得一提的是不只interface区段开头可以声明实体变量，implementation区段开头也可以声明实体变量，两者的差别在于成员访问权限， 声明于interface区段内的实体变量默认权限为protected，声明于implementation区段的实体变量则默认为private，基 于面向对象的封装原则，仅供类型内部使用的变量请尽可能声明于implementation区段(.m档)内，不需要曝露于interface(.h档) 中。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"iOS开发是否应该使用ARC","date":"2025-06-03T08:43:01.000Z","path":"2025/06/03/iOS开发是否应该使用ARC.html","text":"关于ARC的介绍文章网上已经很多，苹果的官方文档也不少。担心使用ARC会带来问题的同学主要的理由有以下5点: 1.担心这个技术方案不靠谱。苹果大多数时候的技术方案都是比较靠谱的，但也有一些技术方案有很多坑，例如storyboard。 2.原有的项目在非ARC环境下运行良好，担心迁移成本或引入新的问题。 3.苹果以前手工管理内存需要非常小心，稍微不注意应用程序就崩溃了。有过这段经历的iOS开发老手，心里上还是觉得自己手工管理内存更踏实一些。 4.使用ARC需要了解ARC的一些细节，还需要引入_bridge等新的关键字，学习成本还是有的。 5.以为ARC只能支持iOS5.0以上（这是非常大的误解）。 对于上面提到5点问题，我认为相应的回答如下: 1.ARC是WWDC2011大会时提出的技术，离现在已经快2年了，而且苹果现在将MacOS上的垃圾回收机制废弃(Deprecated)，采用ARC替代，无疑证明了ARC是成熟的了。 2.确实有一些迁移成本，但苹果在Xcode中专门集成了迁移工具，成本已经非常小了。如下图就是Xcode集成的将非ARC工程转换成ARC工程的工具。另外，为了兼容第三方的非ARC开源库，你也可以在工程中随意使用编译参数：-fno-objc-arc ,这个参数允许对部分文件关闭ARC。 3.手工管理内存虽然踏实，但是泄露很容易发生。常常开发完成后，需要使用Instruments来检测泄露。但用了ARC后，基本不会出现泄露了，我在 开发粉笔网iPhone客户端时，由于使用了ARC，花三个月开发完的应用，用instruments检测后，没有发现任何内存泄漏问题。这在没有使用 ARC的工程中是不可想象的。 4.确实有学习成本。但是非常值得学习，能省不少开发精力。 5.虽然ARC是与iOS5一同推出，但是由于ARC的实现机制是在编译期完成，所以使用ARC之后App仍然可以支持iOS4.3。稍微需要注意的是， 如果要在ARC开启的情况下支持iOS4.3，需要将weak关键字换成 __unsafe_unretained，另外还有一些细节需要处理 所以，希望大家都能在项目中使用ARC，一旦你感受到它带来的好处，你就离不开它了。它也能让你从繁琐的内存管理代码中解放出来，将精力更多关注于代码结构、设计模式而不是底层的内存管理。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"Yii Widget的使用","date":"2025-06-03T07:18:28.000Z","path":"2025/06/03/Yii-Widget的使用.html","text":"小插件解决大问题，做网站，最喜欢使用这种东西，不需要重写代码，直接调用，传递参数，就得到想要的模块，yii也有次功能，看代码： 12345678910111213141516$this-&gt;beginWidget(&#x27;CBootStrapPortlet&#x27;, [ &#x27;title&#x27; =&gt; &#x27;博文分类&#x27;, //导航标题 &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;nav nav-pills nav-stacked&#x27;], //样式定义 &#x27;tagName&#x27; =&gt; &#x27;ul&#x27;, // &#x27;decorationCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;titleCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;contentCssClass&#x27; =&gt; &#x27;&#x27;,]);$this-&gt;widget(&#x27;CBootStrapMenu&#x27;, [ &#x27;items&#x27; =&gt; $this-&gt;blogType, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;],]);$this-&gt;endWidget(); 上面的代码是我的列表的小插件，样式我已经定义好了，只要给变量，传递参数就好了s","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Objective-C 信息传递","date":"2025-06-03T07:14:54.000Z","path":"2025/06/03/Objective-C-信息传递.html","text":"Objective-C最大的特色是承自Smalltalk的信息传递模型（message passing），与今日主流的C++差异甚大。Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递信息更为精确。此二种风格的差异主要在于程序如何看待调用方法&#x2F;传送信息这个动作。C++里类型与方法的关系非常严格清楚，一个方法必定属于一个类型，而且在编译时（compile time）就已经紧密绑定，你不可能去调用一个不存在类型里的方法。但在Objective-C，类型与信息的关系比较松散，调用方法视为对对象发送信息，所有方法都被视为对信息的回应。所有信息处理直到运行时（runtime）才会动态决定，并交由类型自行决定如何处理收到的信息。也就是说，一个类型不保证一定会回应收到的信息，如果类型收到了一个无法处理的信息，程序只会抛出一个Exception，不会出错或当掉。 C++里，送一个信息给对象（或者说调用一个方法）的语法如下: 1obj-&gt;method(argument); Objective-C则写成: 1[obj method: argument]; 此二者并不仅仅是语法上的差异，还有基本行为上的不同。 这里以一个汽车类（car class）的简单例子来解释Objective-C的信息传递特性： 1[car fly]; 典型的C++意义解读是“调用car类型的fly方法”。若car类型里头没有定义fly方法，那编译肯定不会通过。但是Objective-C里，我们应当解读为“发提交一个fly的信息给car对象”，fly是信息，而car是信息的接收者。car收到信息后会决定如何回应这个信息，若car类型内定义有fly方法就运行此段程序，若car内不存在fly方法，这里不会产生编译错误，它仅仅是抛出Exception。 此二种风格各有优劣。C++的编译期绑定使得函数调用非常快速，强制要求所有的方法都必须有对应的动作。缺点是不支持动态绑定（除非手动加上 virtual关键字）。Objective-C天生即是动态绑定，运行期才处理信息，允许传送未知信息给对象。可以送信息给整个对象集合而不需要一一检 查每个对象的型态，天生具备消息转送机制。同时空对象nil也可以接受信息，但是默认不做事，所以送信息给nil也不用担心程序崩溃。 Objective-C的方法调用因为运行期才动态解析信息，一开始信息比C++ virtual成员函数调用速度慢上三倍。但经由IMP高速缓存改善，目前已经比C++的virtual function快上50％。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C Hello World实例","date":"2025-06-03T07:12:55.000Z","path":"2025/06/03/Objective-C-Hello-World实例.html","text":"这里示范一个基础的Hello World程序。 12345678910#import&lt;Foundation/Foundation.h&gt; int main(int argc, char *argv[])&#123; NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; NSLog(@&quot;Hello World!&quot;); [pool drain]; return 0;&#125; 以上是Xcode的旧版”Hello World”程序代码，在4.3.1 xcode的代码为: 12345678#import &lt;Foundation/Foundation.h&gt; int main(int argc, char *argv[])&#123; @autoreleasepool&#123; NSLog(@&quot;Hello World!&quot;); &#125; return 0;&#125;","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Yii CRUD操作","date":"2025-06-03T07:11:26.000Z","path":"2025/06/03/Yii-CRUD操作.html","text":"对于喜欢操作sql语句的人来说和对于sql语句基础不是很好的，能够明白每个CRUD操作是什么意思很重要，简单的介绍个例子，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?phpclass Post extends CActiveRecord&#123; public $fixtures = [ &#x27;posts&#x27; =&gt; &#x27;Post&#x27;, &#x27;tags&#x27; =&gt; &#x27;Tag&#x27;, ]; public function findPost() &#123; //调用find时，我们使用$condition和$params指定查询条件。 //此处$condition可以是SQL语句中的WHERE字符串，$params则是一个参数数组， //其中的值应绑定到$condation中的占位符。 $post = $this-&gt;posts(&#x27;post1&#x27;); $fPost = Post::model()-&gt;find(&#x27;id=:id&#x27;, [&#x27;:id&#x27; =&gt; $post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=1 LIMIT 1 $fPost = Post::model()-&gt;find(&#x27;?&#x27;, [$post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE &#x27;1&#x27; LIMIT 1 //find返回符合条件的第一条记录，而findAll会返回符合条件的所有行。 $fAllPost = Post::model()-&gt;findAll(&#x27;id=:id&#x27;, [&#x27;:id&#x27; =&gt; $post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; $fAllPost = Post::model()-&gt;findAll(&#x27;?&#x27;, [$post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE &#x27;1&#x27; $criteria = new CDbCriteria(); $criteria-&gt;condition = &#x27;id=:id AND title=:title&#x27;; $criteria-&gt;params = [&#x27;:id&#x27; =&gt; $post-&gt;id, &#x27;:title&#x27; =&gt; $post-&gt;title]; $fPost = Post::model()-&gt;find($criteria); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; LIMIT 1 $fAllPost = Post::model()-&gt;findAll($criteria); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; $fPost = Post::model()-&gt;findByPk($post-&gt;id, &#x27;title=:title&#x27;, [&#x27;:title&#x27; =&gt; $post-&gt;title]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=1 AND (title = &#x27;post1&#x27;) LIMIT 1 $fPost = Post::model()-&gt;findByAttributes([&#x27;id&#x27; =&gt; $post-&gt;id, &#x27;title&#x27; =&gt; $post-&gt;title]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=&#x27;1&#x27; AND `t`.`title`=&#x27;post1&#x27; LIMIT 1 $sql = &#x27;SELECT id, title from &#123;&#123;post&#125;&#125; WHERE id = ? AND title = ?&#x27;; //必须设置表前缀 $fPost = Post::model()-&gt;findBySql($sql, [$post-&gt;id, $post-&gt;title]); $sql = &#x27;SELECT id, title from &#123;&#123;post&#125;&#125; WHERE id = :id AND title = :title&#x27;; $fPost = Post::model()-&gt;findBySql($sql, [&#x27;:id&#x27; =&gt; $post-&gt;id, &#x27;:title&#x27; =&gt; $post-&gt;title]); //如果没有找到符合条件的行，find返回null，findAll返回array()。 &#125; public function countPost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $cPost = Post::model()-&gt;count(&#x27;?&#x27;, [$post-&gt;title]); //SELECT COUNT(*) FROM `tbl_post` `t` WHERE &#x27;post1&#x27; 无意义 $cPost = Post::model()-&gt;countByAttributes([&#x27;title&#x27; =&gt; $post-&gt;title, &#x27;content&#x27; =&gt; $post-&gt;content]); //SELECT COUNT(*) FROM `tbl_post` `t` WHERE `t`.`title`=&#x27;post1&#x27; AND `t`.`content`=&#x27;content1&#x27; $sql = &quot;SELECT title from &#123;&#123;post&#125;&#125; WHERE title LIKE &#x27;%&quot; . $post-&gt;title . &quot;%&#x27;&quot;; $cPost = Post::model()-&gt;countBySql($sql); //至少有一条记录符合查询条件 $ePost = Post::model()-&gt;exists(&#x27;id=?ANDtitle=?&#x27;, [$post-&gt;id, $post-&gt;title]); //SELECT 1 FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; LIMIT 1 &#125; public function updatePost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $post-&gt;title = &#x27;updatepost1&#x27;; if ($post-&gt;isNewRecord) &#123; $post-&gt;create_time = $post-&gt;update_time = new CDbExpression(&#x27;NOW()&#x27;); //UPDATE `tbl_post` SET `id`=1, `title`=&#x27;update post 1&#x27;, `content`=&#x27;content1&#x27;, `tags`=NULL, `status`=1, `create_time`=NULL, `update_time`=1302161123, `author_id`=1 WHERE `tbl_post`.`id`=1 &#125; else &#123; $post-&gt;update_time = time(); &#125; $post-&gt;save(); //updateAll $sql = &quot;SELECT * FROM &#123;&#123;post&#125;&#125; WHERE title LIKE &#x27;%&quot; . &quot;post&quot; . &quot;%&#x27;&quot;; //SELECT * FROM tbl_post WHERE title LIKE &#x27;%post%&#x27; $post = Post::model()-&gt;findBySql($sql); $post-&gt;updateAll([&#x27;update_time&#x27; =&gt; time()], &#x27;id&lt;=?&#x27;, [&#x27;2&#x27;]); //UPDATE `tbl_post` SET `update_time`=1302161123 WHERE id &lt;= &#x27;2&#x27; $post-&gt;updateByPk($post-&gt;id + 2, [&#x27;title&#x27; =&gt; &#x27;updatepost3&#x27;]); $post-&gt;updateByPk($post-&gt;id, [&#x27;title&#x27; =&gt; &#x27;updatepost3&#x27;], &#x27;id=?&#x27;, [&#x27;3&#x27;]); //updateCounter更新某个字段的数值，一般是计数器(+/-)。 $tag = $this-&gt;tags(&#x27;tag1&#x27;); $uTag = Tag::model()-&gt;updateCounters([&#x27;frequency&#x27; =&gt; &#x27;3&#x27;], &#x27;id=?&#x27;, [&#x27;1&#x27;]); &#125; public function deletePost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $post-&gt;delete(); $this-&gt;assertEquals(1, $post-&gt;id); //删除数据库表中的记录，但是post的这个实例还在。 $post2 = Post::model()-&gt;findByPk($post-&gt;id); $this-&gt;assertEquals(null, $post2); //多条记录 $delete = Post::model()-&gt;deleteAll(&#x27;(id = ? AND title = ?) || (id = \\&#x27;4\\&#x27;) &#x27;, [1, &#x27;post1&#x27;]); $this-&gt;assertEquals(0, $delete); $delete = Post::model()-&gt;deleteAllByAttributes([&#x27;id&#x27; =&gt; &#x27;2&#x27;], &#x27;content=?&#x27;, [&#x27;content2&#x27;]); //DELETE FROM `tbl_post` WHERE `tbl_post`.`id`=&#x27;2&#x27; AND (content = &#x27;content2&#x27;) $this-&gt;assertEquals(1, $delete); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii在IIS下的伪静态处理","date":"2025-06-03T07:09:10.000Z","path":"2025/06/03/Yii在IIS下的伪静态处理.html","text":"Yii在IIS下的伪静态处理是，在根目录建立httpd.ini文件，然后使用IIS的伪静态规则，写入自己需要的规则： 我购买的虚拟主机在香港，因为windows的主机比较多，于是我也中招了，于是四处寻求方法，四处尝试，终于找到了适合Yii的伪静态规则： 代码如下： 12345678910111213[ISAPI_Rewrite]# 3600 = 1 hourCacheClockRate 3600RepeatLimit 32RewriteEngine On#伪静态规则RewriteBase /RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)/(.*)$ $1/index.php?$2RewriteRule !\\.(js|ico|gif|jpe?g|bmp|png|css)$ index.php [L]我在虚拟机上测试通过了，哈哈，希望对你也有用","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii-Gii的安装和配置","date":"2025-06-03T07:05:48.000Z","path":"2025/06/03/Yii-Gii的安装和配置.html","text":"Gii 是基于 web 的 Yii framework 代码生成器。 开始配置 可以在你的应用程序配置文件中增加以下代码以使用该模块： 1234567&#x27;modules&#x27; =&gt; [ &#x27;gii&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;system.gii.GiiModule&#x27;, &#x27;username&#x27; =&gt; &#x27;dev&#x27;, &#x27;password&#x27; =&gt; &#x27;yiidev&#x27;, ],], 运行 打开浏览器，输入 http://localhost/yourapp/index.php?r=gii，使用刚才在配置文件中填的 username 和 password 登录。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii分页设置","date":"2025-06-03T07:03:26.000Z","path":"2025/06/03/Yii分页设置.html","text":"yii自己是带有自动分页功能的。只要在对应的controller里面，类似下面这样鞋代码，就会实现的 1234567$dataProvider = new CActiveDataProvider( &#x27;Blog&#x27;, [ &#x27;pagination&#x27; =&gt; [&#x27;pageSize&#x27; =&gt; 10], &#x27;criteria&#x27; =&gt; [&#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;], ]); 但是样式还是yii中已经写好的，那么对于我，我要改掉这个样式，使用我提供的样式，可以像我下面这样写 1234567891011121314151617181920&lt;?php$this-&gt;widget(&#x27;zii.widgets.CListView&#x27;, [ &#x27;dataProvider&#x27; =&gt; $dataProvider, &#x27;itemView&#x27; =&gt; &#x27;_view&#x27;, &#x27;summaryCssClass&#x27; =&gt; &#x27;hide&#x27;, &#x27;pagerCssClass&#x27; =&gt; &#x27;pagination&#x27;, &#x27;pager&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLinkPager&#x27;, &#x27;nextPageLabel&#x27; =&gt; &#x27;&amp;raquo;&#x27;, &#x27;prevPageLabel&#x27; =&gt; &#x27;&amp;laquo;&#x27;, &#x27;firstPageLabel&#x27; =&gt; &#x27;最前&#x27;, &#x27;lastPageLabel&#x27; =&gt; &#x27;最后&#x27;, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;], &#x27;header&#x27; =&gt; &#x27;&#x27;, &#x27;hiddenPageCssClass&#x27; =&gt; &#x27;disabled&#x27;, &#x27;selectedPageCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;previousPageCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;nextPageCssClass&#x27; =&gt; &#x27;&#x27;, ],]); 其实只要添加自己对应的class属性就可以了，因为yii有自己默认的class属性，这个是比较简单。 下次我们可以看看，如何修改侧边下拉框，改为自己的喜欢的样式。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii CDbCriteria常用方法","date":"2025-06-03T07:01:08.000Z","path":"2025/06/03/Yii-CDbCriteria常用方法.html","text":"Yii的Active Recorder包装了很多。 特别是把SQL中 把where,order,limit,IN&#x2F;not IN,like等常用短句都包含进CDbCriteria这个类中去，这样整个代码会比较规范，一目了然。 1234567891011121314151617181920212223$criteria = newCDbCriteria;$criteria-&gt;addCondition(&quot;id=1&quot;); //查询条件，即where id =1$criteria-&gt;addInCondition(&#x27;id&#x27;, [1, 2, 3, 4, 5]); //代表where id IN (1,23,,4,5,);$criteria-&gt;addNotInCondition(&#x27;id&#x27;, [1, 2, 3, 4, 5]); //与上面正好相法，是NOT IN$criteria-&gt;addCondition(&#x27;id=1&#x27;, &#x27;OR&#x27;); //这是OR条件，多个条件的时候，该条件是OR而非AND$criteria-&gt;addSearchCondition(&#x27;name&#x27;, &#x27;分类&#x27;); //搜索条件，其实代表了。。where name like ‘%分类%’$criteria-&gt;addBetweenCondition(&#x27;id&#x27;, 1, 4); //between1 and 4$criteria-&gt;compare(&#x27;id&#x27;, 1); //这个方法比较特殊，他会根据你的参数自动处理成addCondition或者addInCondition，//即如果第二个参数是数组就会调用addInCondition$criteria-&gt;addCondition(&quot;id = :id&quot;);$criteria-&gt;params[&#x27;:id&#x27;] = 1;$criteria-&gt;select = &#x27;id,parentid,name&#x27;; //代表了要查询的字段，默认select=’*&#x27;;$criteria-&gt;join = &#x27;xxx&#x27;; //连接表$criteria-&gt;with = &#x27;xxx&#x27;; //调用relations$criteria-&gt;limit = 10; //取1条数据，如果小于0，则不作处理$criteria-&gt;offset = 1; //两条合并起来，则表示 limit 10 offset1,或者代表了。limit 1,10$criteria-&gt;order = &#x27;xxx DESC,XXX ASC&#x27;; //排序条件$criteria-&gt;group = &#x27;group 条件&#x27;;$criteria-&gt;having = &#x27;having 条件 &#x27;;$criteria-&gt;distinct = false; //是否唯一查询","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii开启错误日志","date":"2025-06-03T06:56:27.000Z","path":"2025/06/03/Yii开启错误日志.html","text":"生产环境中的 Web 应用常需要具有完善的事件日志功能。在我们的博客应用中，我们想记录它在使用时发生的错误。这些错误可能是程序错误或者是用户对系统的不当使用导致的错误。记录这些错误可以帮助我们完善此博客应用。 为启用错误日志功能，我们修改 应用配置 如下, 1234567891011121314151617181920212223242526return [ &#x27;preload&#x27; =&gt; [&#x27;log&#x27;], // ...... &#x27;components&#x27; =&gt; [ &#x27;log&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLogRouter&#x27;, &#x27;routes&#x27; =&gt; [ [ &#x27;class&#x27; =&gt; &#x27;CFileLogRoute&#x27;, &#x27;levels&#x27; =&gt; &#x27;error, warning&#x27;, ], [ &#x27;class&#x27; =&gt; &#x27;CProfileLogRoute&#x27;, //显示页面加载的整个流程，包括mysql语句 &#x27;levels&#x27; =&gt; &#x27;profile&#x27;, ], [ &#x27;class&#x27; =&gt; &#x27;CWebLogRoute&#x27;, &#x27;levels&#x27; =&gt; &#x27;profile,trace&#x27;, ], ], ], //...... ],]; 通过上述配置，如果有错误（error）或警告（warning）发生，其详细信息将被记录并保存到位于&#x2F;wwwroot&#x2F;blog&#x2F;protected&#x2F;runtime目录的文件中。 log组件还提供了更多的高级功能，例如将日志信息发送到一个 Email 列表，在 JavaScript 控制台窗口中显示日志信息等。更多详情，请参考指南。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"hexo默认处理heading的标题为id的异常解决方案","date":"2025-05-29T09:08:34.000Z","path":"2025/05/29/hexo默认处理heading的标题为id的异常解决方案.html","text":"hexo在处理markdown文档的时候，默认将heading的内容作为了id来处理锚点，如果是英文是没有问题的。 1## 我的标题 处理后的html内容 1&lt;h2 id=&quot;我的标题&quot;&gt;&lt;a href=&quot;#我的标题&quot; class=&quot;headerlink&quot; title=&quot;我的标题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#我的标题&quot;&gt;我的标题&lt;/a&gt;&lt;/h2&gt; 但是作为标题是中文的话就会有问题，以为在js的代码中，id是中文是不支持的，这会导致很多js库无法正常运行 找了很多资料，其中就有安装hexo-renderer-markdown-it 但是我自己亲自测试下来，还是很复杂，然后也没有解决我的问题，于是我思考这个hexo不会烂到这个程度吧 于是我看到了一种写法 1## [我的标题](#custom-id) 处理后的html内容 1&lt;h2 id=&quot;custom-id&quot;&gt;&lt;a href=&quot;#custom-id&quot; class=&quot;headerlink&quot; title=&quot;我的标题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#custom-id&quot;&gt;我的标题&lt;/a&gt;&lt;/h2&gt; 哎，可以，就这么轻松的解决了，不需要什么卸载安装什么的","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gowhich.com/tags/Hexo/"}]},{"title":"Yii简单的基于角色的访问控制","date":"2025-05-29T07:28:14.000Z","path":"2025/05/29/Yii简单的基于角色的访问控制.html","text":"123456789101112131415161718192021function filters()&#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations ];&#125;function accessRules()&#123; return [ [ &#x27;allow&#x27;, &#x27;action&#x27; =&gt; [&#x27;admin&#x27;], &#x27;roles&#x27; =&gt; [&#x27;staff&#x27;, &#x27;devel&#x27;], ], [ &#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ];&#125; 用户模型在用户表中新增一列，列名 roles。建立相应的模型。在这里它将被命名为 “User”。 当添加用户可以给他们分配角色 “管理员”，“用户”，“员工”等等。 验证在文件 protected&#x2F;components&#x2F;UserIdentity.php 添加如下内容： 123456789101112131415161718192021222324class UserIdentity extends CUserIdentity&#123; private $id; public function authenticate() &#123; $record = User::model()-&gt;findByAttributes([&#x27;email&#x27; =&gt; $this-&gt;username]); if (null === $record) &#123; $this-&gt;errorCode = self::ERROR_USERNAME_INVALID; &#125; else if (md5($this-&gt;password) !== $record-&gt;password) &#123; $this-&gt;errorCode = self::ERROR_PASSWORD_INVALID; &#125; else &#123; $this-&gt;id = $record-&gt;id; $this-&gt;setState(&#x27;roles&#x27;, $record-&gt;roles); $this-&gt;errorCode = self::ERROR_NONE; &#125; return !$this-&gt;errorCode; &#125; public function getId() &#123; return $this-&gt;id; &#125;&#125; 重要的一行是 1$this-&gt;setState(&#x27;roles&#x27;, $record-&gt;roles); 他给会话增加了用户角色。你可以使用如下代码获取用户角色。 1Yii:app()-&gt;user-&gt;getState(&quot;roles&quot;) 或 1Yii::app()-&gt;user-&gt;roles 检查权限:结构在 protected&#x2F;components 文件夹下修改并创建文件 WebUser.php ,然后重写 checkAccess() 方法。 123456789101112131415161718192021222324&lt;?phpclass WebUser extends CWebUser&#123; /** * Overrides a Yii method that is used for roles in controllers (accessRules). * * @param string $operation Name of the operation required (here, a role). * @param mixed $params (opt) Parameters for this operation, usually the object to access. * @return bool Permission granted? */ public function checkAccess($operation, $params = []) &#123; if (empty($this-&gt;id)) &#123; // Not identified =&gt; no rights return false; &#125; $role = $this-&gt;getState(&quot;roles&quot;); if (&#x27;admin&#x27; === $role) &#123; return true; // admin role has access to everything &#125; // allow access if the operation request is the current user&#x27;s role return ($operation === $role); &#125;&#125; 在 checkAccess() 方法中你可以定义自己的逻辑。确保类可以被yii使用配置文件 “protected&#x2F;config&#x2F;main.php” 必须包含以下内容: 123456&#x27;components&#x27; =&gt; [ // ... &#x27;user&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;WebUser&#x27;, ],] 旁注:[CWebUser::checkAccess()] 通常连接yii的验证系统。这里我们使用一个简单的处理角色的系统来替换[CAuthManager] 定义的分级系统。详细教程参加 Role-Based Access Control 检查权限: 使用在你的 PHP 代码中使用 Yii::app()-&gt;user-&gt;checkAccess(&#39;admin&#39;) 来检查当前用户是否有 ‘admin’ 角色。 当用户拥有 “staff” 或 “admin” 角色时，调用 Yii::app()-&gt;user-&gt;checkAccess(&quot;staff&quot;) 将会返回 true。 在控制器中你可以使用 accessRules() 中的 “roles” 属性进行过滤。 见下面的例子。 怎样过滤动作 控制器必须包含以下代码： 123456789101112131415161718192021function filters()&#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations ];&#125;function accessRules()&#123; return [ [ &#x27;allow&#x27;, &#x27;action&#x27; =&gt; [&#x27;admin&#x27;], &#x27;roles&#x27; =&gt; [&#x27;staff&#x27;, &#x27;devel&#x27;], ], [ &#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ];&#125; 这里对控制器中的 “admin” 动作进行了限制访问: 只有拥有 “staff” 或 “devel” 角色才可以访问。 像API文档中描述的那样 CAccessRule, “roles” 属性实际上调用的是 Yii::app()-&gt;user-&gt;checkAccess() 方法。 怎样根据角色显示不同菜单 你只需使用一个基于用户角色的菜单。例如 12345678910&lt;?php$user = Yii::app()-&gt;user; // just a convenience to shorten expressions$this-&gt;widget(&#x27;zii.widgets.CMenu&#x27;, [ &#x27;items&#x27; =&gt; [ [&#x27;label&#x27; =&gt; &#x27;Users&#x27;, &#x27;url&#x27; =&gt; [&#x27;/manageUser/admin&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;checkAcces(&#x27;staff&#x27;)], [&#x27;label&#x27; =&gt; &#x27;Your Ideas&#x27;, &#x27;url&#x27; =&gt; [&#x27;/userarea/ideaList&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;checkAcces(&#x27;normal&#x27;)], [&#x27;label&#x27; =&gt; &#x27;Login&#x27;, &#x27;url&#x27; =&gt; [&#x27;/site/login&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;isGuest], [&#x27;label&#x27; =&gt; &#x27;Logout (&#x27; . Yii::app()-&gt;user-&gt;name . &#x27;)&#x27;, &#x27;url&#x27; =&gt; [&#x27;/site/logout&#x27;], &#x27;visible&#x27; =&gt; !$user-&gt;isGuest], ],]); 更进一步: 访问上下文一个通常的需求，用户只能够修改自己的数据。在这种情况下，用户的角色是没有任何意义的：将要修改的数据。 这就是为什么 [CWebUser::checkAccess()] 有一个可选的参数 “$param” 。现在假设我们要检查的是一个用户是否有权更新Post记录的权限。我们可以这样写： 123if (Yii::app()-&gt;user-&gt;checkAccess(&#x27;normal&#x27;, $post)) &#123; // .....&#125; 当然 WebUser::checkAccess() 必须被扩展来使用 “$params” 参数。这将取决于你的应用程序的逻辑。比如, 这可能是非常简单的 $post-&gt;userId == $this-&gt;id。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii扩展类可以放在extensions目录下面","date":"2025-05-29T07:25:04.000Z","path":"2025/05/29/Yii扩展类可以放在extensions目录下面.html","text":"下面举个例子： 如果我想写个截取字符串长度的函数功能，可以在extensions目录下面新建一个文件，命名为Helper.php 代码如下： 123456789101112131415161718192021222324252627&lt;?phpclass Helper extends CController&#123; public static function truncate_utf8_string($string, $length, $etc = &#x27;...&#x27;) &#123; $result = &#x27;&#x27;; $string = html_entity_decode(trim(strip_tags($string)), ENT_QUOTES, &#x27;UTF-8&#x27;); $strlen = strlen($string); for ($i = 0; (($i &lt; $strlen) &amp;&amp; ($length &gt; 0)); $i++)&#123; if ($number = strpos(str_pad(decbin(ord(substr($string, $i, 1))), 8, &#x27;0&#x27;, STR_PAD_LEFT), &#x27;0&#x27;))&#123; if ($length &lt; 1.0)&#123; break; &#125; $result .= substr($string, $i, $number); $length -= 1.0; $i += $number - 1; &#125;else&#123; $result .= substr($string, $i, 1); $length -= 0.5; &#125; &#125; $result = htmlspecialchars($result, ENT_QUOTES, &#x27;UTF-8&#x27;); if ($i &lt; $strlen)&#123; $result .= $etc; &#125; return $result; &#125;&#125; 然后就可以在自己的代码中引用了Helper::truncate_utf8_string(&#39;XXXXXXXXXXX&#39;,10,&#39;.......&#39;); 如果出现问题可以在config/main.php中加入在import引入要加载扩展的目录 类似： 123456&#x27;import&#x27;=&gt; array( &#x27;application.models.*&#x27;, &#x27;application.components.*&#x27;, &#x27;application.extensions.*&#x27;, // 新加 &#x27;application.extensions.yii-mail.*&#x27;,),","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii中urlManager的配置","date":"2025-05-29T06:30:29.000Z","path":"2025/05/29/Yii中urlManager的配置.html","text":"第一步： 在main.php配置文件的component域中添加urlManager模块，并加入urlrules. 引入rule文件，代码如下 123456789$urls = include(dirname(__FILE__) . &#x27;/urlrules.php&#x27;);urlManager配置修改如下&#x27;urlManager&#x27;=&gt;array( &#x27;urlFormat&#x27; =&gt; &#x27;path&#x27;, &#x27;showScriptName&#x27; =&gt; false,//隐藏index.php &#x27;urlSuffix&#x27; =&gt; &#x27;.html&#x27;,//后缀 &#x27;rules&#x27; =&gt; $urls,), 第二步:在同级目录下写urlrules.php.如： 12345return array( &#x27;/index.html&#x27; =&gt; &#x27;site/index&#x27;, //首页 &#x27;search&#x27; =&gt; &#x27;search/index&#x27;，); 第三步，当然是配置服务器的rewrite模块，使得入口为index.php 1)apache下，在网站根目录下建立.htaccess如下: 12345678910Options +FollowSymLinks IndexIgnore */* RewriteEngine on # if a directory or a file exists, use it directly RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . index.php nginx下在php配置模块和location模块添加rewrite如下： 123456789101112131415161718location / &#123; root /home/george/workspace/EclipsePHP/webroot; index index.html index.php index.htm; #try_files $uri $uri/ @rewrite; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125;&#125;location ~ \\.php$ &#123; root /home/george/workspace/EclipsePHP/webroot; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/george/workspace/EclipsePHP/webroot$fastcgi_script_name; include fastcgi_params; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125;&#125; 完了，再看看你的网站的url 是不是漂亮了不少，同行努力！","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"ubuntu和centos的时间更新操作","date":"2025-05-29T02:38:04.000Z","path":"2025/05/29/ubuntu和centos的时间更新操作.html","text":"在Ubuntu Server上，设置NTP时间同步非常简单，就如下几步： 第一，可以先进行手动更新一次时间（可选）： sudo ntpdate ntp.ubuntu.com 第二，创建一个定时执行的文件： sudo vim /etc/cron.daily/ntpdate 然后在其中添加一行：ntpdate ntp.ubuntu.com，保存退出。 第三，修改这个定时执行文件的权限，使其变成可执行文件： sudo chmod 755 /etc/cron.daily/ntpdate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 下面解析一下,第一句是把当前时区调整为上海就是+8区,想改其他时区也可以去看看&#x2F;usr&#x2F;share&#x2F;zoneinfo目录; 然后第二句是利用ntpdate同步标准时间. 没有安装ntpdate的可以yum一下: yum install -y ntpdate 加入定时计划任务，每隔10分钟同步一下时钟 crontab -e 0-59/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP 这样，我们就可以来解决在CentOS系统中时间不准确的问题了。 如果执行命令出现一下错误 1.提示：7 Dec 19:24:55 ntpdate[2120]: the NTP socket is in use, exiting 这个是你linux机器上已经存在这个进程，输入：ps -ef | grep ntpd Kill掉ntp的进程 2.提示：No Server suitable for synchronization found 这个是最容易出现的问题，比较常见的是配置好服务器并启动服务器进程后，马上 启动客户进程，那么客户进程就会报错。解决方法是，在大约3-5分钟以后启动进程就行","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"}]},{"title":"Hello World","date":"2025-05-28T08:10:14.000Z","path":"2025/05/28/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gowhich.com/tags/Hexo/"}]},{"title":"开始第一篇记录","date":"2025-05-28T08:10:14.000Z","path":"2025/05/28/开始第一篇记录.html","text":"这是第一篇记录","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]}]