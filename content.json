[{"title":"MySQL创建字段的空格问题","date":"2025-06-09T10:10:19.000Z","path":"2025/06/09/MySQL创建字段的空格问题.html","text":"下面举例子中空格我用【X】来表示 请看这条sql语句 123INSERT INTO teleplay_tieba_daily (`t_t_id`,`sum`,`post_sum`,`subject_sum`,`member_sum`,`check_sum`,`yesterday_fans_num`, `yesterday_post_num`, `yesterday_subject_num`,`yesterday_member_num`, `yesterday_check_num`,`spider_date`) VALUES (236,1790,24728,1837,1790,17,0,0,0,0,0,&#x27;2013-04-22&#x27;),(240,239,6824,1082,239,5,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5109,171,300,90,171,4,0,0,0,0,0,&#x27;2013-04-22&#x27;), (5139,97,2462,294,97,1,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5153,36,1215,181,36,0,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5276,26,759,115,26,0,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5358,53,320,93,53,0,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5387,3156,85687,4389,3156,54,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5429,1181,13811,2430,1181,14,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5480,46,749,117,46,0,0,0,0,0,0,&#x27;2013-04-22&#x27;) 按道理说是没有问题的，但是给出的错误是： Unknown column ‘yesterday_check_num’ in ‘field list’注意，是字段没有 反复看了一下，通过借助phpmyadmin的选择字段的方式添加数据，执行后，居然成功了 123INSERT INTO teleplay_tieba_daily (`t_t_id`,`sum`,`post_sum`,`subject_sum`,`member_sum`,`check_sum`,`yesterday_fans_num`, `yesterday_post_num`,`yesterday_subject_num`, `yesterday_member_num`,`【x】yesterday_check_num`,`spider_date`) VALUES (236,1790,24728,1837,1790,17,0,0,0,0,0,&#x27;2013-04-22&#x27;),(240,239,6824,1082,239,5,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5109,171,300,90,171,4,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5139,97,2462,294,97,1,0,0,0,0,0,&#x27;2013-04-22&#x27;), (5153,36,1215,181,36,0,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5276,26,759,115,26,0,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5358,53,320,93,53,0,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5387,3156,85687,4389,3156,54,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5429,1181,13811,2430,1181,14,0,0,0,0,0,&#x27;2013-04-22&#x27;),(5480,46,749,117,46,0,0,0,0,0,0,&#x27;2013-04-22&#x27;) 发现字段的真相是’【x】yesterday_check_num’，但是我想，我最初在创建字段的时候，为什么mysql没有把左右两边的空格过滤掉，这是漏洞还是mysql故意要这样设计的呢？如果有一天一个像我一样的程序员，也做了类似的事情，后面的程序员做sql插入的时候，估计会很困惑。因为这个问题，不去仔仔细细的查找，根本找不出原因。 另外程序员在处理输入的字符的时候都会将两边的空格去掉才对","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.gowhich.com/tags/MySQL/"}]},{"title":"Yii框架中CGridView修改值的类型，处理值的方式","date":"2025-06-09T09:41:16.000Z","path":"2025/06/09/Yii框架中CGridView修改值的类型，处理值的方式.html","text":"表中的每一行代表一个数据项的数据,和一个列通常代表一个属性的物品(一些列可能对应于复杂的表达式的属性或静态文本)。 CGridView既支持排 序和分页的数据项。排序和分页可以在AJAX模式或正常的页面请求。使用CGridView的一个好处是,当用户浏览器禁用JavaScript,排序和 分页自动退化普通页面请求和仍然正常运行。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$this-&gt;widget(&#x27;zii.widgets.grid.CGridView&#x27;, [ &#x27;id&#x27; =&gt; &#x27;chapter-grid&#x27;, &#x27;dataProvider&#x27; =&gt; $model-&gt;search(), //数据结果集 &#x27;filter&#x27; =&gt; $model, &#x27;columns&#x27; =&gt; [ &#x27;id&#x27;, //锚点&lt;a href=&quot;http://www.gulianqiang.com/&quot;&gt;&lt;/a&gt; [ &#x27;name&#x27; =&gt; &#x27;name&#x27;, &#x27;type&#x27; =&gt; &#x27;raw&#x27;, &#x27;value&#x27; =&gt; &#x27;CHtml::link($data-&gt;name,&quot;/book/$data-&gt;id&quot;)&#x27;, ], //图片 [ &#x27;name&#x27; =&gt; &#x27;image&#x27;, &#x27;type&#x27; =&gt; &#x27;image&#x27;, &#x27;value&#x27; =&gt; &#x27;LImages::getPath(&quot;book&quot;).$data-&gt;image&#x27;, //图片相对路径 ], //下拉列表 [ &#x27;name&#x27; =&gt; &#x27;type&#x27;, &#x27;value&#x27; =&gt; &#x27;Lookup::item(&quot;chapterType&quot;,$data-&gt;type)&#x27;, &#x27;filter&#x27; =&gt; Lookup::items(&#x27;chapterType&#x27;), ], //内容截取 [ &#x27;name&#x27; =&gt; &#x27;content&#x27;, &#x27;type&#x27; =&gt; &#x27;html&#x27;, &#x27;value&#x27; =&gt; &#x27;mb_substr(htmlspecialchars_decode($data-&gt;content),0,100,&quot;utf-8&quot;)&#x27;, ], //时间 [ &#x27;name&#x27; =&gt; &#x27;create_time&#x27;, &#x27;type&#x27; =&gt; &#x27;datetime&#x27;, ], // 根据相关信息读数据库 [ &#x27;name&#x27; =&gt; &#x27;user_id&#x27;, &#x27;value&#x27; =&gt; &#x27;User::model()-&gt;findbyPk($data-&gt;user_id)-&gt;username&#x27;, &#x27;filter&#x27; =&gt; false, ], [ &#x27;class&#x27; =&gt; &#x27;CButtonColumn&#x27;, ], ],]); 我的使用代码： 其实也是可以加入自己的方法的 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$this-&gt;widget(&#x27;zii.widgets.grid.CGridView&#x27;, [ &#x27;id&#x27; =&gt; &#x27;link-grid&#x27;, &#x27;dataProvider&#x27; =&gt; $model-&gt;search(), &#x27;summaryCssClass&#x27; =&gt; &#x27;hide&#x27;, &#x27;itemsCssClass&#x27; =&gt; &#x27;table table-bordered&#x27;, &#x27;emptyText&#x27; =&gt; &#x27;搜索结果为空&#x27;, &#x27;pagerCssClass&#x27; =&gt; &#x27;pagination&#x27;, &#x27;filterCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;pager&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLinkPager&#x27;, &#x27;nextPageLabel&#x27; =&gt; &#x27;下一页&#x27;, &#x27;prevPageLabel&#x27; =&gt; &#x27;上一页&#x27;, &#x27;firstPageLabel&#x27; =&gt; &#x27;最前&#x27;, &#x27;lastPageLabel&#x27; =&gt; &#x27;最后&#x27;, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;], &#x27;header&#x27; =&gt; &#x27;&#x27;, &#x27;hiddenPageCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;selectedPageCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;previousPageCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;nextPageCssClass&#x27; =&gt; &#x27;&#x27;, ], &#x27;filter&#x27; =&gt; $model, &#x27;columns&#x27; =&gt; [ &#x27;title&#x27; =&gt; [ &#x27;name&#x27; =&gt; &#x27;title&#x27;, &#x27;type&#x27; =&gt; &#x27;raw&#x27;, &#x27;value&#x27; =&gt; &#x27;Helper::truncate_utf8_string($data-&gt;title, 20,\\&#x27;......\\&#x27;)&#x27;, ], &#x27;url&#x27; =&gt; [ &#x27;name&#x27; =&gt; &#x27;url&#x27;, &#x27;type&#x27; =&gt; &#x27;raw&#x27;, &#x27;value&#x27; =&gt; &#x27;Helper::truncate_utf8_string($data-&gt;url, 20,\\&#x27;......\\&#x27;)&#x27;, ], &#x27;create_date&#x27;, [ &#x27;class&#x27; =&gt; &#x27;CButtonColumn&#x27;, ], ],]); 以上已经提供常用的数据显示类型。基本可以将使用Yii框架开发web应用使用CGridView的情况都列出。 参考资料：http://www.gulianqiang.com/yii/158.html","tags":[{"name":"Yii","slug":"Yii","permalink":"https://blog.gowhich.com/tags/Yii/"}]},{"title":"Memcache-PHP中操作Memcache","date":"2025-06-09T08:40:31.000Z","path":"2025/06/09/Memcache-PHP中操作Memcache.html","text":"简介memcache模块是一个高效的守护进程，提供用于内存缓存的过程式程序和面向对象的方便的接口，特别是对于设计动态web程序时减少对数据库的访问。 memcache也提供用于通信对话（session_handler）的处理。 更多Memcache 模块相关信息可以到 http://www.danga.com/memcached/ 查阅。 memcache在php.ini中的配置项列表memcache在php.ini中的配置项列表 名称 默认值 是否可变 改变日志 memcache.allow_failover “1” PHP_INI_ALL Available since memcache 2.0.2. memcache.max_failover_attempts “20” PHP_INI_ALL Available since memcache 2.1.0. memcache.chunk_size “8192” PHP_INI_ALL Available since memcache 2.0.2. memcache.default_port “11211” PHP_INI_ALL Available since memcache 2.0.2. memcache.hash_strategy “standard” PHP_INI_ALL Available since memcache 2.2.0. memcache.hash_function “crc32” PHP_INI_ALL Available since memcache 2.2.0. session.save_handler “files” PHP_INI_ALL Supported since memcache 2.1.2 session.save_path “” PHP_INI_ALL Supported since memcache 2.1.2 有关 PHP_INI_* 常量进一步的细节与定义参见PHP手册php.ini 配置选项。 以下是配置项的简要解释 memcache.allow_failover Boolean 在错误时是否透明的故障转移到其他服务器上处理（注：故障转移是动词）。 memcache.max_failover_attempts integer 定义服务器的数量类设置和获取数据，只联合 memcache.allow_failover 一同使用。 memcache.chunk_size integer 数据将会被分成指定大小（chunk_size）的块来传输，这个值（chunk_size）越小，写操作的请求就越多，如果发现其他的无法解释的减速，请试着将这个值增大到32768. memcache.default_port string 当连接memcache服务器的时候，如果没有指定端口这个默认的tcp端口将被用。 memcache.hash_strategy string 控制在映射 key 到服务器时使用哪种策略。设置这个值一致能使hash 算法始终如一的使用于服务器接受添加或者删除池中变量时将不会被重新映射。设置这个值以标准的结果在旧的策略被使用时。 memcache.hash_function string 控制哪种 hsah 函数被应用于 key映射 到服务器过程中，默认值“crc32”使用 CRC32 算法，而“fnv”则表示使用 FNV-1a 算法。 session.save_handler string 通过设置这个值为memcache来确定使用 memcache 用于通信对话的处理（session handler）。 session.save_path string 定义用于通话存储的各服务器链接的分隔符号，例如：“tcp:&#x2F;&#x2F;host1:11211, tcp:&#x2F;&#x2F;host2:11211”。每 服务器个链接可以包含被接受于该服务器的参数，比较类似使用 Memcache::addServer() 来添加的服务器，例如：“tcp:&#x2F;&#x2F;host1:11211?persistent&#x3D;1&amp;weight&#x3D;1&amp;timeout&#x3D;1&amp; amp; amp;retry_interval&#x3D;15”。 memcache常量列表memcache常量列表 名称 类型 描述 MEMCACHE_COMPRESSED integer 用于调整在使用 Memcache::set(), Memcache::add() 和 Memcache::replace() 几个函数时的压缩比率。 MEMCACHE_HAVE_SESSION integer 如果通信对话的处理（session handler）被允许使用其值为 1，其他情况值为 0。 Memcache Functions 函数列表Memcache::connect说明 bool Memcache::connect ( string $host [, int $port [, int $timeout ]] ) 连接memcache服务器 参数 - - $host(string) 服务器域名或ip $port(int) 服务器tcp端口号，默认值是11211 $timeout 连接memcache进程的失效时间，在修改它的默认值1的时候要三思，以免失去所有memcache缓存的优势导致连接变得很慢。 返回值如果成功则返回true，失败则返回false 范例12345/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/* OO API */$memcache = new Memcache;$memcache-&gt;connect(‘memcache_host‘, 11211); Memcache::pconnect说明 bool Memcache::pconnect ( string $host [, int $port [, int $timeout ]] )以长连接方式连接服务器 参数 - - $host(string) 服务器域名或ip $port(int) 服务器tcp端口号，默认值是11211 $timeout 连接memcache进程的失效时间，在修改它的默认值1的时候要三思，以免失去所有memcache缓存的优势导致连接变得很慢。 返回值如果成功则返回true，失败则返回false 范例12345/* procedural API */$memcache_obj = memcache_pconnect(‘memcache_host‘, 11211);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;pconnect(‘memcache_host‘, 11211); Memcache::close说明 bool Memcache::close ( void ) 关闭对象 (对常连接不起作用) 返回值如果成功则返回true，失败则返回false 范例123456789/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/* do something here .. */memcache_close($memcache_obj);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);/* do something here .. */$memcache_obj-&gt;close(); Memcache::addServer(#2-4)说明 bool Memcache::addServer ( string $host [, int $port [, bool $persistent [, int $weight [, int $timeout [, int $retry_interval [, bool $status [, callback $failure_callback ]]]]]]] )向对象添加一个服务器（注：addServer没有连接到服务器的动作，所以在memcache进程没有启动的时候，执行addServer成功也会返回true） 参数 - - host 服务器域名或 IP port 端口号，默认为 11211 persistent 是否使用常连接，默认为 TRUE weight 权重，在多个服务器设置中占的比重 timeout 连接服务器失效的秒数，修改默认值 1 时要三思，有可能失去所有缓存方面的优势导致连接变得很慢 retry_interval 服务器连接失败时的重试频率，默认是 15 秒一次，如果设置为 -1 将禁止自动重试，当扩展中加载了 dynamically via dl() 时，无论本参数还是常连接设置参数都会失效。 每一个失败的服务器在失效前都有独自的生存期，选择后端请求时会被跳过而不服务于请求。一个过期的连接将成功的重新连接或者被标记为失败的连接等待下一次 重试。这种效果就是说每一个 web server 的子进程在服务于页面时的重试连接都跟他们自己的重试频率有关。 |status | 控制服务器是否被标记为 online，设置这个参数为 FALSE 并设置 retry_interval 为 -1 可以使连接失败的服务器被放到一个描述不响应请求的服务器池子中，对这个服务器的请求将失败，接受设置为失败服务器的设置，默认参数为 TRUE，代表该服务器可以被定义为 online。|failure_callback| 失败时的回调函数，函数的两个参数为失败服务器的 hostname 和 port 返回值成功返回 TRUE，失败返回 FALSE。注：在测试addServer函数的时候我们主要测试了其参数retry_interval和status 范例retry_interval参数的测试123$mem = new Memcache;$is_add = $mem-&gt;addServer(‘localhost‘, 11211, true, 1, 1, 15, true); // retrt_interval=15$is_set = $mem-&gt;set(‘key1‘, ‘中华人民共和国‘); 上面的例子中如果localhost服务器down掉或是memcache守护进程当掉，执行请求的时候连接服务器失败时算起15秒后会自动重试连 接服务器，但是在这15秒内不会去连接这个服务器，就是只要有请求，没15秒就会尝试连接服务器，但是每个服务器连接重试是独立的。比如说我一次添加了两 个服务器一个是localhost，一个是172.16.100.60，它们分别是从各自连接失败那个时间算起，只要对各自服务器有请求就会每隔15秒去 连接各自的服务器的。 retry_interval和status结合使用的情况12345&lt;?php$mem = new Memcache;$is_add = $mem-&gt;addServer(‘localhost‘, 11211, true, 1, 1, -1, false); // retrt_interval=-1, status=false$is_set = $mem-&gt;set(‘key1‘, ‘中华人民共和国‘);?&gt; 在上面的retrt_interval&#x3D;-1, status&#x3D;false这种情况下，将连接失败的服务器放到一个不响应请求的一个池子中，因此对key分配的算法也就没有影响了，而他是立即返回错误失败还是故障转移还要看memcache.allow_failover的设置，执行set， add， replace，get等请求的时候都会失败返回false，即使memcache进程运行正常。 status参数的测试除了与retry_interval结合使用，status单独使用的情况会对函数memcache::getServerStatu获得的结果产生影响无论memcache进程的正常运行还是当掉，status为true的时候getServerStatus的结果都是true，反之则为false但是在memcache进程正常运行的情况下，对set，add，replace，get等函数都没有影响。 Memcache::add说明 bool Memcache::add ( string $key , mixed $var [, int $flag [, int $expire ]] )添加一个要缓存的数据如果作为这个缓存的数据的键在服务器上还不存在的情况下, 参数 - - key 缓存数据的键 其长度不能超过250个字符 var 值，整型将直接存储，其他类型将被序列化存储 ，其值最大为1M flag 是否使用 zlib 压缩 ,当flag&#x3D;MEMCACHE_COMPRESSED的时侯，数据很小的时候不会采用zlib压缩，只有数据达到一定大小才对数据进行zlib压缩。（没有具体的测试数据进行压缩的最小值是多少） expire 过期时间，0 为永不过期，可使用 unix 时间戳格式或距离当前时间的秒数，设为秒数时不能大于 2592000（30 天） 返回值成功返回 TRUE，失败返回 FALSE，如果这个键已经存在，其他方面memcache:;add()的行为与memcache::set相似 范例1234567&lt;?php$memcache_obj = memcache_connect(&quot;localhost&quot;, 11211);/* procedural API */memcache_add($memcache_obj, ‘var_key‘, ‘test variable‘, FALSE, 30);/* OO API */$memcache_obj-&gt;add(‘var_key‘, ‘test variable‘, FALSE, 30);?&gt; Memcache::replace说明 bool Memcache::replace ( string $key , mixed $var [, int $flag [, int $expire ]] )替换一个指定 已存在key 的的缓存变量内容 参数 - - key 缓存数据的键， 其长度不能超过250个字符 var 值，整型将直接存储，其他类型将被序列化存储，其值最大为1M flag 是否使用 zlib 压缩 ,当flag&#x3D;MEMCACHE_COMPRESSED的时侯，数据很小的时候不会采用zlib压缩，只有数据达到一定大小才对数据进行zlib压缩。（没有具体的测试数据进行压缩的最小值是多少） expire 过期时间，0 为永不过期，可使用 unix 时间戳格式或距离当前时间的秒数，设为秒数时不能大于 2592000（30 天） 返回值成功返回 TRUE，失败返回 FALSE。 范例1234567&lt;?php$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/* procedural API */memcache_replace($memcache_obj, &quot;test_key&quot;, &quot;some variable&quot;, FALSE, 30);/* OO API */$memcache_obj-&gt;replace(&quot;test_key&quot;, &quot;some variable&quot;, FALSE, 30);?&gt; Memcache::set说明 bool Memcache::set ( string $key , mixed $var [, int $flag [, int $expire ]] )设置一个指定 key 的缓存变量内容 参数 - - key 缓存数据的键， 其长度不能超过250个字符 var 值，整型将直接存储，其他类型将被序列化存储，其值最大为1M flag 是否使用 zlib 压缩 ,当flag&#x3D;MEMCACHE_COMPRESSED的时侯，数据很小的时候不会采用zlib压缩，只有数据达到一定大小才对数据进行zlib压缩。（没有具体的测试数据进行压缩的最小值是多少） expire 过期时间，0 为永不过期，可使用 unix 时间戳格式或距离当前时间的秒数，设为秒数时不能大于 2592000（30 天） 返回值成功返回 TRUE，失败返回 FALSE。 范例123456789101112&lt;?php/* procedural API *//* connect to memcached server */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/*set value of item with key ‘var_key‘using 0 as flag value, compression is not usedexpire time is 30 second*/memcache_set($memcache_obj, ‘var_key‘, ‘some variable‘, 0, 30);echo memcache_get($memcache_obj, ‘var_key‘);?&gt; 123456789101112&lt;?php/* OO API */$memcache_obj = new Memcache;/* connect to memcached server */$memcache_obj-&gt;connect(‘memcache_host‘, 11211);/*set value of item with key ‘var_key‘, using on-the-fly compressionexpire time is 50 seconds*/$memcache_obj-&gt;set(‘var_key‘, ‘some really big variable‘, MEMCACHE_COMPRESSED, 50);echo $memcache_obj-&gt;get(‘var_key‘);?&gt; Memcache::get说明 string Memcache::get ( string $key [, int &amp;$flags ] )array Memcache::get ( array $keys [, array &amp;$flags ] )获取某个 key 的变量缓存值 参数 - - key 缓存值的键 flags 如果是传址某个变量，获取缓存值被set或是add的flag结果将被存于该变量 返回值返回缓存的指定 key 的变量内容或者是在失败或该变量的值不存在时返回 FALSE如果传出的key的数组中的key都不存在，返回的结果是一个空数组，反之则返回key与缓存值相关联的关联数组 范例1234567891011121314151617181920212223&lt;?php/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);$var = memcache_get($memcache_obj, ‘some_key‘);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);$var = $memcache_obj-&gt;get(‘some_key‘);/*You also can use array of keys as a parameter.If such item wasn‘t found at the server, the resultarray simply will not include such key.*//* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);$var = memcache_get($memcache_obj, Array(‘some_key‘, ‘another_key‘));//如果some_key，another_key不存在 $var = array();//如果some_key，another_key存在 $var = array(‘some_key‘=&gt;‘缓存值‘, ‘another_key‘=&gt;‘缓存值‘);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);$var = $memcache_obj-&gt;get(Array(‘some_key‘, ‘second_key‘));?&gt; Memcache::delete说明 bool Memcache::delete ( string $key [, int $timeout ] ) 删除某一个变量的缓存 参数 - - key 缓存的键 键值不能为null和‘’，当它等于前面两个值的时候php会有警告错误。 timeout 删除这项的时间，如果它等于0，这项将被立刻删除反之如果它等于30秒，那么这项被删除在30秒内 返回值成功返回 TRUE，失败返回 FALSE。 范例12345678910&lt;?php/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/* after 10 seconds item will be deleted by the server */memcache_delete($memcache_obj, ‘key_to_delete‘, 10);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);$memcache_obj-&gt;delete(‘key_to_delete‘, 10);?&gt; Memcache::flush说明 bool Memcache::flush ( void ) 清空所有缓存内容，不是真的删除缓存的内容，只是使所有变量的缓存过期，使内存中的内容被重写 返回值成功返回 TRUE，失败返回 FALSE。 范例12345678910&lt;?php/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);memcache_flush($memcache_obj);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);$memcache_obj-&gt;flush();?&gt; Memcache::getExtendedStats说明 array Memcache::getExtendedStats ([ string $type [, int $slabid [, int $limit ]]] ) 获取所有服务器扩展静态信息 参数 - - type 静态信息类型，有效值包括{reset, malloc, maps, cachedump, slabs, items, sizes}，依照一定规则协议这个可选参数是为了方便开发人员查看不同类别的信息而输入的标题 slabid 用于按指定类型联合设置 cache 堆为有效的片到堆中。缓存堆被被命令绑定到服务器上并被严格的用于调试用途 limit 用于按指定类型联合设置 cache 堆为输入的数字所限制的大小到堆，默认值为 100 返回值返回一个由服务器扩展静态信息二维数组，失败时返回 FALSE 范例1234567&lt;?php$memcache_obj = new Memcache;$memcache_obj-&gt;addServer(‘memcache_host‘, 11211);$memcache_obj-&gt;addServer(‘failed_host‘, 11211);$stats = $memcache_obj-&gt;getExtendedStats(); print_r($stats);?&gt; 输出结果 123456789101112131415161718192021222324Array([memcache_host:11211] =&gt; Array([pid] =&gt; 3756[uptime] =&gt; 603011[time] =&gt; 1133810435[version] =&gt; 1.1.12[rusage_user] =&gt; 0.451931[rusage_system] =&gt; 0.634903[curr_items] =&gt; 2483[total_items] =&gt; 3079[bytes] =&gt; 2718136[curr_connections] =&gt; 2[total_connections] =&gt; 807[connection_structures] =&gt; 13[cmd_get] =&gt; 9748[cmd_set] =&gt; 3096[get_hits] =&gt; 5976[get_misses] =&gt; 3772[bytes_read] =&gt; 3448968[bytes_written] =&gt; 2318883[limit_maxbytes] =&gt; 33554432),[failed_host:11211] =&gt;) Memcache::getStats说明 array Memcache::getStats ([ string $type [, int $slabid [, int $limit ]]] ) 获取最后添加服务器静态信息 参数 - - type 静态信息类型，有效值包括{reset, malloc, maps, cachedump, slabs, items, sizes}，依照一定规则协议这个可选参数是为了方便开发人员查看不同类别的信息而输入的标题 slabid 用于按指定类型联合设置 cache 堆为有效的片到堆中。缓存堆被被命令绑定到服务器上并被严格的用于调试用途 limit 用于按指定类型联合设置 cache 堆为输入的数字所限制的大小到堆，默认值为 100 返回值返回一个服务器静态信息数组，失败时返回 FALSE Memcache::getServerStatus说明 int Memcache::getServerStatus ( string $host [, int $port ] ) 通过输入的 host 及 port 来获取相应的服务器信息 参数 - - host 服务器域名或 IP port 端口号，默认为 11211 返回值返回服务器状态，0 为失败，其他情况返回非 0 数字 范例123456789&lt;?php/* OO API */$memcache = new Memcache;$memcache-&gt;addServer(‘memcache_host‘, 11211);echo $memcache-&gt;getServerStatus(‘memcache_host‘, 11211);/* procedural API */$memcache = memcache_connect(‘memcache_host‘, 11211);echo memcache_get_server_status($memcache, ‘memcache_host‘, 11211);?&gt; Memcache::getVersion说明 string Memcache::getVersion ( void ) 获取服务器的版本号信息 返回值成功返回服务器的版本号字符串，失败返回 FALSE 范例123456789&lt;?php/* OO API */$memcache = new Memcache;$memcache-&gt;connect(‘memcache_host‘, 11211);echo $memcache-&gt;getVersion();/* procedural API */$memcache = memcache_connect(‘memcache_host‘, 11211);echo memcache_get_version($memcache);?&gt; Memcache::setCompressThreshold bool Memcache::setCompressThreshold ( int $threshold [, float $min_savings ] )设置压缩极限 参数 - - threshold 设置控制自动压缩的变量长度的最小值 min_saving 指定的最低压缩比率，值必须介于 0 - 1 之间，默认为 0.2 代表 20% 的压缩比率 返回值成功返回 TRUE，失败返回 FALSE。 范例123456789&lt;?php/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;addServer(‘memcache_host‘, 11211);$memcache_obj-&gt;setCompressThreshold(20000, 0.2);/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);memcache_set_compress_threshold($memcache_obj, 20000, 0.2);?&gt; Memcache::setServerParams说明 bool Memcache::setServerParams ( string $host [, int $port [, int $timeout [, int $retry_interval [, bool $status [, callback $failure_callback ]]]]] )Memcache version 2.1.0 后增加的函数，运行时设置服务器参数 参数 - - host 服务器域名或 IP port 端口号，默认为 11211 timeout 超时连接失效的秒数，修改默认值 1 时要三思，有可能失去所有缓存方面的优势导致连接变得很慢 retry_interval 服务器连接失败时的重试频率，默认是 15 秒一次，如果设置为 -1 将禁止自动重试，当扩展中加载了 dynamically via dl() 时，无论本参数还是常连接设置参数都会失效。 每一个失败的服务器在失效前都有独自的生存期，选择后端请求时会被跳过而不服务于请求。一个过期的连接将成功的重新连接或者被标记为失败的连接等待下一次 重试。这种效果就是说每一个 web server 的子进程在服务于页面时的重试连接都跟他们自己的重试频率有关。 status 控制服务器是否被标记为 online，设置这个参数为 FALSE 并设置 retry_interval 为 -1 可以使连接失败的服务器被放到一个描述不响应请求的服务器池子中，对这个服务器的请求将失败，接受设置为失败服务器的设置，默认参数为 TRUE，代表该服务器可以被定义为 online。 failure_callback 失败时的回调函数，函数的两个参数为失败服务器的 hostname 和 port 返回值成功返回 TRUE，失败返回 FALSE。 范例1234567891011121314&lt;?phpfunction _callback_memcache_failure($host, $port)&#123; print &quot;memcache ‘$host:$port‘ failed&quot;;&#125;/* OO API */$memcache = new Memcache;// Add the server in offline mode$memcache-&gt;addServer(‘memcache_host‘, 11211, FALSE, 1, 1, -1, FALSE);// Bring the server back online$memcache-&gt;setServerParams(‘memcache_host‘, 11211, 1, 15, TRUE, ‘_callback_memcache_failure‘);/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);memcache_set_server_params($memcache_obj, ‘memcache_host‘, 11211, 1, 15, TRUE, ‘_callback_memcache_failure‘);?&gt; Memcache::increment说明 int Memcache::increment ( string $key [, int $value ] )给指定 key 的缓存变量一个增值，如果该变量不是数字时不会被转化为数字，这个增值将会加到该变量原有的数字之上，变量不存在不会新增变量，对于压缩存储的变量不要使用本函数因为相应的取值方法会失败。 参数 - - key 缓存值的键 value 值，整型将直接存储，其他类型将被序列化存储 返回值成功返回新的变量值，失败返回 FALSE。 范例1234567891011&lt;?php/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/* increment counter by 2 */$current_value = memcache_increment($memcache_obj, ‘counter‘, 2);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);/* increment counter by 3 */$current_value = $memcache_obj-&gt;increment(‘counter‘, 3);?&gt; Memcache::decrement说明 int Memcache::decrement ( string $key [, int $value ] )给指定 key 的缓存变量一个递减值，与 increment 操作类似，将在原有变量基础上减去这个值，该项的值将会在转化为数字后减去，新项的值不会小于 0，对于压缩存储的变量不要使用本函数因为相应的取值方法会失败。 参数 - - key 缓存值的键 value 值，整型将直接存储，其他类型将被序列化存储 返回值成功返回新的变量值，失败返回 FALSE。 范例1234567891011&lt;?php/* procedural API */$memcache_obj = memcache_connect(‘memcache_host‘, 11211);/* decrement item by 2 */$new_value = memcache_decrement($memcache_obj, ‘test_item‘, 2);/* OO API */$memcache_obj = new Memcache;$memcache_obj-&gt;connect(‘memcache_host‘, 11211);/* decrement item by 3 */$new_value = $memcache_obj-&gt;decrement(‘test_item‘, 3);?&gt; memcache_debug说明 bool memcache_debug ( bool $on_off ) 设置 memcache 的调试器是否开启，值为 TRUE 或 FALSE。 受影响于 php 安装时是否使用了 –enable-debug 选项，如果使用了该函数才会返回 TRUE，其他情况将始终返回 FALSE。 参数 - - on_off 设置调试模式是否开启，TRUE 为开启，FALSE 为关闭 返回值php 安装时如果使使用了 –enable-debug 选项返回 TRUE，否则将返回 FALSE。 参考资料来源：http://www.cnblogs.com/qiantuwuliang/archive/2011/03/07/1974499.html","tags":[{"name":"Memcache","slug":"Memcache","permalink":"https://blog.gowhich.com/tags/Memcache/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Memcache的客户端连接","date":"2025-06-09T08:30:09.000Z","path":"2025/06/09/Memcache的客户端连接.html","text":"许多语言都实现了连接memcached的客户端，其中以Perl、PHP为主。 仅仅memcached网站上列出的语言就有 Perl PHP Python Ruby C# C&#x2F;C++ Lua 等等。 memcached客户端API：http://www.danga.com/memcached/apis.bml这里介绍通过mixi正在使用的Perl库链接memcached的方法。 使用Cache::MemcachedPerl的memcached客户端有 Cache::Memcached Cache::Memcached::Fast Cache::Memcached::libmemcached 等几个CPAN模块。这里介绍的Cache::Memcached是memcached的作者Brad Fitzpatric的作品， 应该算是memcached的客户端中应用最为广泛的模块了。 Cache::Memcached – search.cpan.org: http://search.cpan.org/dist/Cache-Memcached/ 使用Cache::Memcached连接memcached下面的源代码为通过Cache::Memcached连接刚才启动的memcached的例子。 1234567891011121314151617#!/usr/bin/perluse strict;use warnings;use Cache::Memcached;my $key = &quot;foo&quot;;my $value = &quot;bar&quot;;my $expires = 3600; # 1 hourmy $memcached = Cache::Memcached-&gt;new(&#123; servers =&gt; [&quot;127.0.0.1:11211&quot;], compress_threshold =&gt; 10_000&#125;);$memcached-&gt;add($key, $value, $expires);my $ret = $memcached-&gt;get($key);print &quot;$ret\\n&quot;; 在这里，为Cache::Memcached指定了memcached服务器的IP地址和一个选项，以生成实例。 Cache::Memcached常用的选项如下所示。 选项 说明 servers 用数组指定memcached服务器和端口 compress_threshold 数据压缩时使用的值 namespace 指定添加到键的前缀 另外，Cache::Memcached通过Storable模块可以将Perl的复杂数据序列化之后再保存， 因此散列、数组、对象等都可以直接保存到memcached中。 保存数据向memcached保存数据的方法有 add replace set 它们的使用方法都相同： 12345my $add = $memcached-&gt;add( &#x27;键&#x27;, &#x27;值&#x27;, &#x27;期限&#x27; );my $replace = $memcached-&gt;replace( &#x27;键&#x27;, &#x27;值&#x27;, &#x27;期限&#x27; );my $set = $memcached-&gt;set( &#x27;键&#x27;, &#x27;值&#x27;, &#x27;期限&#x27; );my $val = $memcached-&gt;get(&#x27;键&#x27;);my $val = $memcached-&gt;get_multi(&#x27;键1&#x27;, &#x27;键2&#x27;, &#x27;键3&#x27;, &#x27;键4&#x27;, &#x27;键5&#x27;); 一次取得多条数据时使用getmulti。getmulti可以非同步地同时取得多个键值， 其速度要比循环调用get快数十倍。 删除数据删除数据使用delete方法，不过它有个独特的功能。 1$memcached-&gt;delete(&#x27;键&#x27;, &#x27;阻塞时间(秒)&#x27;); 删除第一个参数指定的键的数据。第二个参数指定一个时间值，可以禁止使用同样的键保存新数据。 此功能可以用于防止缓存数据的不完整。但是要注意，set函数忽视该阻塞，照常保存数据 增一和减一操作可以将memcached上特定的键值作为计数器使用。 12my $ret = $memcached-&gt;incr(&#x27;键&#x27;);$memcached-&gt;add(&#x27;键&#x27;, 0) unless defined $ret; 增一和减一是原子操作，但未设置初始值时，不会自动赋成0。因此， 应当进行错误检查，必要时加入初始化操作。而且，服务器端也不会对 超过2 SUP(32)时的行为进行检查。","tags":[{"name":"Memcache","slug":"Memcache","permalink":"https://blog.gowhich.com/tags/Memcache/"}]},{"title":"Memcache基础介绍","date":"2025-06-09T08:22:04.000Z","path":"2025/06/09/Memcache基础介绍.html","text":"memcached 是以LiveJournal 旗下Danga Interactive 公司的Brad Fitzpatric 为首开发的一款软件。现在已成为 mixi、 hatena、 Facebook、 Vox、LiveJournal等众多服务中 提高Web应用扩展性的重要因素。 许多Web应用都将数据保存到RDBMS中，应用服务器从中读取数据并在浏览器中显示。 但随着数据量的增大、访问的集中，就会出现RDBMS的负担加重、数据库响应恶化、 网站显示延迟等重大影响。 这时就该memcached大显身手了。memcached是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、 提高可扩展性。 memcached的特征memcached作为高速运行的分布式缓存服务器，具有以下的特点。 协议简单 基于libevent的事件处理 内置内存存储方式 memcached不互相通信的分布式 协议简单memcached的服务器客户端通信并不使用复杂的XML等格式， 而使用简单的基于文本行的协议。因此，通过telnet 也能在memcached上保存数据、取得数据。下面是例子。 12345678910$ telnet localhost 11211Trying 127.0.0.1...Connected to localhost.localdomain (127.0.0.1).Escape character is &#x27;^]&#x27;.set foo 0 0 3 （保存命令）bar （数据）STORED （结果）get foo （取得命令）VALUE foo 0 3 （数据）bar （数据） 协议文档位于memcached的源代码内，也可以参考以下的URL。 http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt 基于libevent的事件处理libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能 封装成统一的接口。即使对服务器的连接数增加，也能发挥O(1)的性能。 memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能。 可以参考Dan Kegel的The C10K Problem。 libevent: http://www.monkey.org/~provos/libevent/The C10K Problem: http://www.kegel.com/c10k.html 内置内存存储方式为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。 由于数据仅存在于内存中，因此重启memcached、重启操作系统会导致全部数据消失。 另外，内容容量达到指定值之后，就基于LRU(Least Recently Used)算法自动删除不使用的缓存。 memcached本身是为缓存而设计的服务器，因此并没有过多考虑数据的永久性问题。 memcached不互相通信的分布式memcached尽管是“分布式”缓存服务器，但服务器端并没有分布式功能。 各个memcached不会互相通信以共享信息。那么，怎样进行分布式呢？ 这完全取决于客户端的实现。 接下来简单介绍一下memcached的使用方法。 安装memcachedmemcached的安装比较简单，这里稍加说明。 memcached支持许多平台。 * Linux * FreeBSD * Solaris (memcached 1.2.5以上版本) * Mac OS X 另外也能安装在Windows上。这里使用Fedora Core 8进行说明。 memcached的安装运行memcached需要本文开头介绍的libevent库。Fedora 8中有现成的rpm包， 通过yum命令安装即可。 $ sudo yum install libevent libevent-devel memcached的源代码可以从memcached网站上下载。本文执笔时的最新版本为1.2.5。 Fedora 8虽然也包含了memcached的rpm，但版本比较老。因为源代码安装并不困难， 这里就不使用rpm了。 下载memcached：http://www.danga.com/memcached/download.bml memcached安装与一般应用程序相同，configure、make、make install就行了。 123456$ wget http://www.danga.com/memcached/dist/memcached-1.2.5.tar.gz$ tar zxf memcached-1.2.5.tar.gz$ cd memcached-1.2.5$ ./configure$ make$ sudo make install 默认情况下memcached安装到&#x2F;usr&#x2F;local&#x2F;bin下。 memcached的启动从终端输入以下命令，启动memcached。 123456789101112131415$ /usr/local/bin/memcached -p 11211 -m 64m -vvslab class 1: chunk size 88 perslab 11915slab class 2: chunk size 112 perslab 9362slab class 3: chunk size 144 perslab 7281中间省略...slab class 38: chunk size 391224 perslab 2slab class 39: chunk size 489032 perslab 2&lt;23 server listening&lt;24 send buffer was 110592, now 268435456&lt;24 server listening (udp)&lt;24 server listening (udp)&lt;24 server listening (udp)&lt;24 server listening (udp) 这里显示了调试信息。这样就在前台启动了memcached，监听TCP端口11211 最大内存使用量为64M。 作为daemon后台启动时，只需 1$ /usr/local/bin/memcached -p 11211 -m 64m -d 这里使用的memcached启动选项的内容如下。 选项 说明-p 使用的TCP端口。默认为11211-m 最大内存大小。默认为64M-vv 用very vrebose模式启动，调试信息和错误输出到控制台-d 作为daemon在后台启动 上面四个是常用的启动选项，其他还有很多，通过 1$ /usr/local/bin/memcached -h 命令可以显示。许多选项可以改变memcached的各种行为， 推荐读一读。","tags":[{"name":"Memcache","slug":"Memcache","permalink":"https://blog.gowhich.com/tags/Memcache/"}]},{"title":"Nodejs的安装、测试及hello world","date":"2025-06-09T08:19:55.000Z","path":"2025/06/09/Nodejs的安装、测试及hello-world.html","text":"安装：现在地址：http://www.nodejs.org/download/ 可以根据自己的系统类型，选择对应的安装文件，进行安装 测试写一个简单的hello world 123456var http = require(&#x27;http&#x27;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); response.end(&#x27;Hello World\\n&#x27;);&#125;).listen(8124);console.log(&#x27;Server running at http://127.0.0.1:8124/&#x27;); 使用浏览器，输入url地址http://127.0.0.1:8124/，可以看到输出Hello World字符串，如果没有说明出现问题了。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://blog.gowhich.com/tags/Nodejs/"}]},{"title":"CSS opacity透明度继承问题","date":"2025-06-09T08:18:15.000Z","path":"2025/06/09/CSS-opacity透明度继承问题.html","text":"元素透明的做法，大概如下 1#div.opacity&#123; filter:alpha(opacity:80);opacity:0.8; &#125; 但是结果导致的问题是，里面所有的元素都开始透明了 通过搜索，搜集资料，我发现了一个解决问题的方法 HTML文件代码如下： 1234567891011&lt;div class=&#x27;well activity-outer&#x27;&gt; &lt;div class=&#x27;activity-opacity&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;activity-inner&#x27;&gt; &lt;h4&gt;活动细则:&lt;/h4&gt; &lt;div class=&#x27;detail&#x27;&gt; &lt;p style=&#x27;margin:0;padding:0;text-indent:1em&#x27;&gt;1. 手机拍摄黑龙江卫视乱世佳人照片并上传, 选择上传到“天心恋”和“重心恋”其中一组&lt;/p&gt; &lt;p style=&#x27;margin:0;padding:0;text-indent:1em&#x27;&gt;2. 普通观众点击支持，看哪些照片（带黑龙江卫视台标）获得支持多,优先获得奖品&lt;/p&gt; &lt;p style=&#x27;margin:0;padding:0;text-indent:1em&#x27;&gt;3. 本活动在和黑龙江卫视播出最后一期结束&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS文件代码如下： 12345678910111213141516171819202122div.activity-outer&#123;padding:0;background-color:transparent;border:0&#125;div.activity-opacity,div.activity-inner&#123; height:100px; width:938px; left:0; position:relative; top:0; border-radius: 4px 4px 4px 4px; border-color:#ccc;&#125;div.activity-opacity&#123; background-color:#ccc; filter:alpha(opacity:80); opacity:.8;&#125;div.activity-inner&#123; margin-top: -119px; padding: 14px 4px 0 10px; color:white&#125; 以上两个文件的代码，是我做的网站的一个摘录，主css文件采用的是bootstrap这个css框架，记录一下。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.gowhich.com/tags/CSS/"}]},{"title":"Yii Relational Active Record（关联查询）relations","date":"2025-06-09T04:03:20.000Z","path":"2025/06/09/Yii-Relational-Active-Record（关联查询）relations.html","text":"在使用关联AR之前，首先要在数据库中建立关联的数据表之间的主键-外键关联，AR需要通过分析数据库中的定义数据表关联的元信息，来决定如何连接数据。 如何声明关联在使用AR进行关联查询之前，我们需要告诉AR各个AR类之间有怎样的关联。AR类之间的关联直接反映着数据库中这个类所代表的数据表之间的关联。从关系数据库的角度来说，两个数据表A，B之间可能的关联有三种：一对多，一对一，多对多。而在AR中，关联有以下四种：BELONGS_TO: 如果数据表A和B的关系是一对多，那我们就说B属于A（B belongs to A）。HAS_MANY: 如果数据表A和B的关系是多对一，那我们就说B有多个A（B has many A）。HAS_ONE: 这是‘HAS_MANY’关系中的一个特例，当A最多有一个的时候，我们说B有一个A （B has one A）。MANY_MANY: 这个相当于关系数据库中的多对多关系。因为绝大多数关系数据库并不直接支持多对多的关系，这时通常都需要一个单独的关联表，把多对多的关系分解为两个一对多的关系。用AR的方式去理解的话，我们可以认为 MANY_MANY关系是由BELONGS_TO和HAS_MANY组成的。在AR中声明关联，是通过覆盖（Override）父类CActiveRecord中的relations()方法来实现的。这个方法返回一个包含了关系定义的数组，数组中的每一组键值代表一个关联：&#39;VarName&#39;=&gt;array(&#39;RelationType&#39;, &#39;ClassName&#39;, &#39;ForeignKey&#39;, ...additional options)这里的VarName是这个关联的名称；RelationType指定了这个关联的类型，有四个常量代表了四种关联的类型：self::BELONGS_TO，self::HAS_ONE，self::HAS_MANY和self::MANY_MANYClassName是这个关系关联到的AR类的类名；ForeignKey指定了这个关联是通过哪个外键联系起来的。后面的additionaloptions可以加入一些额外的设置，后面会做介绍。 下面的代码演示了如何定义User和Post之间的关联。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Post extends CActiveRecord&#123; public function relations() &#123; return [ &#x27;author&#x27; =&gt; [ self::BELONGS_TO, &#x27;User&#x27;, &#x27;authorID&#x27;, ], &#x27;categories&#x27; =&gt; [ self::MANY_MANY, &#x27;Category&#x27;, &#x27;PostCategory(postID, categoryID)&#x27;, ], ]; &#125;&#125;class User extends CActiveRecord&#123; public function relations() &#123; return [ &#x27;posts&#x27; =&gt; [ self::HAS_MANY, &#x27;Post&#x27;, &#x27;authorID&#x27;, ], &#x27;profile&#x27; =&gt; [ self::HAS_ONE, &#x27;Profile&#x27;, &#x27;ownerID&#x27;, ], ]; &#125;&#125; 说明: 有时外键可能由两个或更多字段组成，在这里可以将多个字段名由逗号或空格分隔，一并写在这里。对于多对多的关系，关联表必须在外键中注明，例如在Post类的categories关联中，外键就需要写成PostCategory(postID, categoryID)。在AR类中声明关联时，每个关联会作为一个属性添加到AR类中，属性名就是关联的名称。在进行关联查询时，这些属性就会被设置为关联到的AR类的实例，例如在查询取得一个Post实例时，它的$author属性就是代表Post作者的一个User类的实例。 关联查询进行关联查询最简单的方式就是访问一个关联AR对象的某个关联属性。如果这个属性之前没有被访问过，这时就会启动一个关联查询，通过当前AR对象的主键连接相关的表，来取得关联对象的值，然后将这些数据保存在对象的属性中。这种方式叫做“延迟加载”，也就是只有等到访问到某个属性时，才会真正到数据库中把这些关联的数据取出来。下面的例子描述了延迟加载的过程： 1234// retrieve the post whose ID is 10$post=Post::model()-&gt;findByPk(10);// retrieve the post&#x27;s author: a relational query will be performed here$author=$post-&gt;author; 在不同的关联情况下，如果没有查询到结果，其返回的值也不同：BELONGS_TO 和 HAS_ONE 关联，无结果时返回null; HAS_MANY 和 MANY_MANY, 无结果时返回空数组。延迟加载方法使用非常方便，但在某些情况下并不高效。例如，若我们要取得N个post的作者信息，使用延迟方法将执行N次连接查询。此时我们应当使用所谓的急切加载方法。急切加载方法检索主要的 AR 实例及其相关的 AR 实例. 这通过使用 with() 方法加上 find 或 findAll 方法完成。例如，$posts=Post::model()-&gt;with(&#39;author&#39;)-&gt;findAll();上面的代码将返回一个由 Post 实例组成的数组. 不同于延迟加载方法，每个Post 实例中的author 属性在我们访问此属性之前已经被关联的User 实例填充。不是为每个post 执行一个连接查询, 急切加载方法在一个单独的连接查询中取出所有的 post 以及它们的author!我们可以在with()方法中指定多个关联名字。例如, 下面的代码将取回 posts 以及它们的作者和分类: $posts=Post::model()-&gt;with(&#39;author&#39;,&#39;categories&#39;)-&gt;findAll();我们也可以使用嵌套的急切加载。不使用一个关联名字列表, 我们将关联名字以分层的方式传递到 with() 方法, 如下, 12345$posts = Post::model()-&gt;with( &#x27;author.profile&#x27;, &#x27;author.posts&#x27;, &#x27;categories&#x27;)-&gt;findAll(); 上面的代码将取回所有的 posts 以及它们的作者和分类。它也将取出每个作者的profile和 posts.急切加载也可以通过指定 CDbCriteria::with 属性被执行, 如下: 1234567$criteria = new CDbCriteria;$criteria-&gt;with = [ &#x27;author.profile&#x27;, &#x27;author.posts&#x27;, &#x27;categories&#x27;,];$posts = Post::model()-&gt;findAll($criteria); 或 1$posts = Post::model()-&gt;findAll([&#x27;with&#x27; =&gt; [&#x27;author.profile&#x27;, &#x27;author.posts&#x27;, &#x27;categories&#x27;]]; 关联查询选项之前我们提到额外的参数可以被指定在关联声明中。这些选项，指定为 name-value 对，被用来定制关联查询。它们被概述如下： select: 为关联 AR 类查询的字段列表。默认是 ‘*’, 意味着所有字段。查询的字段名字可用别名表达式来消除歧义（例如：COUNT(??.name) AS nameCount）。condition: WHERE 子语句。默认为空。注意, 列要使用别名引用（例如：??.id&#x3D;10）。params: 被绑定到 SQL 语句的参数. 应当为一个由 name-value 对组成的数组（）。on: ON 子语句. 这里指定的条件将使用 and 操作符被追加到连接条件中。此选项中的字段名应被消除歧义。此选项不适用于 MANY_MANY 关联。order: ORDER BY 子语句。默认为空。注意, 列要使用别名引用（例如：??.age DESC）。with: 应当和此对象一同载入的子关联对象列表. 注意, 不恰当的使用可能会形成一个无穷的关联循环。joinType: 此关联的连接类型。默认是 LEFT OUTER JOIN。aliasToken：列前缀占位符。默认是“??.”。alias: 关联的数据表的别名。默认是 null, 意味着表的别名和关联的名字相同。together: 是否关联的数据表被强制与主表和其他表连接。此选项只对于HAS_MANY 和 MANY_MANY 关联有意义。若此选项被设置为 false, ……(此处原文出错!).默认为空。此选项中的字段名以被消除歧义。having: HAVING 子语句。默认是空。注意, 列要使用别名引用。index: 返回的数组索引类型。确定返回的数组是关键字索引数组还是数字索引数组。不设置此选项, 将使用数字索引数组。此选项只对于HAS_MANY 和 MANY_MANY 有意义 此外, 下面的选项在延迟加载中对特定关联是可用的: group: GROUP BY子句。默认为空。注意, 列要使用别名引用(例如：??.age)。 本选项仅应用于HAS_MANY 和 MANY_MANY 关联。having: HAVING子句。默认为空。注意, 列要使用别名引用(例如：??.age)。本选项仅应用于HAS_MANY 和 MANY_MANY 关联。limit: 限制查询的行数。本选项不能用于BELONGS_TO关联。offset: 偏移。本选项不能用于BELONGS_TO关联。 下面我们改变在 User 中的 posts 关联声明,通过使用上面的一些选项: 1234567891011121314&lt;?phpclass User extends CActiveRecord&#123; public function relations() &#123; return [ &#x27;posts&#x27; =&gt; [self::HAS_MANY, &#x27;Post&#x27;, &#x27;author_id&#x27;, &#x27;order&#x27; =&gt; &#x27;posts.create_time DESC&#x27;, &#x27;with&#x27; =&gt; &#x27;categories&#x27;, ], &#x27;profile&#x27; =&gt; [self::HAS_ONE, &#x27;Profile&#x27;, &#x27;owner_id&#x27;], ]; &#125;&#125; 现在若我们访问 $author-&gt;posts, 我们将得到用户的根据发表时间降序排列的 posts. 每个 post 实例也载入了它的分类。 为字段名消除歧义当一个字段的名字出现在被连接在一起的两个或更多表中，需要消除歧义(disambiguated)。可以通过使用表的别名作为字段名的前缀实现。在关联AR查询中，主表的别名确定为 t，而一个关联表的别名和相应的关联的名字相同(默认情况下)。 例如，在下面的语句中，Post 的别名是 t ，而 Comment 的别名是 comments:$posts=Post::model()-&gt;with(&#39;comments&#39;)-&gt;findAll();现在假设 Post 和 Comment 都有一个字段 create_time , 我们希望取出 posts 及它们的 comments,排序方式是先根据 posts 的创建时间,然后根据 comment 的创建时间。我们需要消除create_time 字段的歧义，如下: 12345$posts = Post::model() -&gt;with(&#x27;comments&#x27;) -&gt;findAll([ &#x27;order&#x27; =&gt; &#x27;t.create_time, comments.create_time&#x27;;, ]); 默认情况下,Yii 自动为每个关联表产生一个表别名，我们必须使用此前缀 ??. 来指向这个自动产生的别名。 主表的别名是表自身的名字。 动态关联查询选项我们使用 with()和 with 均可使用动态关联查询选项。 动态选项将覆盖在 relations() 方法中指定的已存在的选项。例如，使用上面的 User 模型， 若我们想要使用急切加载方法以升序来取出属于一个作者的 posts(关联中的order 选项指定为降序)， 我们可以这样做: 12345678User::model()-&gt;with( [ &#x27;posts&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;posts.create_time ASC&#x27;, ], &#x27;profile&#x27;, ])-&gt;findAll(); 动态查询选项也可以在使用延迟加载方法时使用以执行关联查询。 要这样做，我们应当调用一个方法，它的名字和关联的名字相同，并传递动态查询选项 作为此方法的参数。例如，下面的代码返回一个用户的 status 为 1 的 posts : 12$user = User::model()-&gt;findByPk(1);$posts = $user-&gt;posts([&#x27;condition&#x27; =&gt; &#x27;status=1&#x27;]); 关联查询的性能如上所述，急切加载方法主要用于当我们需要访问许多关联对象时。 通过连接所有所需的表它产生一个大而复杂的 SQL 语句。一个大的 SQL 语句在许多情况下是首选的。然而在一些情况下它并不高效。考虑一个例子，若我们需要找出最新的文章以及它们的评论。假设每个文章有 10 条评论，使用一个大的 SQL 语句，我们将取回很多多余的 post数据， 因为每个post 将被它的每条评论反复使用。现在让我们尝试另外的方法：我们首先查询最新的文章，然后查询它们的评论。用新的方法，我们需要执行执行两条 SQL 语句。有点是在查询结果中没有多余的数据。因此哪种方法更加高效？没有绝对的答案。执行一条大的 SQL 语句也许更加高效，因为它需要更少的花销来解析和执行 SQL 语句。另一方面，使用单条 SQL语句，我们得到更多冗余的数据，因此需要更多时间来阅读和处理它们。因为这个原因，Yii 提供了 together 查询选项以便我们在需要时选择两种方法之一。默认下， Yii 使用第一种方式，即产生一个单独的 SQL语句来执行急切加载。我们可以在关联声明中设置 together 选项为 false 以便一些表被连接在单独的 SQL语句中。例如，为了使用第二种方法来查询最新的文章及它们的评论，我们可以在 Post 类中声明 comments 关联如下, 123456function relations()&#123; return [ &#x27;comments&#x27; =&gt; [self::HAS_MANY, &#x27;Comment&#x27;, &#x27;post_id&#x27;, &#x27;together&#x27; =&gt; false], ];&#125; 当我们执行急切加载时，我们也可以动态地设置此选项: 1$posts = Post::model()-&gt;with([&#x27;comments&#x27; =&gt; [&#x27;together&#x27; =&gt; false]])-&gt;findAll(); 统计查询除了上面描述的关联查询，Yii 也支持所谓的统计查询(或聚合查询)。 它指的是检索关联对象的聚合信息，例如每个 post的评论的数量，每个产品的平均等级等。统计查询只被 HAS_MANY(例如，一个 post 有很多评论) 或 MANY_MANY (例如，一个 post 属于很多分类和一个 category 有很多 post) 关联对象执行。执行统计查询非常类似于之前描述的关联查询。我们首先需要在 CActiveRecord 的 relations() 方法中声明统计查询。 12345678910class Post extends CActiveRecord&#123; public function relations() &#123; return [ &#x27;commentCount&#x27; =&gt; [self::STAT, &#x27;Comment&#x27;, &#x27;post_id&#x27;], &#x27;categoryCount&#x27; =&gt; [self::STAT, &#x27;Category&#x27;, &#x27;post_category(post_id,category_id)&#x27;], ]; &#125;&#125; 在上面，我们声明了两个统计查询：commentCount 计算属于一个 post 的评论的数量，categoryCount 计算一个 post所属分类的数量。注意 Post 和 Comment 之间的关联类型是 HAS_MANY， 而 Post 和 Category 之间的关联类型是 MANY_MANY (使用连接表 PostCategory)。如我们所看到的，声明非常类似于之间小节中的关联。唯一的不同是这里的关联类型是STAT。有了上面的声明，我们可以检索使用表达式 $post-&gt;commentCount 检索一个 post 的评论的数量。当我们首次访问此属性，一个 SQL 语句将被隐含地执行并检索 对应的结果。我们已经知道，这是所谓的 lazy loading方法。若我们需要得到多个post 的评论数目，我们也可以使用 eager loading 方法:$posts=Post::model()-&gt;with(&#39;commentCount&#39;, &#39;categoryCount&#39;)-&gt;findAll();上面的语句将执行三个 SQL 语句以取回所有的 post 及它们的评论数目和分类数目。使用延迟加载方法， 若有 N 个 post ,我们使用 2N+1 条 SQL 查询完成。默认情况下，一个统计查询将计算 COUNT 表达式(and thus the comment count and category countin the above example).当我们在 relations()中声明它时，通过 指定额外的选项，可以定制它。可用的选项简介如下。select: 统计表达式。默认是 COUNT()，意味着子对象的个数。defaultValue: 没有接收一个统计查询结果时被赋予的值。例如，若一个 post 没有任何评论，它的 commentCount 将接收此值。此选项的默认值是 0。condition: WHERE 子语句。默认是空。params: 被绑定到产生的SQL 语句中的参数。它应当是一个 name-value 对组成的数组。order: ORDER BY 子语句。默认是空。group: GROUP BY 子语句。默认是空。having: HAVING 子语句。默认是空。 关联查询命名空间关联查询也可以和 命名空间一起执行。有两种形式。第一种形式，命名空间被应用到主模型。第二种形式，命名空间被应用到关联模型。下面的代码展示了如何应用命名空间到主模型。$posts=Post::model()-&gt;published()-&gt;recently()-&gt;with(&#39;comments&#39;)-&gt;findAll();这非常类似于非关联的查询。唯一的不同是我们在命名空间后使用了 with() 调用。 此查询应当返回最近发布的 post和它们的评论。下面的代码展示了如何应用命名空间到关联模型。$posts=Post::model()-&gt;with(&#39;comments:recently:approved&#39;)-&gt;findAll();上面的查询将返回所有的 post 及它们审核后的评论。注意 comments 指的是关联名字，而 recently 和 approved 指的是 在 Comment 模型类中声明的命名空间。关联名字和命名空间应当由冒号分隔。命名空间也可以在 CActiveRecord::relations() 中声明的关联规则的 with 选项中指定。在下面的例子中， 若我们访问 $user-&gt;posts，它将返回此post 的所有审核后的评论。 123456789class User extends CActiveRecord&#123; public function relations() &#123; return [ &#x27;posts&#x27; =&gt; [self::HAS_MANY, &#x27;Post&#x27;, &#x27;author_id&#x27;, &#x27;with&#x27; =&gt; &#x27;comments:approved&#x27;], ]; &#125;&#125; 注意: 应用到关联模型的命名空间必须在 CActiveRecord::scopes 中指定。结果，它们不能被参数化。","tags":[{"name":"Yii","slug":"Yii","permalink":"https://blog.gowhich.com/tags/Yii/"}]},{"title":"PHP下载远程图片的方法","date":"2025-06-09T03:56:59.000Z","path":"2025/06/09/PHP下载远程图片的方法.html","text":"获取远程文件大小及信息的函数12345678910111213141516171819202122&lt;?phpfunction getFileSize($url)&#123; $url = parse_url($url); if ($fp = @fsockopen($url[’host’], empty($url[’port’]) ? 80 : $url[’port’], $error)) &#123; fputs($fp, &quot;GET &quot; . (empty($url[’path’]) ? ’ / ’ : $url[’path’]) . &quot; HTTP/1.1\\r\\n&quot;); fputs($fp, &quot;Host:$url[host]\\r\\n\\r\\n&quot;); while (!feof($fp)) &#123; $tmp = fgets($fp); if (trim($tmp) == ’’) &#123; break; &#125; else if (preg_match(’ / Content - Length:( . * ) / si’, $tmp, $arr)) &#123; return trim($arr[1]); &#125; &#125; return null; &#125; else &#123; return null; &#125;&#125;echo getFileSize(&quot;http://www.dianpub.com/download/xml.rar&quot;); 图片12345678910111213141516171819202122232425262728293031&lt;?php//记录程序开始的时间$BeginTime = getmicrotime();function GrabImage($url, $filename = &quot;&quot;)&#123; if (&quot;&quot; == $url): return false; if (&quot;&quot; == $filename) &#123; $ext = strrchr($url, &quot;.&quot;); if (&quot;.gif&quot; != $ext &amp;&amp; &quot;.jpg&quot; != $ext): return false; $filename = date(&quot;dMYHis&quot;) . $ext; &#125; ob_start(); readfile($url); $img = ob_get_contents(); ob_end_clean(); $size = strlen($img); $fp2 = @fopen($filename, &quot;a&quot;); fwrite($fp2, $img); fclose($fp2); return $filename;&#125;$img = GrabImage(&quot;http://www.dianpub.com/images/_1978837_detector_ap100.jpg&quot;, &quot;&quot;);if ($img): echo &#x27;&lt;pre&gt;&lt;img src=&quot;&#x27; . $img . &#x27;&quot;&gt;&lt;/pre&gt;&#x27;;else:echo &quot;false&quot;;//记录程序运行结束的时间$EndTime = getmicrotime();//返回运行时间exit($EndTime - $BeginTime); 全文下载图片12345678910111213141516171819202122232425262728&lt;?phpif (!empty($saveremoteimg)) &#123; $body = stripslashes($body); $img_array = []; preg_match_all(&quot;/(src|SRC)=[\\&quot;|&#x27;| ]&#123;0,&#125;(http:\\/\\/(.*)\\.(gif|jpg|jpeg|bmp|png))/isU&quot;, $body, $img_array); $img_array = array_unique($img_array[2]); set_time_limit(0); $imgUrl = $img_dir . &quot;/&quot; . strftime(&quot;%Y%m%d&quot;, time()); $imgPath = $base_dir . $imgUrl; $milliSecond = strftime(&quot;%H%M%S&quot;, time()); if (!is_dir($imgPath)) &#123; @mkdir($imgPath, 0777); &#125; foreach ($img_array as $key =&gt; $value) &#123; $value = trim($value); $get_file = @file_get_contents($value); $rndFileName = $imgPath . &quot;/&quot; . $milliSecond . $key . &quot;.&quot; . substr($value, -3, 3); $fileurl = $imgUrl . &quot;/&quot; . $milliSecond . $key . &quot;.&quot; . substr($value, -3, 3); if ($get_file) &#123; $fp = @fopen($rndFileName, &quot;w&quot;); @fwrite($fp, $get_file); @fclose($fp); &#125; $body = ereg_replace($value, $fileurl, $body); &#125; $body = addslashes($body);&#125; PHP远程文件下载类（支持断点续传）1）功能:支持断点续传的下载,能计算传输率,能控制传输率 简易使用方法: 12345&lt;?php$object = new httpdownload();$object-&gt;set_byfile($file);//服务器文件名,包括路径$object-&gt;filename = $filename;//下载另存为的文件名$object-&gt;download(); 类文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288&lt;?phpclass httpdownload&#123; public $data = null; public $data_len = 0; public $data_mod = 0; public $data_type = 0; public $data_section = 0; //section download public $sentSize = 0; public $handler = [&#x27;auth&#x27; =&gt; null]; public $use_resume = true; public $use_autoexit = false; public $use_auth = false; public $filename = null; public $mime = null; public $bufsize = 2048; public $seek_start = 0; public $seek_end = -1; public $totalsizeref = 0; public $bandwidth = 0; public $speed = 0; public function initialize() &#123; global $HTTP_SERVER_VARS; if ($this-&gt;use_auth) &#123; if (!$this-&gt;_auth()) &#123; header(&#x27;WWW-Authenticate: Basic realm=&quot;Please enter your username and password&quot;&#x27;); header(&#x27;HTTP/1.0 401 Unauthorized&#x27;); header(&#x27;status: 401 Unauthorized&#x27;); if ($this-&gt;use_autoexit) &#123; exit(); &#125; return false; &#125; &#125; if (null == $this-&gt;mime) &#123; $this-&gt;mime = &quot;application/octet-stream&quot;; &#125; //default mime if (isset($_SERVER[&#x27;HTTP_RANGE&#x27;]) || isset($HTTP_SERVER_VARS[&#x27;HTTP_RANGE&#x27;])) &#123; if (isset($HTTP_SERVER_VARS[&#x27;HTTP_RANGE&#x27;])) &#123; $seek_range = substr($HTTP_SERVER_VARS[&#x27;HTTP_RANGE&#x27;], strlen(&#x27;bytes=&#x27;)); &#125; else &#123; $seek_range = substr($_SERVER[&#x27;HTTP_RANGE&#x27;], strlen(&#x27;bytes=&#x27;)); &#125; $range = explode(&#x27;-&#x27;, $seek_range); if ($range[0] &gt; 0) &#123; $this-&gt;seek_start = intval($range[0]); &#125; if ($range[1] &gt; 0) &#123; $this-&gt;seek_end = intval($range[1]); &#125; else &#123; $this-&gt;seek_end = -1; &#125; if (!$this-&gt;use_resume) &#123; $this-&gt;seek_start = 0; //header(&quot;HTTP/1.0 404 Bad Request&quot;); //header(&quot;Status: 400 Bad Request&quot;); //exit; //return false; &#125; else &#123; $this-&gt;data_section = 1; &#125; &#125; else &#123; $this-&gt;seek_start = 0; $this-&gt;seek_end = -1; &#125; $this-&gt;sentSize = 0; return true; &#125; public function header($size, $seek_start = null, $seek_end = null) &#123; header(&#x27;Content-type: &#x27; . $this-&gt;mime); header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . $this-&gt;filename . &#x27;&quot;&#x27;); header(&#x27;Last-Modified: &#x27; . date(&#x27;D, d M Y H:i:s \\G\\M\\T&#x27;, $this-&gt;data_mod)); if ($this-&gt;data_section &amp;&amp; $this-&gt;use_resume) &#123; header(&quot;HTTP/1.0 206 Partial Content&quot;); header(&quot;Status: 206 Partial Content&quot;); header(&#x27;Accept-Ranges: bytes&#x27;); header(&quot;Content-Range: bytes $seek_start-$seek_end/$size&quot;); header(&quot;Content-Length: &quot; . ($seek_end - $seek_start + 1)); &#125; else &#123; header(&quot;Content-Length: $size&quot;); &#125; &#125; public function download_ex($size) &#123; if (!$this-&gt;initialize()) &#123; return false; &#125; ignore_user_abort(true); //Use seek end here if ($this-&gt;seek_start &gt; ($size - 1)) &#123; $this-&gt;seek_start = 0; &#125; if ($this-&gt;seek_end &lt;= 0) &#123; $this-&gt;seek_end = $size - 1; &#125; $this-&gt;header($size, $seek, $this-&gt;seek_end); $this-&gt;data_mod = time(); return true; &#125; public function download() &#123; if (!$this-&gt;initialize()) &#123; return false; &#125; try &#123; error_log(&quot;begin download\\n&quot;, 3, &quot;/usr/local/www/apache22/LOGS/apache22_php.err&quot;); $seek = $this-&gt;seek_start; $speed = $this-&gt;speed; $bufsize = $this-&gt;bufsize; $packet = 1; //do some clean up @ob_end_clean(); $old_status = ignore_user_abort(true); @set_time_limit(0); $this-&gt;bandwidth = 0; $size = $this-&gt;data_len; if (0 == $this-&gt;data_type) //download from a file &#123; &#123; $size = filesize($this-&gt;data); &#125; if ($seek &gt; ($size - 1)) &#123; $seek = 0; &#125; if (null == $this-&gt;filename) &#123; $this-&gt;filename = basename($this-&gt;data); &#125; $res = fopen($this-&gt;data, &#x27;rb&#x27;); if ($seek) &#123; fseek($res, $seek); &#125; if ($this-&gt;seek_end &lt; $seek) &#123; $this-&gt;seek_end = $size - 1; &#125; $this-&gt;header($size, $seek, $this-&gt;seek_end); //always use the last seek $size = $this-&gt;seek_end - $seek + 1; while (!(connection_aborted() || connection_status() == 1) &amp;&amp; $size &gt; 0) &#123; if ($size &lt; $bufsize) &#123; echo fread($res, $size); $this-&gt;bandwidth += $size; $this-&gt;sentSize += $size; &#125; else &#123; echo fread($res, $bufsize); $this-&gt;bandwidth += $bufsize; $this-&gt;sentSize += $bufsize; &#125; $size -= $bufsize; flush(); if ($speed &gt; 0 &amp;&amp; ($this-&gt;bandwidth &gt; $speed * $packet * 1024)) &#123; sleep(1); $packet++; &#125; &#125; fclose($res); if (1 == $this-&gt;data_type) //download from a string &#123; if ($seek &gt; ($size - 1)) &#123; $seek = 0; &#125; if ($this-&gt;seek_end &lt; $seek) &#123; $this-&gt;seek_end = $this-&gt;data_len - 1; &#125; $this-&gt;data = substr($this-&gt;data, $seek, $this-&gt;seek_end - $seek + 1); if (null == $this-&gt;filename) &#123; $this-&gt;filename = time(); &#125; $size = strlen($this-&gt;data); $this-&gt;header($this-&gt;data_len, $seek, $this-&gt;seek_end); while (!connection_aborted() &amp;&amp; $size &gt; 0) &#123; if ($size &lt; $bufsize) &#123; $this-&gt;bandwidth += $size; $this-&gt;sentSize += $size; &#125; else &#123; $this-&gt;bandwidth += $bufsize; $this-&gt;sentSize += $bufsize; &#125; echo substr($this-&gt;data, 0, $bufsize); $this-&gt;data = substr($this-&gt;data, $bufsize); $size -= $bufsize; flush(); if ($speed &gt; 0 &amp;&amp; ($this-&gt;bandwidth &gt; $speed * $packet * 1024)) &#123; sleep(1); $packet++; &#125; &#125; &#125; else if (2 == $this-&gt;data_type) &#123; //just send a redirect header header(&#x27;location: &#x27; . $this-&gt;data); &#125; if ($this-&gt;totalsizeref == $this-&gt;sentSize) &#123; error_log(&quot;end download\\n&quot;, 3, &quot;/usr/local/www/apache22/LOGS/apache22_php.err&quot;); &#125; else &#123; error_log(&quot;download is canceled\\n&quot;, 3, &quot;/usr/local/www/apache22/LOGS/apache22_php.err&quot;); &#125; if ($this-&gt;use_autoexit) &#123; exit(); &#125; //restore old status ignore_user_abort($old_status); set_time_limit(ini_get(&quot;max_execution_time&quot;)); &#125; catch (Exception $e) &#123; error_log(&quot;cancel download\\n&quot; . $e, 3, &quot;/usr/local/www/apache22/LOGS/apache22_php.err&quot;); &#125; return true; &#125; public function set_byfile($dir) &#123; if (is_readable($dir) &amp;&amp; is_file($dir)) &#123; $this-&gt;data_len = 0; $this-&gt;data = $dir; $this-&gt;data_type = 0; $this-&gt;data_mod = filemtime($dir); $this-&gt;totalsizeref = filesize($dir); return true; &#125; else &#123; return false; &#125; &#125; public function set_bydata($data) &#123; if (&#x27;&#x27; == $data) &#123; return false; &#125; $this-&gt;data = $data; $this-&gt;data_len = strlen($data); $this-&gt;data_type = 1; $this-&gt;data_mod = time(); return true; &#125; public function set_byurl($data) &#123; $this-&gt;data = $data; $this-&gt;data_len = 0; $this-&gt;data_type = 2; return true; &#125; public function set_lastmodtime($time) &#123; $time = intval($time); if ($time &lt;= 0) &#123; $time = time(); &#125; $this-&gt;data_mod = $time; &#125; public function _auth() &#123; if (!isset($_SERVER[&#x27;PHP_AUTH_USER&#x27;])) &#123; return false; &#125; if (isset($this-&gt;handler[&#x27;auth&#x27;]) &amp;&amp; function_exists($this-&gt;handler[&#x27;auth&#x27;])) &#123; return $this-&gt;handler[&#x27;auth&#x27;](&#x27;auth&#x27;, $_SERVER[&#x27;PHP_AUTH_USER&#x27;], $_SERVER[&#x27;PHP_AUTH_PW&#x27;]); &#125; else &#123; return true; &#125; //you must use a handler &#125;&#125; PHP使用GD库下载远程图片123456789101112&lt;?php$imgname = &quot;http://imgdujia.kuxun.cn/newpic/929/812929/4.jpg&quot;;$src_im = imagecreatefromjpeg($imgname);$srcW = ImageSX($src_im); //获得图像的宽$srcH = ImageSY($src_im); //获得图像的高$dst_im = ImageCreateTrueColor($srcW, $srcH); //创建新的图像对象imagecopy($dst_im, $src_im, 0, 0, 0, 0, $srcW, $srcH);imagejpeg($dst_im, &quot;newpic.jpg&quot;); //创建缩略图文件echo &quot;&lt;img src=&quot;newpic . jpg&quot; mce_src=&quot;newpic . jpg&quot;&gt;&lt;/img&gt;&quot;; 123456789&lt;?phpheader(&quot;Content-type: image/png&quot;);$im = imagecreatefromjpeg(&quot;http://postimg.mop.com/200602/02/74/122374/200602022335325121.JPG&quot;);$white = imagecolorallocate($im, 0xF9, 0xD7, 0xCD);imagefill($im, 0, 0, $white);$text_color = imagecolorallocate($im, 233, 14, 91);imagestring($im, 1, 5, 5, &quot;A Simple Text String&quot;, $text_color);imagepng($im);imagedestroy($im);","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"NGINX如何开启和配置gzip","date":"2025-06-09T03:52:26.000Z","path":"2025/06/09/NGINX如何开启和配置gzip.html","text":"gzip是GNU zip的缩写，它是一个GNU自由软件的文件压缩程序，可以极大的加速网站.有时压缩比率高到80%,近来测试了一下,最少都有40%以上,还是相当不错的。大道至简，知易行难，悟者大成。 gzip 决定是否开启gzip模块example:gzip on; gzip_buffers 设置gzip申请内存的大小,其作用是按块大小的倍数申请内存空间param2:int(k) 后面单位是kexample: gzip_buffers 4 8k; gzip_comp_level 设置gzip压缩等级，等级越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大param:1-9example:gzip_com_level 1; gzip_min_length 当返回内容大于此值时才会使用gzip进行压缩,以K为单位,当值为0时，所有页面都进行压缩param:intexample:gzip_min_length 1000; gzip_http_version 用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项,目前此项基本可以忽略param: 1.0|1.1example:gzip_http_version 1.0 gzip_proxied Nginx做为反向代理的时候启用，param:off|expired|no-cache|no-sotre|private|no_last_modified|no_etag|auth|any]expample:gzip_proxied no-cache;off – 关闭所有的代理结果数据压缩expired – 启用压缩，如果header中包含”Expires”头信息no-cache – 启用压缩，如果header中包含”Cache-Control:no-cache”头信息no-store – 启用压缩，如果header中包含”Cache-Control:no-store”头信息private – 启用压缩，如果header中包含”Cache-Control:private”头信息no_last_modified – 启用压缩，如果header中包含”Last_Modified”头信息no_etag – 启用压缩，如果header中包含“ETag”头信息auth – 启用压缩，如果header中包含“Authorization”头信息any – 无条件压缩所有结果数据 gzip_types 设置需要压缩的MIME类型,非设置值不进行压缩param:text&#x2F;html|application&#x2F;x-javascript|text&#x2F;css|application&#x2F;xmlexample:gzip_types text/html; Demo 1234gzip on;gzip_min_length 1000;gzip_buffers 4 8k;gzip_types text/html application/x-javascript text/css application/xml;","tags":[{"name":"NGINX","slug":"NGINX","permalink":"https://blog.gowhich.com/tags/NGINX/"}]},{"title":"iOS代码段分享","date":"2025-06-09T03:49:52.000Z","path":"2025/06/09/iOS代码段分享.html","text":"收集的一些实用的ios代码段 去除顶部状态栏后的分辨率1CGRect frame = [[UIScreen mainScreen] applicationFrame]; 获取当前SIM卡的手机号码（私有API）首先引入官方的CoreTelephony库，然后使用如下函数返回用户手机号码即可： 12extern NSString *CTSettingCopyMyPhoneNumber();NSString *telNum = CTSettingCopyMyPhoneNumber(); 获取当前运营商名称及相关描述信息首先引入官方的CoreTelephony库，然后添加相应的头文件： 12#import &lt;CoreTelephony/CTCarrier.h&gt;#import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt; 接着使用CTTelephonyNetworkInfo与CTCarrier这两个类获取运营商相关信息，并将其保存到一个CTCarrier对象中： 1234CTTelephonyNetworkInfo *info = [[CTTelephonyNetworkInfo alloc] init];CTCarrier *carrier = info.subscriberCellularProvider;NSLog(@”description:%@”,[carrier description]);NSLog(@”carrier:%@”, carrier.carrierName); 输出为： 123456789CTCarrier (0x1a0200) &#123;Carrier name: [中国联通]Mobile Country Code: [460]Mobile Network Code:[01]ISO Country Code:[cn]Allows VOIP? [YES]&#125;carrier:中国联通","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS的controller的跳转 pushViewController/presentModalViewController/addSubView","date":"2025-06-09T03:27:58.000Z","path":"2025/06/09/iOS的controller的跳转-pushViewController-presentModalViewController-addSubView.html","text":"用UINavigationController的时候用pushViewController:animated（在调用的函数里面添加如下类似代码） 12teleplayViewController *teleplay = [[teleplayViewController alloc] init];[self.navigationController pushViewController:teleplay animated:YES]; 其他时候用presentModalViewController:animated（在调用的函数里面添加如下类似代码） 1[self presentModalViewController:controller animated:YES]; 同时不要忘记在另一个视图中调用函数dismissViewControllerAnimated（代码类似如下） 1[self dismissViewControllerAnimated:YES completion:NULL]; 切换视图一般用不到addSubview UINavigationController是导航控制器，如果pushViewController的话，会跳转到下一个ViewController，点返回会回到现在这个ViewController； 如果是addSubview的话，其实还是对当前的ViewController操作，只是在当前视图上面又“盖”住了一层视图，其实原来的画面在下面呢，看不到而已。（当然，也可以用insertSubView atIndex那个方法设置放置的层次)","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS搜索栏UISearchBarDelegate委托常用方法","date":"2025-06-06T10:07:30.000Z","path":"2025/06/06/iOS搜索栏UISearchBarDelegate委托常用方法.html","text":"请看下面的实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//点击键盘上的search按钮时调用- (void) searchBarSearchButtonClicked:(UISearchBar *)searchBar&#123; NSString *searchTerm = searchBar.text; [self handleSearchForTerm:searchTerm];&#125;//输入文本实时更新时调用- (void) searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText&#123; if (searchText.length == 0) &#123; [self resetSearch]; [table reloadData]; return; &#125; [self handleSearchForTerm:searchText];&#125;//cancel按钮点击时调用- (void) searchBarCancelButtonClicked:(UISearchBar *)searchBar&#123; isSearching = NO; search.text = @&quot;&quot;; [self resetSearch]; [table reloadData]; [searchBar resignFirstResponder];&#125;//点击搜索框时调用- (void) searchBarTextDidBeginEditing:(UISearchBar *)searchBar&#123; isSearching = YES; [table reloadData];&#125; UISearchBar上按钮的默认文字为Cancel，如果想改为其他文字请调用以下代码 1234567for(id cc in [searchtext subviews])&#123; if([cc isKindOfClass:[UIButton class]])&#123; UIButton *btn = (UIButton *)cc; [btn setTitle:@&quot;取消&quot; forState:UIControlStateNormal]; &#125; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS uitableview uitableviewcell简单举例","date":"2025-06-06T10:04:09.000Z","path":"2025/06/06/iOS-uitableview-uitableviewcell简单举例.html","text":"我学过网页制作，多多少少的能理解一下table这个元素，关于ios的uitableview应该也有这些类似的东西，觉得在uitableview中，都能够找与table对应的部分，看下面代码： MasterViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142//// MasterViewController.m// vlinkagePerson//// Created by david on 13-4-14.// Copyright (c) 2013年 david. All rights reserved.//#import &quot;MasterViewController.h&quot;@interface MasterViewController ()@end@implementation MasterViewController@synthesize navbar,navItem,searchButton,attentionButton,personTable,keys,objects,content;- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; // Custom initialization &#125; return self;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view from its nib. self.keys = [NSArray arrayWithObjects:@&quot;mainTitleKey&quot;,@&quot;secondaryTitleKey&quot;,@&quot;imageKey&quot;,nil]; self.objects = [NSArray arrayWithObjects:@&quot;How&quot;,@&quot;Are&quot;,@&quot;You&quot;,nil]; //表格添加内容 self.content = [[NSDictionary alloc] initWithObjects:objects forKeys:keys]; //创建一个导航栏 self.navbar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, 320, 44)]; //创建一个导航栏集合 self.navItem = [[UINavigationItem alloc] initWithTitle:@&quot;艺人列表&quot;]; //在这个集合Item中添加标题，按钮 //style:设置按钮的风格，一共有三种选择 //action：@selector:设置按钮的点击事件 //创建一个左边按钮 self.searchButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;搜索&quot; style:UIBarButtonItemStylePlain target:self action:@selector(searchEvent)]; //创建一个右边按钮 self.attentionButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;我的关注&quot; style:UIBarButtonItemStylePlain target:self action:@selector(attentionList)]; //把导航栏集合添加到导航栏中，设置动画关闭 [self.navbar pushNavigationItem:self.navItem animated:YES]; //把左右两个按钮添加到导航栏集合中去 [self.navItem setLeftBarButtonItem:self.searchButton]; [self.navItem setRightBarButtonItem:self.attentionButton]; //添加UITableView self.personTable = [[UITableView alloc] initWithFrame:CGRectMake(0, 44, 320, 460) style:UITableViewStyleGrouped]; [self.personTable setDataSource:self]; [self.personTable setDelegate:self]; //将标题栏中的内容全部添加到主视图当中 [self.view addSubview:self.navbar]; //将表格添加到主视图中 [self.view addSubview:self.personTable]; &#125;-(void) searchEvent&#123; &#125;-(void) attentionList&#123; &#125;//Section总数- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; return self.objects;&#125;//每个section显示的标题//设置caption- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; return @&quot;大家好&quot;;&#125;//指定有多少个分区(Section)，默认为1//需要多少个table-(NSInteger) numberOfSectionsInTableView:(UITableView *)tableView&#123; return 4;&#125;//指定每个分区中有多少行，默认为1//table的行数-(NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 2;&#125;//绘制Cell//为每个表格赋值-(UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;MyIdentifier&quot;]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;MyIdentifier&quot;]; cell.selectionStyle = UITableViewCellSelectionStyleNone; &#125; cell.textLabel.text = [self.content objectForKey:@&quot;mainTitleKey&quot;]; cell.detailTextLabel.text = [self.content objectForKey:@&quot;secondaryTitleKey&quot;]; NSString *path = [[NSBundle mainBundle] pathForResource:[self.content objectForKey:@&quot;imageKey&quot;] ofType:@&quot;png&quot;]; UIImage *theImage = [UIImage imageWithContentsOfFile:path]; cell.imageView.image = theImage; return cell;&#125;- (void)didReceiveMemoryWarning&#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS NSDictionary操作简介","date":"2025-06-06T10:01:44.000Z","path":"2025/06/06/iOS-NSDictionary操作简介.html","text":"iOS NSDictionary 操作代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)loopThrough &#123; NSArray * keys=[NSArray arrayWithObjects:@&quot;key1“，@&quot;key2&quot;,@&quot;key3&quot;,nill]; NSArray *objects=[NSArray arrayWithOjbects:@&quot;how&quot;,@&quot;are&quot;,@&quot;you&quot;,nill]; NSDictionary *dic=[NSDictionary dictionaryWithObjects:objects,forKeys:keys]; //loop 1 for(id key in dic) &#123; NSLog(@&quot;key:%@,value:%@&quot;，key,[dic objectForKey:key]); &#125; //loop 2 NSEnumerator *enumerator; id key; enumerator=[dic keyEnumerator]; while((key=[enumerator nextObject])) &#123; NSLog(@&quot;key:%@,value:%@&quot;,key,objectForKey:key]); &#125; &#125;-(void)testNsMutableDictionary &#123; NSMutableDictionary *dic=[NSMutableDictionary dictionaryWithCapacity:30]; //dictionaryWithObjectsAndKeys:[NSMuble numberWithInt:1] @&quot;math1&quot;,[NSMuble numberWithInt:2] @&quot;math2&quot;]; [dic setObject:@&quot;one&quot; forKey:@&quot;dog&quot;]; [dic setObject:@&quot;two&quot; forKey:@&quot;cat&quot;]; [dic setValue:[NSString stringWithFormat:@&quot;three&quot;] forKey:@&quot;pig&quot;]; [dic removeObjectForkey:@&quot;cat&quot;]; [dic removeAllObjects]; NSMutableArray arraylist=[[NSMutableArray alloc] init]; [arrarlist addObject:dic]; [dic release]; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"用Javascript获取页面元素的位置","date":"2025-06-06T06:28:24.000Z","path":"2025/06/06/用Javascript获取页面元素的位置.html","text":"一、网页的大小和浏览器窗口的大小首先，要明确两个基本概念。 一张网页的全部面积，就是它的大小。通常情况下，网页的大小由内容和CSS样式表决定。 浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport（视口）。 很显然，如果网页的内容能够在浏览器窗口中全部显示（也就是不出现滚动条），那么网页的大小和浏览器窗口的大小是相等的。如果不能全部显示，则滚动浏览器窗口，可以显示出网页的各个部分。 二、获取网页的大小网页上的每个元素，都有clientHeight和clientWidth属性。这两个属性指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。 因此，document元素的clientHeight和clientWidth属性，就代表了网页的大小。 12345678910111213function getViewport() &#123; if (document.compatMode == &quot;BackCompat&quot;) &#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125;&#125; 上面的getViewport函数就可以返回浏览器窗口的高和宽。使用的时候，有三个地方需要注意： 1）这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。 2）大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。 3）clientWidth和clientHeight都是只读属性，不能对它们赋值。 三、获取网页大小的另一种方法网页上的每个元素还有scrollHeight和scrollWidth属性，指包含滚动条在内的该元素的视觉面积。 那么，document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。 仿照getViewport()函数，可以写出getPagearea()函数。 12345678910111213function getPagearea() &#123; if (document.compatMode == &quot;BackCompat&quot;) &#123; return &#123; width: document.body.scrollWidth, height: document.body.scrollHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight &#125; &#125;&#125; 但是，这个函数有一个问题。如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相 等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对getPagearea()函数进行改写。 1234567891011121314151617function getPagearea() &#123; if (document.compatMode == &quot;BackCompat&quot;) &#123; return &#123; width: Math.max(document.body.scrollWidth, document.body.clientWidth), height: Math.max(document.body.scrollHeight, document.body.clientHeight) &#125; &#125; else &#123; return &#123; width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight) &#125; &#125;&#125; 四、获取网页元素的绝对位置网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。 首先，每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。 下面两个函数可以用来获取绝对位置的横坐标和纵坐标。 1234567891011121314151617181920212223function getElementLeft(element) &#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;function getElementTop(element) &#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 由于在表格和iframe中，offsetParent对象未必等于父容器，所以上面的函数对于表格和iframe中的元素不适用。 五、获取网页元素的相对位置网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。 有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。 对上一节中的两个函数进行相应的改写： 1234567891011121314151617181920212223242526272829303132333435function getElementViewLeft(element) &#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; if (document.compatMode == &quot;BackCompat&quot;) &#123; var elementScrollLeft = document.body.scrollLeft; &#125; else &#123; var elementScrollLeft = document.documentElement.scrollLeft; &#125; return actualLeft - elementScrollLeft;&#125;function getElementViewTop(element) &#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; if (document.compatMode == &quot;BackCompat&quot;) &#123; var elementScrollTop = document.body.scrollTop; &#125; else &#123; var elementScrollTop = document.documentElement.scrollTop; &#125; return actualTop - elementScrollTop;&#125; scrollTop和scrollLeft属性是可以赋值的，并且会立即自动滚动网页到相应位置，因此可以利用它们改变网页元素的相对位置。另外，element.scrollIntoView()方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。 六、获取元素位置的快速方法除了上面的函数以外，还有一种快速方法，可以立刻获得网页元素的位置。 那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。 所以，网页元素的相对位置就是 12var X= this.getBoundingClientRect().left;var Y =this.getBoundingClientRect().top; 再加上滚动距离，就可以得到绝对位置 12var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft;var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop; 目前，IE、Firefox 3.0+、Opera 9.5+都支持该方法，而Firefox 2.x、Safari、Chrome、Konqueror不支持。 原文网址：http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://blog.gowhich.com/tags/Javascript/"}]},{"title":"Ubuntu Server的bashrc配置","date":"2025-06-06T06:25:16.000Z","path":"2025/06/06/Ubuntu-Server的bashrc配置.html","text":"我的配置，感觉很友好，很有好感，喜欢的拿去用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# ~/.bashrc: executed by bash(1) for non-login shells.# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)# for examples# If not running interactively, don&#x27;t do anything[ -z &quot;$PS1&quot; ] &amp;&amp; return# don&#x27;t put duplicate lines in the history. See bash(1) for more options# ... or force ignoredups and ignorespaceHISTCONTROL=ignoredups:ignorespace# append to the history file, don&#x27;t overwrite itshopt -s histappend# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)HISTSIZE=1000HISTFILESIZE=2000# check the window size after each command and, if necessary,# update the values of LINES and COLUMNS.shopt -s checkwinsize# make less more friendly for non-text input files, see lesspipe(1)[ -x /usr/bin/lesspipe ] &amp;&amp; eval &quot;$(SHELL=/bin/sh lesspipe)&quot;# set variable identifying the chroot you work in (used in the prompt below)if [ -z &quot;$debian_chroot&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot)fi# set a fancy prompt (non-color, unless we know we &quot;want&quot; color)case &quot;$TERM&quot; in xterm-color) color_prompt=yes;;esac# uncomment for a colored prompt, if the terminal has the capability; turned# off by default to not distract the user: the focus in a terminal window# should be on the output of commands, not on the prompt#force_color_prompt=yesif [ -n &quot;$force_color_prompt&quot; ]; then if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then # We have color support; assume it&#x27;s compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fifilocalhost_ip=&#x27;xxx.xxx.xxx.xxx&#x27;if [ &quot;$color_prompt&quot; = yes ]; then PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@$localhost_ip\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ &#x27; #PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@$localhost_ip\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ &#x27;else PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@$localhost_ip:\\w\\$ &#x27; #PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@$localhost_ip\\h:\\w\\$ &#x27;fiunset color_prompt force_color_prompt# If this is an xterm set the title to user@host:dircase &quot;$TERM&quot; inxterm*|rxvt*) PS1=&quot;\\[\\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h: \\w\\a\\]$PS1&quot; ;;*) ;;esac# enable color support of ls and also add handy aliasesif [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot; alias ls=&#x27;ls --color=auto&#x27; #alias dir=&#x27;dir --color=auto&#x27; #alias vdir=&#x27;vdir --color=auto&#x27; alias grep=&#x27;grep --color=auto&#x27; alias fgrep=&#x27;fgrep --color=auto&#x27; alias egrep=&#x27;egrep --color=auto&#x27;fi# some more ls aliasesalias ll=&#x27;ls -alF&#x27;alias la=&#x27;ls -A&#x27;alias l=&#x27;ls -CF&#x27;# Alias definitions.# You may want to put all your additions into a separate file like# ~/.bash_aliases, instead of adding them here directly.# See /usr/share/doc/bash-doc/examples in the bash-doc package.if [ -f ~/.bash_aliases ]; then . ~/.bash_aliasesfi# enable programmable completion features (you don&#x27;t need to enable# this, if it&#x27;s already enabled in /etc/bash.bashrc and /etc/profile# sources /etc/bash.bashrc).#if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then# . /etc/bash_completion#fi","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.gowhich.com/tags/Ubuntu/"}]},{"title":"iOS创建navigationbar","date":"2025-06-06T03:44:14.000Z","path":"2025/06/06/iOS创建navigationbar.html","text":"使用代码创建自己的navigationbar： 环境: 123xcode:Version 4.6.1 (4H512)simulater:iPhone6.1 直接上代码： MasterViewController.h12345678910111213141516171819202122232425262728//// MasterViewController.h// vlinkagePerson//// Created by david on 13-4-14.// Copyright (c) 2013年 david. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface MasterViewController : UIViewController//导航栏@property (strong, nonatomic) UINavigationBar *navbar;//导航栏集合@property (strong, nonatomic) UINavigationItem *navItem;//左边按钮@property (strong, nonatomic) UIBarButtonItem *searchButton;//右边按钮@property (strong, nonatomic) UIBarButtonItem *attentionButton;//自定义方法//搜索操作-(void) searchEvent;-(void) attentionList;@end MasterViewController.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//// MasterViewController.m// vlinkagePerson//// Created by david on 13-4-14.// Copyright (c) 2013年 david. All rights reserved.//#import &quot;MasterViewController.h&quot;@interface MasterViewController ()@end@implementation MasterViewController@synthesize navbar,navItem,searchButton,attentionButton;- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; // Custom initialization &#125; return self;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view from its nib. //创建一个导航栏 self.navbar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, 320, 44)]; //创建一个导航栏集合 self.navItem = [[UINavigationItem alloc] initWithTitle:@&quot;艺人列表&quot;]; //在这个集合Item中添加标题，按钮 //style:设置按钮的风格，一共有三种选择 //action：@selector:设置按钮的点击事件 //创建一个左边按钮 self.searchButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;搜索&quot; style:UIBarButtonItemStylePlain target:self action:@selector(searchEvent)]; //创建一个右边按钮 self.attentionButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;我的关注&quot; style:UIBarButtonItemStylePlain target:self action:@selector(attentionList)]; //把导航栏集合添加到导航栏中，设置动画关闭 [self.navbar pushNavigationItem:self.navItem animated:YES]; //把左右两个按钮添加到导航栏集合中去 [self.navItem setLeftBarButtonItem:self.searchButton]; [self.navItem setRightBarButtonItem:self.attentionButton]; //将标题栏中的内容全部添加到主视图当中 [self.view addSubview:self.navbar]; &#125;-(void) searchEvent&#123; &#125;-(void) attentionList&#123; &#125;- (void)didReceiveMemoryWarning&#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS CGFloat CGPoint CGSize和CGRect","date":"2025-06-06T02:35:44.000Z","path":"2025/06/06/iOS-CGFloat-CGPoint-CGSize和CGRect.html","text":"CGGeometry类定义几何元素的结构和操作几何元素的函数。 1、数据类型：CGFloat: 浮点值的基本类型 CGPoint: 表示一个二维坐标系中的点 CGSize: 表示一个矩形的宽度和高度 CGRect: 表示一个矩形的位置和大小 1234567891011121314151617typedef float CGFloat;// 32-bittypedef double CGFloat;// 64-bitstruct CGPoint &#123; CGFloat x; CGFloat y;&#125;;typedef struct CGPoint CGPoint;struct CGSize &#123; CGFloat width; CGFloat height;&#125;;typedef struct CGSize CGSize;struct CGRect &#123; CGPoint origin; CGSize size;&#125;;typedef struct CGRect CGRect; 注意：CGRect数据结构的高度和宽度可以是负数。例如，一个矩形的原点是[0.0，0.0]和大小是[10.0,10.0]。这个矩形完全等同原点是[10.0，10.0]和大小是[-10.0，-10.0]的矩形。 2、使用值来创建几何元素的方法CGPointMake、CGRectMake、CGSizeMake12345678910111213141516171819202122232425CGPoint CGPointMake ( CGFloat x, CGFloat y );CGSize CGSizeMake ( CGFloat width, CGFloat height );CGRect CGRectMake ( CGFloat x, CGFloat y, CGFloat width, CGFloat height );CGFloat ten=10.0f;CGPoint point = CGPointMake(0.0f, 0.0f);CGSize size = CGSizeMake(10.0f, 10.0f);CGRect rect = CGRectMake(point.x, point.y, size.width, size.height);NSLog(@&quot;ten: %f&quot;, ten);NSLog(@&quot;point: %@&quot;, NSStringFromCGPoint(point));NSLog(@&quot;size: %@&quot;, NSStringFromCGSize(size));NSLog(@&quot;rect: %@&quot;, NSStringFromCGRect(rect));","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"iOS UIScreen（屏幕）UIWindow（画框)UIView(画布)didFinishLaunchingWithOptions的概念","date":"2025-06-06T02:33:47.000Z","path":"2025/06/06/iOS-UIScreen（屏幕）UIWindow（画框-UIView-画布-didFinishLaunchingWithOptions的概念.html","text":"didFinishLaunchingWithOptions 方法：顾名思义。在app开始运行时会调用里面的方法。 12345678910111213141516171819202122232425262728- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; //返回的是带有状态栏的矩形 self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease]; CGRect bound = [[UIScreen mainScreen]bounds]; //返回的是不带有状态栏的Rect NSLog(@&quot;boundwith:%f boundheight:%f&quot;,bound.size.width,bound.size.height); NSLog(@&quot;boundx:%f boundy:%f&quot;,bound.origin.x,bound.origin.y); //2012-08-03 23:21:45.716 DinkMixer[599:c07] boundwith:320.000000 boundheight:480.000000 //2012-08-03 23:21:45.719 DinkMixer[599:c07] boundx:0.000000 boundy:0.000000 CGRect appBound = [[UIScreen mainScreen]applicationFrame]; //返回的是带有状态栏的Rect NSLog(@&quot;appBoundwith:%f boundheight:%f&quot;,appBound.size.width,appBound.size.height); NSLog(@&quot;appBoundx:%f boundy:%f&quot;,appBound.origin.x,appBound.origin.y); //2012-08-03 23:21:45.720 DinkMixer[599:c07] appBoundwith:320.000000 boundheight:460.000000 //2012-08-03 23:21:45.720 DinkMixer[599:c07] appBoundx:0.000000 boundy:20.000000 //很明显状态栏占用了空间20像素 MasterViewController *masterViewController = [[[MasterViewController alloc] initWithNibName:@&quot;MasterViewController&quot; bundle:nil] autorelease];//根据nib文件的名称来创建一个视图控制器 self.navigationController = [[[UINavigationController alloc] initWithRootViewController:masterViewController] autorelease];//创建一个导航控制器，并指定该导航控制器的根视图控制器为上面建立的masterViewController self.window.rootViewController = self.navigationController;//窗体（window）有一个根视图控制器——这个视图控制器负责配置当窗体显示时最先显示的视图。要让你的视图控制器的内容显示在窗体中，需要去设置窗体的根视图控制器为你的视图控制器。 [self.window makeKeyAndVisible];//这行代码会让包含了视图控制器视图的Window窗口显示在屏幕上。 return YES;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"Linux查看文件系统类型","date":"2025-06-06T02:27:33.000Z","path":"2025/06/06/Linux查看文件系统类型.html","text":"1. mount123456789101112131415161718:~$ mount/dev/sda1 on / type ext4 (rw,errors=remount-ro,user_xattr)proc on /proc type proc (rw,noexec,nosuid,nodev)none on /sys type sysfs (rw,noexec,nosuid,nodev)none on /sys/fs/fuse/connections type fusectl (rw)none on /sys/kernel/debug type debugfs (rw)none on /sys/kernel/security type securityfs (rw)none on /dev type devtmpfs (rw,mode=0755)none on /dev/pts type devpts (rw,noexec,nosuid,gid=5,mode=0620)none on /dev/shm type tmpfs (rw,nosuid,nodev)none on /var/run type tmpfs (rw,nosuid,mode=0755)none on /var/lock type tmpfs (rw,noexec,nosuid,nodev)none on /lib/init/rw type tmpfs (rw,nosuid,mode=0755)none on /var/lib/ureadahead/debugfs type debugfs (rw,relatime)none on /proc/fs/vmblock/mountPoint type vmblock (rw)binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,noexec,nosuid,nodev)gvfs-fuse-daemon on /home/kysnail/.gvfs type fuse.gvfs-fuse-daemon (rw,nosuid,nodev,user=kysnail):~$ 2. df12345678910:~$ df -lhT文件系统 类型 容量 已用 可用 已用% 挂载点/dev/sda1 ext4 19G 11G 7.8G 57% /none devtmpfs 498M 248K 497M 1% /devnone tmpfs 502M 252K 501M 1% /dev/shmnone tmpfs 502M 96K 502M 1% /var/runnone tmpfs 502M 0 502M 0% /var/locknone tmpfs 502M 0 502M 0% /lib/init/rwnone debugfs 19G 11G 7.8G 57% /var/lib/ureadahead/debugfs:~$ 3. fdisk123456789101112131415161718192021222324252627:~$ sudo fdisk /dev/sdaWARNING: DOS-compatible mode is deprecated. It&#x27;s strongly recommended to switch off the mode (command &#x27;c&#x27;) and change display units to sectors (command &#x27;u&#x27;).Command (m for help): cDOS Compatibility flag is not setCommand (m for help): uChanging display/entry units to sectorsCommand (m for help): pDisk /dev/sda: 21.5 GB, 21474836480 bytes heads, 63 sectors/track, 2610 cylinders, total 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x00077544Device Boot Start End Blocks Id System/dev/sda1 * 2048 40105983 20051968 83 Linux/dev/sda2 40108030 41940991 916481 5 Extended/dev/sda5 40108032 41940991 916480 82 Linux swap / SolarisCommand (m for help): q 4. file12345:~$ sudo file -s /dev/sda/dev/sda: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 40103936 sectors; partition 2: ID=0x5, starthead 254, startsector 40108030, 1832962 sectors, code offset 0x63kysnail@ubunkysnail:~$ sudo file -s /dev/sda1/dev/sda1: Linux rev 1.0 ext4 filesystem data, UUID=4942da40-8a49-4bfd-9dc2-45c906d48413 (needs journal recovery) (extents) (large files) (huge files):~$ 5. parted12345678910111213141516:~$ sudo partedGNU Parted 2.2使用 /dev/sda欢迎使用 GNU Parted! 输入 &#x27;help&#x27;可获得命令列表.(parted) p Model: VMware, VMware Virtual S (scsi)磁盘 /dev/sda: 21.5GBSector size (logical/physical): 512B/512B分区表：msdos数字 开始： End 大小 类型 文件系统 标志 1049kB 20.5GB 20.5GB primary ext4 启动 20.5GB 21.5GB 938MB extended 20.5GB 21.5GB 938MB logical linux-swap(v1)(parted) 6. 查看 fstab12345678910111213# /etc/fstab: static file system information.## Use &#x27;blkid -o value -s UUID&#x27; to print the universally unique identifier# for a device; this may be used with UUID= as a more robust way to name# devices that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;proc /proc proc nodev,noexec,nosuid 0 0# / was on /dev/sda1 during installationUUID=4942da40-8a49-4bfd-9dc2-45c906d48413 / ext4 errors=remount-ro,user_xattr 0 1# swap was on /dev/sda5 during installationUUID=935fb95d-771f-448e-9d23-4820106e1783 none swap sw 0 0/dev/fd0 /media/floppy0 auto rw,user,noauto,exec,utf8 0 0","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"}]},{"title":"Can't connect to MySQL server on 'xxx.xxx.xxx.xxx' (61)","date":"2025-06-05T09:37:45.000Z","path":"2025/06/05/Can-t-connect-to-MySQL-server-on-xxx-xxx-xxx-xxx-61.html","text":"我要在本机链接我本机上虚拟机的mysql，我使用mac下的workbench，就就是连接不上，报错信息为：“Can’t connect to MySQL server on ‘10.211.55.5’ (61)”，查了好多资料，有一种方法解决了我的问题： 第一步：查看是都3306端口开启使用ufw（不会安装的，请与我联系）， 1sudo ufw status 或者直接使用命令 1netstat -an | grep 3306 如果结果显示类似： 1tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN 从结果可以看出3306端口只是在IP 127.0.0.1上监听，所以拒绝了其他IP的访问。 第二步：修改配置文件修改文件 &#x2F;etc&#x2F;mysql&#x2F;my.cnf文件，打开文件，找到下面内容： 123# Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.bind-address = 127.0.0.1 把上面这一行注释掉或者把127.0.0.1换成合适的IP，建议注释掉。重新启动后，重新使用netstat检测： 12~# netstat -an | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 第三步： 使用创建的用户登录一下，成功。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.gowhich.com/tags/MySQL/"}]},{"title":"Centos下SVN的配置","date":"2025-06-05T09:31:37.000Z","path":"2025/06/05/centos下svn的配置.html","text":"在终端运行svn命令.如果没有安装,系统会提示安装 1.首先需要安装Subversion软件： 1sudo apt-get install subversion 2.建立一个文件夹作为版本库的根目录 1mkdir /var/svnroot/ 这个目录本身不是版本库，只是拿来装版本库的目录 3.进入这个目录，创建版本库 12cd /var/svnroot/svnadmin create mysvn 以后如果有多个项目，可以继续在&#x2F;var&#x2F;svnroot&#x2F;下面create新的版本库 4.配置vlink 12cd /var/svnroot/vlink/conf/ls 将会看到以下文件 1authz passwd svnserve.conf 首先编辑 svnserve.conf 1vim svnserve.conf 其中 anon-access 表示 匿名用户的权限，auth-access 表示经过认证的用户的权限。去掉前面的#注释，顶格写。一般说来像这样就可以了： 12anon-access = noneauth-access = write 然后看到下面有 password-db 这个配置项。 这个是配置使用的密码文件。 1password-db = passwd 为了以后多个版本库同时运行，建议改这个文件到 &#x2F;var&#x2F;svnroot&#x2F;下面。比如： &#x2F;var&#x2F;svnroot&#x2F;passed 1password-db =/var/svnroot/passed 同理，authz-db这个也是，像这样： 1/var/svnroot/authz 然后有个东西叫做realm，这个貌似是连接svn服务器的时候的提示句子。。不过设置成vlink的名字肯定没错。比如 vlink 1realm = vlink 其他的不管。保存退出。 5.编辑 &#x2F;var&#x2F;svnroot&#x2F;passwd这个简单，像这样就可以了： 123[users]username=passwordusername=password 6.启动svnserve 1sudo svnserve -d -r /var/svnroot/ -r 后面的参数是svnroot位置，而不是某个版本库的位置要关闭svnserve可以直接用 kill 结束掉那个进程 7.Configure iptables如果服务器上设置了iptables的话,你需要开启3690端口. 12iptables -A INPUT -p tcp -i eth0 --dport 3690 -j ACCEPT/sbin/iptables -A INPUT -p tcp -i eth0 --dport 3690 -j ACCEPT 查看ipatbles: iptables -L 如果出现下面一行表示设置成功了: 1… ACCEPT tcp – anywhere anywhere tcp dpt:svn 8.测试 在本地 svn co svn://xxx.xxx.xxx.xxx/vlink –username xxx –password xxx如果还有问题的我建议是将svnserve.conf文件中的有关authz注释掉，在测试。我做的时候是有上面的问题，后来师兄注释掉后就好了，具体我也不明白什么原因如何将想要的svn库中文件备份导出和导入呢（这里我没有测试过，大家可以测试一下，我们共同探讨） 9.将原来的Repository导出为一个文件dumpfile 1svnadmin dump path/to/old-repo &gt; dumpfile.svn 10.将dumpfile导入到新的Repository 1svnadmin load path/to/new-repo &lt; dumpfile.svn 11.本机svn的快速迁移方法: 1svnadmin hotcopy old_rep_path new_rep_path 12.将原先服务器的配置文件备份后复制到新服务器中/etc/httpd/conf.d/subversion.conf还有repository目录下的authfile、auth.conf也需要备份后复制到新服务器中 13.linux下重新定位SVN URL方法:如果更换了SVN服务器，就需要重新定位，指向新的SVN URL。重新定位命令：svn switch --relocate 原svn地址 新svn地址如何查看原svn地址？查看原svn路径方法：svn info","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://blog.gowhich.com/tags/Centos/"}]},{"title":"iOS存储方式","date":"2025-06-05T03:06:45.000Z","path":"2025/06/05/iOS存储方式.html","text":"第一种:NSKeyedArchiver（加密形式）代码很简单就不多解释了直接上代码： 123456789101112131415161718//=================NSKeyedArchiver========================NSString *saveStr1 = @ &quot;我是&quot; ;NSString *saveStr2 = @ &quot;数据&quot; ;NSArray *array = [NSArray arrayWithObjects:saveStr1, saveStr2, nil];//----Save//这一句是将路径和文件名合成文件完整路径NSString *Path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSString *filename = [Path stringByAppendingPathComponent:@ &quot;saveDatatest&quot; ];[NSKeyedArchiver archiveRootObject:array toFile:filename];//用于测试是否已经保存了数据saveStr1 = @ &quot;hhhhhhiiii&quot; ;saveStr2 =@ &quot;mmmmmmiiii&quot; ;//----Loadarray = [NSKeyedUnarchiver unarchiveObjectWithFile: filename];saveStr1 = [array objectAtIndex:0];saveStr2 = [array objectAtIndex:1];NSLog(@ &quot;str:%@&quot; ,saveStr1);NSLog(@ &quot;astr:%@&quot; ,saveStr2); 第二种:NSUserDefaults举个简单的例子 1234567891011121314151617//=================NSUserDefaults========================NSString *saveStr1 = @ &quot;我是&quot; ;NSString *saveStr2 = @ &quot;数据&quot; ;NSArray *array = [NSArray arrayWithObjects:saveStr1, saveStr2, nil];//SaveNSUserDefaults *saveDefaults = [NSUserDefaults standardUserDefaults];[saveDefaults setObject:array forKey:@ &quot;SaveKey&quot; ];//用于测试是否已经保存了数据saveStr1 = @ &quot;hhhhhhiiii&quot; ;saveStr2 =@ &quot;mmmmmmiiii&quot; ;//---Loadarray = [saveDefaults objectForKey:@ &quot;SaveKey&quot; ];saveStr1 = [array objectAtIndex:0];saveStr2 = [array objectAtIndex:1];NSLog(@ &quot;str:%@&quot; ,saveStr1);NSLog(@ &quot;astr:%@&quot; ,saveStr2); 第三种:Write写入方式举个例子，也很简单的 123456789101112131415161718192021222324252627//=================Write写入方式========================NSString *saveStr1 = @ &quot;我是&quot; ;NSString *saveStr2 = @ &quot;数据&quot; ;NSArray *array = [NSArray arrayWithObjects:saveStr1, saveStr2, nil];//----SaveNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];if (!documentsDirectory) &#123; NSLog(@ &quot;没找到&quot; );&#125;NSMutableArray *saveDataArray=nil;NSString *appFile = [documentsDirectory stringByAppendingPathComponent:@ &quot;Savedatas.plist&quot; ];[[NSArray arrayWithObjects:array,nil] writeToFile:appFile atomically:NO];//用于测试是否已经保存了数据saveStr1 = @ &quot;hhhhhhiiii&quot; ;saveStr2 =@ &quot;mmmmmmiiii&quot; ;//----Loadif ([[NSFileManager defaultManager] fileExistsAtPath:appFile])&#123; saveDataArray = [NSMutableArray arrayWithContentsOfFile:appFile];&#125;else&#123; saveDataArray = [NSMutableArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@ &quot;Savedatas&quot; ofType:@ &quot;plist&quot; ]];&#125;NSArray *strArray = [saveDataArray objectAtIndex:0];saveStr1 = [strArray objectAtIndex:0];saveStr2 = [strArray objectAtIndex:1];NSLog(@ &quot;str:%@&quot; ,saveStr1);NSLog(@ &quot;astr:%@&quot; ,saveStr2); 第四种:SQLite3在使用sqlite3之前 你需要将libsqlite3.dylib这个类库加入到你的项目中 123456789- (NSString *)dataFilePath&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; return [documentsDirectory stringByAppendingPathComponent:kFilename];&#125;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0]; //首先得到应用程序沙盒中Document文件夹的路径return [documentsDirectory stringByAppendingPathComponent:kFilename]//返回你指定文件的路径 打开数据库 12345sqlite3 *database;if(sqlite3_open([filePath UTF8String], &amp;database)) &#123; sqlite3_close(database); NSAssert(0,@&quot;Failed to open database&quot;);&#125; 创建数据库 123456char *errorMsg;NSString *createSQL = @&quot;CREATE TABLE IF NOT EXISTS FIELDS (ROW INTEGER PRIMARY KEY,FIELD_DATA TEXT);&quot;;if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg)!=SQLITE_OK) &#123; sqlite3_close(database); NSAssert1(0,@&quot;Error creating table:%s&quot;,errorMsg);&#125; 数据查询 123456789101112131415161718NSString *query = @&quot;SELECT ROW, FIELD_DATA FROM FIELDS ORDER BY ROW&quot;;sqlite3_stmt *statement;if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil)==SQLITE_OK) &#123; while (sqlite3_step(statement)==SQLITE_ROW) &#123; int row = sqlite3_column_int(statement, 0); char *rowData = (char *)sqlite3_column_text(statement, 1); //NSString *fieldName = [[NSString alloc] initWithFormat:@&quot;field&amp;d&quot;,row]; //NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData]; //UITextField *field = [self valueForKey:fieldName]; //field.text = fieldValue; //[fieldName release]; //[fieldValue release]; &#125; sqlite3_finalize(statement);&#125;sqlite3_close(database); 数据插入／更新 12345678910111213141516171819202122232425sqlite3 *database;if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database)) &#123; sqlite3_close(database); NSAssert(0,@&quot;Failed to open database&quot;);&#125; for (int i=1; i&lt;=4; i++) &#123; NSString *fieldName = [[NSString alloc] initWithFormat:@&quot;field%d&quot;,i]; UITextField *field = [self valueForKey:fieldName]; [fieldName release]; char *errorMsg; char *update = &quot;INSERT OR REPLACE INTO FIELDS (ROW,FIELD_DATA) VALUES(?,?);&quot;; //这里插入的值可以用nsstring替换，但是最好的做法是使用绑定，如果遇到特殊字符 这是不二选择 sqlite3_stmt *stmt; if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil)==SQLITE_OK) &#123; sqlite3_bind_int(stmt, 1, i); sqlite3_bind_text(stmt, 2, [[field text] UTF8String], -1, NULL); &#125; if (sqlite3_step(stmt)!=SQLITE_DONE) &#123; NSAssert(0,@&quot;Error updating table:%s&quot;,errorMsg); &#125; sqlite3_finalize(stmt);&#125;sqlite3_close(database); #######################可爱分割线############################# 对Write写入方式保存数据和读取数据封装了两个方法： 封装的函数如下： 1234567891011121314151617181920212223242526//保存游戏数据 //参数介绍： // (NSMutableArray *)data ：保存的数据 // (NSString *)fileName ：存储的文件名 -(BOOL) saveGameData:(NSMutableArray *)data saveFileName:(NSString *)fileName &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; if (!documentsDirectory) &#123; NSLog(@&quot;Documents directory not found!&quot;); return NO; &#125; NSString *appFile = [documentsDirectory stringByAppendingPathComponent:fileName]; return ([data writeToFile:appFile atomically:YES]); &#125; //读取游戏数据 //参数介绍： // (NSString *)fileName ：需要读取数据的文件名 -(id) loadGameData:(NSString *)fileName &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSString *appFile = [documentsDirectory stringByAppendingPathComponent:fileName]; NSMutableArray *myData = [[[NSMutableArray alloc] initWithContentsOfFile:appFile] autorelease]; return myData; &#125; 可以使用类似下面的例子进行使用 123456NSString *saveStr1 = @&quot;测试保存读取&quot;; NSString *saveStr2 = @&quot;两个函数&quot;; NSMutableArray *array = [NSMutableArray arrayWithObjects:saveStr1, saveStr2, nil]; [self saveGameData:array saveFileName:@&quot;Himi&quot;]; NSMutableArray*temp =(NSMutableArray*)[self loadGameData:@&quot;Himi&quot;]; NSLog(@&quot;%@--%@&quot;,[temp objectAtIndex:0],[temp objectAtIndex:1]); 有两点需要注意的地方： 1，取出数据的时候需要注意 12NSUserDefaults *saveDefaults = [NSUserDefaults standardUserDefaults]; NSMutableArray *arraySaveData =[saveDefaults objectForKey:@&quot;OhSaveData&quot;]; //NSMutableArray *arraySaveData=[NSMutableArray arrayWithArray:[saveDefaults objectForKey:@&quot;OhSaveData&quot;]]; 第二句代码是通过一个文件名获取你存储的数据，返回数据数组，但是！一定要注意这里返回的数据数组是不可修改的！及时你将读取的数据赋给一个可修改的数组中也一样无法修改其中的数据，所以如果你想将取出的数据进行修改那么这里需要要使用第三行代码来获取 2，修改已经的存储文件 12NSUserDefaults *saveDefaults = [NSUserDefaults standardUserDefaults]; [saveDefaults setObject:arraySaveData forKey:@&quot;已经存在的文件名&quot;];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"Yii使用model进行设置查询规则/模型/控制器","date":"2025-06-05T02:52:51.000Z","path":"2025/06/05/Yii使用model进行设置查询规则-模型-控制器.html","text":"yii有个查询数据的便利的地方，就是可以在model层设置查询规则，然后在controller层，直接调用，进行数据查询： 举个例子说明一下： 先从model层说起：model名称叫做Blog，继承自CActiveRecord 123456789101112131415function scopes()&#123; return [ &#x27;published&#x27; =&gt; [ &#x27;condition&#x27; =&gt; &#x27;status=1&#x27;, ], &#x27;recently&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, &#x27;limit&#x27; =&gt; 5, ], &#x27;createDateDesc&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, ], ];&#125; 在上面的代码中，继承函数scopes,然后在里面命名自己想要使用的规则名称。 我这里使用了 published，recently，createCateDesc，分别对应sql语句的一部分，这个在调用controller的时候会合并到总的sql语句里面去的。 下面看在controller里面怎么使用 12345678910111213//最近的博文$rawData = Blog::model()-&gt;recently()-&gt;findAll();$rawData = new CArrayDataProvider($rawData, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;title&#x27;, ], ], &#x27;pagination&#x27; =&gt; [ &#x27;pageSize&#x27; =&gt; 10, ],]); 我在自己的BlogController控制器，action为actionView的方法中引用了这样一个代码： 注意其中的recently部分 1$rawData=Blog::model()-&gt;recently()-&gt;findAll(); 这个就是我们在model层设置的规则，在这里作为方法被调用了。 是不是很方便呀。 详细的代码我贴到下面： model123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?php/** * This is the model class for table &quot;tbl_blog&quot;. * * The followings are the available columns in table &#x27;tbl_blog&#x27;: * @property integer $id * @property string $title * @property string $description * @property string $create_date * @property string $update_date */class Blog extends CActiveRecord&#123; /** * Returns the static model of the specified AR class. * @param string $className active record class name. * @return Blog the static model class */ public static function model($className = __CLASS__) &#123; return parent::model($className); &#125; /** * @return string the associated database table name */ public function tableName() &#123; return &#x27;tbl_blog&#x27;; &#125; /** * @return array validation rules for model attributes. */ public function rules() &#123; // NOTE: you should only define rules for those attributes that // will receive user inputs. return [ [&#x27;title&#x27;, &#x27;required&#x27;, &#x27;message&#x27; =&gt; &#x27;标题不能为空&#x27;], [&#x27;description&#x27;, &#x27;required&#x27;, &#x27;message&#x27; =&gt; &#x27;内容不能为空&#x27;], [&#x27;title&#x27;, &#x27;length&#x27;, &#x27;max&#x27; =&gt; 255], [&#x27;tag&#x27;, &#x27;safe&#x27;], [&#x27;type_id&#x27;, &#x27;safe&#x27;], [&#x27;update_date&#x27;, &#x27;safe&#x27;], // The following rule is used by search(). // Please remove those attributes that should not be searched. [&#x27;id, title, description, create_date, update_date&#x27;, &#x27;safe&#x27;, &#x27;on&#x27; =&gt; &#x27;search&#x27;], ]; &#125; /** * @return array relational rules. */ public function relations() &#123; // NOTE: you may need to adjust the relation name and the related // class name for the relations automatically generated below. return [ ]; &#125; /** * @return array customized attribute labels (name=&gt;label) */ public function attributeLabels() &#123; return [ &#x27;id&#x27; =&gt; &#x27;ID序号&#x27;, &#x27;title&#x27; =&gt; &#x27;标题&#x27;, &#x27;description&#x27; =&gt; &#x27;内容&#x27;, &#x27;tag&#x27; =&gt; &#x27;标签(使用逗号进行分割)&#x27;, &#x27;type_id&#x27; =&gt; &#x27;分类类型&#x27;, &#x27;create_date&#x27; =&gt; &#x27;创建时间&#x27;, &#x27;update_date&#x27; =&gt; &#x27;更新时间&#x27;, ]; &#125; /** * Retrieves a list of models based on the current search/filter conditions. * @return CActiveDataProvider the data provider that can return the models based on the search/filter conditions. */ public function search() &#123; // Warning: Please modify the following code to remove attributes that // should not be searched. $criteria = new CDbCriteria(); $criteria-&gt;compare(&#x27;id&#x27;, $this-&gt;id); $criteria-&gt;compare(&#x27;title&#x27;, $this-&gt;title, true); $criteria-&gt;compare(&#x27;description&#x27;, $this-&gt;description, true); $criteria-&gt;compare(&#x27;create_date&#x27;, $this-&gt;create_date, true); $criteria-&gt;compare(&#x27;update_date&#x27;, $this-&gt;update_date, true); $criteria-&gt;scopes = &#x27;createDateDesc&#x27;; return new CActiveDataProvider($this, [ &#x27;criteria&#x27; =&gt; $criteria, ]); &#125; /** * 行为操作 */ public function behaviors() &#123; return [ &#x27;CTimestampBehavior&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;zii.behaviors.CTimestampBehavior&#x27;, &#x27;createAttribute&#x27; =&gt; &#x27;create_date&#x27;, &#x27;updateAttribute&#x27; =&gt; &#x27;update_date&#x27;, &#x27;setUpdateOnCreate&#x27; =&gt; &#x27;true&#x27;, ], ]; &#125; //查询范围 public function scopes() &#123; return [ &#x27;published&#x27; =&gt; [ &#x27;condition&#x27; =&gt; &#x27;status=1&#x27;, ], &#x27;recently&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, &#x27;limit&#x27; =&gt; 5, ], &#x27;createDateDesc&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, ], ]; &#125;&#125; controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263&lt;?phpclass BlogController extends Controller&#123; /** * @var string the default layout for the views. Defaults to &#x27;//layouts/column2&#x27;, meaning * using two-column layout. See &#x27;protected/views/layouts/column2.php&#x27;. */ public $layout = &#x27;//layouts/column2&#x27;; /** * @return array action filters */ public function filters() &#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations &#x27;postOnly + delete&#x27;, // we only allow deletion via POST request ]; &#125; /** * Specifies the access control rules. * This method is used by the &#x27;accessControl&#x27; filter. * @return array access control rules */ public function accessRules() &#123; return [ [&#x27;allow&#x27;, // allow all users to perform &#x27;index&#x27; and &#x27;view&#x27; actions &#x27;actions&#x27; =&gt; [&#x27;view&#x27;], &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], [&#x27;allow&#x27;, // allow authenticated user to perform &#x27;create&#x27; and &#x27;update&#x27; actions &#x27;actions&#x27; =&gt; [&#x27;create&#x27;, &#x27;update&#x27;, &#x27;index&#x27;], &#x27;users&#x27; =&gt; [&#x27;@&#x27;], ], [&#x27;allow&#x27;, // allow admin user to perform &#x27;admin&#x27; and &#x27;delete&#x27; actions &#x27;actions&#x27; =&gt; [&#x27;admin&#x27;, &#x27;delete&#x27;], &#x27;user&#x27; =&gt; [&#x27;admin&#x27;], ], [&#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ]; &#125; /** * Displays a particular model. * @param integer $id the ID of the model to be displayed */ public function actionView($id) &#123; //最近的博文 $rawData = Blog::model()-&gt;recently()-&gt;findAll(); $rawData = new CArrayDataProvider($rawData, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;title&#x27;, ], ], &#x27;pagination&#x27; =&gt; [ &#x27;pageSize&#x27; =&gt; 10, ], ]); $recentBlogMenu = []; foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $recentBlogMenu[] = [ &#x27;label&#x27; =&gt; $value-&gt;title, &#x27;url&#x27; =&gt; [&#x27;blog/view&#x27;, &#x27;id&#x27; =&gt; $value-&gt;id], ]; &#125; //博文的分类 $rawData = Type::model()-&gt;findAll(); $rawData = new CArrayDataProvider($rawData, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;name&#x27;, ], ], ]); $blogType = []; foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $blogType[] = [ &#x27;label&#x27; =&gt; $value-&gt;name, &#x27;url&#x27; =&gt; [&#x27;type/search/&#x27; . $value-&gt;id], ]; &#125; $this-&gt;render(&#x27;view&#x27;, [ &#x27;model&#x27; =&gt; $this-&gt;loadModel($id), &#x27;blogType&#x27; =&gt; $blogType, &#x27;recentBlogMenu&#x27; =&gt; $recentBlogMenu, ]); &#125; /** * Creates a new model. * If creation is successful, the browser will be redirected to the &#x27;view&#x27; page. */ public function actionCreate() &#123; $model = new Blog; // Uncomment the following line if AJAX validation is needed // $this-&gt;performAjaxValidation($model); if (isset($_POST[&#x27;Blog&#x27;])) &#123; $model-&gt;attributes = $_POST[&#x27;Blog&#x27;]; if ($model-&gt;save()) &#123; $this-&gt;redirect([&#x27;view&#x27;, &#x27;id&#x27; =&gt; $model-&gt;id]); &#125; &#125; $rawData = new CActiveDataProvider( &#x27;Type&#x27;, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;name&#x27;, ], ], ] ); foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $type[$value-&gt;id] = $value-&gt;name; &#125; $this-&gt;render(&#x27;create&#x27;, [ &#x27;model&#x27; =&gt; $model, &#x27;type&#x27; =&gt; $type, ]); &#125; /** * Updates a particular model. * If update is successful, the browser will be redirected to the &#x27;view&#x27; page. * @param integer $id the ID of the model to be updated */ public function actionUpdate($id) &#123; $model = $this-&gt;loadModel($id); // Uncomment the following line if AJAX validation is needed // $this-&gt;performAjaxValidation($model); if (isset($_POST[&#x27;Blog&#x27;])) &#123; $model-&gt;attributes = $_POST[&#x27;Blog&#x27;]; if ($model-&gt;save()) &#123; $this-&gt;redirect([&#x27;view&#x27;, &#x27;id&#x27; =&gt; $model-&gt;id]); &#125; &#125; $rawData = new CActiveDataProvider( &#x27;Type&#x27;, [ &#x27;sort&#x27; =&gt; [ &#x27;attributes&#x27; =&gt; [ &#x27;id&#x27;, &#x27;name&#x27;, ], ], ] ); foreach ($rawData-&gt;getData() as $key =&gt; $value) &#123; $type[$value-&gt;id] = $value-&gt;name; &#125; $this-&gt;render(&#x27;update&#x27;, [ &#x27;model&#x27; =&gt; $model, &#x27;type&#x27; =&gt; $type, ]); &#125; /** * Deletes a particular model. * If deletion is successful, the browser will be redirected to the &#x27;admin&#x27; page. * @param integer $id the ID of the model to be deleted */ public function actionDelete($id) &#123; $this-&gt;loadModel($id)-&gt;delete(); // if AJAX request (triggered by deletion via admin grid view), we should not redirect the browser if (!isset($_GET[&#x27;ajax&#x27;])) &#123; $this-&gt;redirect(isset($_POST[&#x27;returnUrl&#x27;]) ? $_POST[&#x27;returnUrl&#x27;] : [&#x27;admin&#x27;]); &#125; &#125; /** * Lists all models. */ public function actionIndex() &#123; $dataProvider = new CActiveDataProvider( &#x27;Blog&#x27;, [ &#x27;pagination&#x27; =&gt; [&#x27;pageSize&#x27; =&gt; 10], &#x27;criteria&#x27; =&gt; [ &#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;, ], ] ); $this-&gt;render(&#x27;index&#x27;, [ &#x27;dataProvider&#x27; =&gt; $dataProvider, ]); &#125; /** * Manages all models. */ public function actionAdmin() &#123; $model = new Blog(&#x27;search&#x27;); $model-&gt;unsetAttributes(); // clear any default values if (isset($_GET[&#x27;Blog&#x27;])) &#123; $model-&gt;attributes = $_GET[&#x27;Blog&#x27;]; &#125; $this-&gt;render(&#x27;admin&#x27;, [ &#x27;model&#x27; =&gt; $model, ]); &#125; /** * Returns the data model based on the primary key given in the GET variable. * If the data model is not found, an HTTP exception will be raised. * @param integer the ID of the model to be loaded */ public function loadModel($id) &#123; $model = Blog::model()-&gt;findByPk($id); if (null === $model) &#123; throw new CHttpException(404, &#x27;请求的页面不存在.&#x27;); &#125; return $model; &#125; /** * Performs the AJAX validation. * @param CModel the model to be validated */ protected function performAjaxValidation($model) &#123; if (isset($_POST[&#x27;ajax&#x27;]) &amp;&amp; &#x27;blog-form&#x27; === $_POST[&#x27;ajax&#x27;]) &#123; echo CActiveForm::validate($model); Yii::app()-&gt;end(); &#125; &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"},{"name":"Yii","slug":"Yii","permalink":"https://blog.gowhich.com/tags/Yii/"}]},{"title":"Objective-C分类(Category)借用Smalltalk实现中的“分类”概念","date":"2025-06-05T02:26:00.000Z","path":"2025/06/05/Objective-C分类-Category-借用Smalltalk实现中的“分类”概念.html","text":"在Objective-C的设计中，一个主要的考虑即为大型代码框架的维护。结构化编程的经验显示，改进代码的一种主要方法即为将其分解为更小的片段。Objective-C借用并扩展了Smalltalk实现中的“分类”概念，用以帮助达到分解代码的目的。[1] 一个分类可以将方法的实现分解进一系列分离的文件。程序员可以将一组相关的方法放进一个分类，使程序更具可读性。举例来讲，可以在字符串类中增加一个名为“拼写检查”的分类，并将拼写检查的相关代码放进这个分类中。 进一步的，分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法，而无需持有原有的代码，或是重新编译原有的类。例如若系统提供的字符串类的实现中不包含拼写检查的功能，可以增加这样的功能而无需更改原有的字符串类的代码。 在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。 若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。 其它语言也尝试了通过不同方法增加这一语言特性。TOM在这方面走的更远，不仅允许增加方法，更允许增加成员变量。也有其它语言使用面向声明的解决方案，其中最值得注意的是Self语言。 C#与Visual Basic.NET语言以扩展函数的与不完全类的方式实现了类似的功能。Ruby与一些动态语言则以”monkey patch”的名字称呼这种技术。 使用分类的例子 这个例子创建了Integer类，其本身只定义了integer属性，然后增加了两个分类Arithmetic与Display以扩展类的功能。虽然分类可以访问类的私有成员，但通常利用属性的访问方法来访问是一种更好的做法，可以使得分类与原有类更加独立。这是分类的一种典型应用—另外的应用是利用分类来替换原有类中的方法，虽然用分类而不是继承来替换方法不被认为是一种好的做法。 Integer.h123456789101112#import &lt;objc/Object.h&gt; @interface Integer : Object&#123;@private int integer;&#125; @property (assign, nonatomic) integer; @end Integer.m12345678#import &quot;Integer.h&quot; @implementation Integer @synthesize integer; @end Arithmetic.h1234567#import &quot;Integer.h&quot; @interface Integer (Arithmetic)- (id) add: (Integer *) addend;- (id) sub: (Integer *) subtrahend;@end Arithmetic.m12345678910111213#import &quot;Arithmetic.h&quot;@implementation Integer (Arithmetic)- (id) add: (Integer *) addend&#123; self.integer = self.integer + addend.integer; return self;&#125; - (id) sub: (Integer *) subtrahend&#123; self.integer = self.integer - subtrahend.integer; return self;&#125;@end Display.h12345678 #import &quot;Integer.h&quot;@interface Integer (Display)- (id) showstars;- (id) showint;@end Display.m123456789101112131415161718#import &quot;Display.h&quot;@implementation Integer (Display)- (id) showstars&#123; int i, x = self.integer; for(i=0; i &lt; x; i++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); return self;&#125; - (id) showint&#123; printf(&quot;%d\\n&quot;, self.integer); return self;&#125;@end main.m12345678910111213141516171819202122232425262728 #import &quot;Integer.h&quot;#import &quot;Arithmetic.h&quot;#import &quot;Display.h&quot;int main(void)&#123; Integer *num1 = [Integer new], *num2 = [Integer new]; int x; printf(&quot;Enter an integer: &quot;); scanf(&quot;%d&quot;, &amp;x); num1.integer = x; [num1 showstars]; printf(&quot;Enter an integer: &quot;); scanf(&quot;%d&quot;, &amp;x); num2.integer = x; [num2 showstars]; [num1 add:num2]; [num1 showint]; return 0;&#125; 注释 可以利用以下命令来编译： 1gcc -x objective-c main.m Integer.m Arithmetic.m Display.m -lobjc 在编译时间，可以利用省略#import &quot;Arithmetic.h&quot;与[num1 add:num2]命令，以及Arithmetic.m文件来实验。程序仍然可以运行，这表明了允许动态的、按需的加载分类；若不需要某一分类提供的功能，可以简单的不编译之。 源自：维基百科","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C与Smalltalk类似的动态类型","date":"2025-06-04T09:14:58.000Z","path":"2025/06/04/Objective-C与Smalltalk类似的动态类型.html","text":"动态类型类似于Smalltalk，Objective-C具备动态类型： 即消息可以发送给任何对象实体，无论该对象实体的公开接口中有没有对应的方法。在C++这种静态类型的语言里，不可能对一个(void*)指针调用任何方 法，编译器会挡下该调用行为。但在Objective-C中，你可以对id发送任何信息(id很像void*，但是被严格限制只能使用在对象上)，编译器 仅会发出“该对象可能无法回应信息”的警告，程序同样可以通过编译，而实际发生的事则取决于运行期该对象的真正形态，若该对象的确可以回应消息，则依旧运 行对应的方法。 这种特性可以增加语言的灵活性，因为它允许对象“捕捉”消息，再将消息转送到另一个可以正确处理该消息的对象，形同消息“转发”给另一个对象。 一个对象收到信息之后，他有三种处理信息的可能手段，第一是回应该消息并运行方法，若无法回应，则可以转发消息给其他对象，若以上两者均无，就要处 理无法回应而抛出的例外。只要进行三者之其一，该消息就算完成任务而被丢弃。若对“nil”（空对象指针）发送消息，该消息通常会被忽略，取决于编译器选 项可能会抛出例外。 虽然Objective-C具备动态类型的能力，但编译期的静态类型检查依旧可以应用到变量上。以下三种声明在运行时效力是完全相同的，但是三种声明提供了一个比一个更明显的类型信息，附加的类型信息让编译器在编译时可以检查变量类型，并对类型不符的变量提出警告。 下面三个方法，差异仅在于参数的形态： 1- setMyValue:(id) foo; id形态表示参数“foo”可以是任何类的实例。 1- setMyValue:(id &lt;aProtocol&gt;) foo; id &lt;aProtocol&gt;表示“foo”可以是任何类的实例，但必须采纳“aProtocol”协议。 1- setMyValue:(NSNumber*) foo; 该声明表示“foo”必须是“NSNumber”的实例。 动态类型是一种强大的特性。在缺少泛型的静态类型语言（如Java 5以前的版本）中实现容器类时，程序员需要写一种针对通用类型对象的容器类，然后在通用类型和实际类型中不停的强制类型转换。无论如何，类型转换会破坏静态类型，例如写入一个“整数”而将其读取为“字符串”会产生运行时错误。这样的问题被泛型解决，但容器类需要其内容对象的类型一致，而对于动态类型语言则完全没有这方面的问题。 [资料：维基百科]","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C对象发送消息[转发]","date":"2025-06-04T08:54:17.000Z","path":"2025/06/04/Objective-C对象发送消息-转发.html","text":"Objective-C允许对一个对象发送消息，不管它是否能够响应之。除了响应或丢弃消息以外，对象也可以将消息转发到可以响应该消息的对象。转发可以用于简化特定的设计模式，例如观测器模式或代理模式。 Objective-C运行时在Object中定义了一对方法： A.转发方法: 12- (retval_t) forward:(SEL) sel :(arglist_t) args; // with GCC- (id) forward:(SEL) sel :(marg_list) args; // with NeXT/Apple systems B.响应方法: 12- (retval_t) performv:(SEL) sel :(arglist_t) args; // with GCC- (id) performv:(SEL) sel :(marg_list) args; // with NeXT/Apple systems 希望实现转发的对象只需用新的方法覆盖以上方法来定义其转发行为。无需重写响应方法performv::，由于该方法只是单纯的对响应对象发送消息并传递参数。其中，SEL类型是Objective-C中消息的类型。 例子 这里包括了一个演示转发的基本概念的程序示例。(代码来源：维基百科Objective-C) Forwarder.h123456789#import &lt;objc/Object.h&gt; @interface Forwarder : Object&#123; id recipient; //该对象是我们希望转发到的对象。&#125; @property (assign, nonatomic) id recipient; @end Forwarder.m1234567891011121314151617#import &quot;Forwarder.h&quot; @implementation Forwarder @synthesize recipient; - (retval_t) forward: (SEL) sel : (arglist_t) args&#123; /* *检查转发对象是否响应该消息。 *若转发对象不响应该消息，则不会转发，而产生一个错误。 */ if([recipient respondsTo:sel]) return [recipient performv: sel : args]; else return [self error:&quot;Recipient does not respond&quot;];&#125; Recipient.h1234567#import &lt;objc/Object.h&gt; // A simple Recipient object.@interface Recipient : Object- (id) hello;@end Recipient.m123456789101112#import &quot;Recipient.h&quot; @implementation Recipient - (id) hello&#123; printf(&quot;Recipient says hello!\\n&quot;); return self;&#125; @end main.m1234567891011121314151617#import &quot;Forwarder.h&quot;#import &quot;Recipient.h&quot; int main(void)&#123; Forwarder *forwarder = [Forwarder new]; Recipient *recipient = [Recipient new]; forwarder.recipient = recipient; //Set the recipient. /* *转发者不响应hello消息！该消息将被转发到转发对象。 * (若转发对象响应该消息) */ [forwarder hello]; return 0;&#125; 脚注 利用GCC编译时，编译器报告： 1234$ gcc -x objective-c -Wno-import Forwarder.m Recipient.m main.m -lobjcmain.m: In function `main&#x27;:main.m:12: warning: `Forwarder&#x27; does not respond to `hello&#x27; 如前文所提到的，编译器报告Forwarder类不响应hello消息。在这种情况下，由于实现了转发，可以忽略这个警告。 运行该程序产生如下输出： 12$ ./a.outRecipient says hello!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Golang新版本安装吐槽","date":"2025-06-03T09:14:58.000Z","path":"2025/06/03/Golang新版本安装吐槽.html","text":"我是打算使用一下最新版本的Golang，然后使用下Hugo，结果安装的时候提示要安装上一个版本，我感觉没啥问题，我就安装了要求安装的版本，结果还是有问题继续安装要求安装的版本结果就是一个套着一个，我服了 这个机制头一次见到 123456789101112131415161718192021222324252627282930313233343536373839404142$ gvm install go1.24.3Updating Go source...Installing go1.24.3... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.24.3-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:01] C:130$ tail -f -n 100 ~/.gvm/logs/go-go1.24.3-compile.log Building Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_22_6_or_later (notgo122.go) in /home/durban/.gvm/gos/go1.24.3/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:25] C:130$ gvm install go1.22.6 Installing go1.22.6... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.22.6-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:35] C:1$ tail -f -n 100 ~/.gvm/logs/go-go1.22.6-compile.logBuilding Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_20_6_or_later (notgo120.go) in /home/durban/.gvm/gos/go1.22.6/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:49] C:130$ gvm install go1.20.6 Installing go1.20.6... * Compiling...ERROR: Failed to compile. Check the logs at /home/durban/.gvm/logs/go-go1.20.6-compile.logERROR: Failed to use installed version# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:13:53] C:1$ tail -f -n 100 ~/.gvm/logs/go-go1.20.6-compile.logBuilding Go cmd/dist using /home/durban/.gvm/gos/go1.14.15. (go1.14.15 linux/amd64)can&#x27;t load package: package ./cmd/dist: found packages main (build.go) and building_Go_requires_Go_1_17_13_or_later (notgo117.go) in /home/durban/.gvm/gos/go1.20.6/src/cmd/dist# durban @ durban-amd-workspace in ~/Downloads/ubuntu_software [17:14:02] C:130$ gvm install go1.17.13 Installing go1.17.13... * Compiling...go1.17.13 successfully installed! 笑死人 这个安装逻辑就是按照这个顺序依次安装 1234gvm install go1.17.13gvm install go1.20.6gvm install go1.22.6gvm install go1.24.3 为了体验下新版本我这是招谁了","tags":[{"name":"Golang","slug":"Golang","permalink":"https://blog.gowhich.com/tags/Golang/"}]},{"title":"Objective-C 创建对象","date":"2025-06-03T09:03:50.000Z","path":"2025/06/03/Objective-C-创建对象.html","text":"Objective-C中创建对象的方法：Objective-C 创建对象需通过 alloc 以及 init。alloc的作用是分配内存，init 则是初始化对象。 init 与 alloc 都是定义在 NSObject 里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。以下为范例： 1MyObject * my = [[MyObject alloc] init]; 在 Objective-C 2.0 里，若创建对象不需要参数，则可直接使用 new 1MyObject * my = [MyObject new]; 这仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写 init 方法，来添加额外的工作。(用途类似 C++ 的构造函数 constructor) 123456- (id) init &#123; if ( self=[super init] ) &#123; // 必须调用父类的 init // do something here ... &#125; return self;&#125;","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C 协议(Protocol)","date":"2025-06-03T08:54:11.000Z","path":"2025/06/03/Objective-C-协议-Protocol.html","text":"协议是一组尚未实现的方法列表，任何的类均可采纳该协议并给出方法的具体实现。 Objective-C在NeXT时期曾经试图引入多重继承的概念，但由于协议的出现而没有实现。协议的功能类似于C++中的多重抽象基类继承或是Java与C#语言中的“接口”。在Objective-C中，包括两种定义协议的方式：由编译器保证的“正式协议”，以及为特定目的设定的“非正式协议”。 非正式协议为一个可以选择性实现的一系列方法列表。非正式协议虽名为协议，但实际上是挂于NSObject上的未实现分类 (Unimplemented Category)的一种称谓，Objetive-C语言机制上并没有非正式协议这种东西，OSX 10.6版本之后由于正式协议也可以通过@optional关键字达成相同功用，所以非正式协议已经被废弃不再使用。 正式协议则类似于Java中的”接口”，它是一系列方法的列表，任何类都可以声明自身实现了某个协议。在Objective-C 2.0之前，一个类必须实现它声明符合的协议中的所有方法，否则编译器会报告一个错误，表明这个类没有实现它声明符合的协议中的全部方法。 Objective-C 2.0版本允许标记协议中某些方法为可选的(Optional)，这样编译器就不会强制实现这些可选的方法。 协议经常应用于Cocoa 中的委托及事件触发。例如文本框类通常会包括一个委托 (delegate)对象，该对象可以实现一个协议，该协议中可能包含一个实现文字输入的自动完成方法。若这个委托对象实现了这个方法，那么文本框类就会在适当的时候触发自动完成事件，并调用这个方法用于自动完成功能。 Objective-C中协议的概念与Java中接口的概念并不完全相同，即一个类可以在不声明它符合某个协议的情况下，实现这个协议所包含的方 法，也即实质上符合这个协议，而这种差别对外部代码而言是不可见的。正式协议的声明不提供实现，它只是简单地表明符合该协议的类实现了该协议的方法，保证 调用端可以安全调用方法。 语法 协议以关键字@protocol作为区段起始，@end退出，中间为方法列表。 1234@protocol Locking- (void)lock;- (void)unlock;@end 这是一个协议的例子，多线程编程中经常要确保一份共享资源同时只有一个线程可以使用，会在使用前给该资源挂上锁 ，以上即为一个表明有“锁”的概念的协议，协议中有两个方法，只有名称但尚未实现。 下面的SomeClass宣称他采纳了Locking协议： 123456789101112@interface SomeClass : SomeSuperClass &lt;Locking&gt;@end一旦SomeClass表明他采纳了Locking协议，SomeClass就有义务实现Locking协议中的两个方法。@implementation SomeClass- (void)lock &#123; // 实现lock方法...&#125;- (void)unlock &#123; // 实现unlock方法...&#125;@end 由于SomeClass已经确实遵从了Locking协议，故调用端可以安全的发送lock或unlock信息给SomeClass实体变量，不需担心他没有办法回应信息。 插件是另一个使用抽象定义的例子，可以在不关心插件的实现的情况下定义其希望的行为。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C 类型的声明与实现","date":"2025-06-03T08:45:02.000Z","path":"2025/06/03/Objective-C-类型的声明与实现.html","text":"Objective-C 类型要求区分接口（interface）与实现（implementation）为两个程序区块，这是强制性的。 类型的接口通常放置于头文件内，依C语言的惯例以.h作为扩展名；类型的实现则放于以.m为扩展名。 Interface接口区段里头清楚定义了类型的名称，实体变量（instance variable），以及方法。 以关键字@interface作为区段起头，@end退出区段。 12345678910@interface MyObject : NSObject &#123; int memberVar1; // 实体变量 id memberVar2;&#125;+(return_type) class_method; // 类别分类 -(return_type) instance_method1; // 实体方法-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 方法前面的+&#x2F;-号代表方法的类型：加号（+）代表类型方法（class method），不需要实体就可以调用，近于C++的静态成员函数（static member function）。减号（-）即是一般的实体方法（instance method）。 这里提供了一份意义相近的C++语法对照，如下： 123456789101112class MyObject : public NSObject &#123; protected: int memberVar1; // 实体变量 void * memberVar2; public: static return_type class_method(); // 类别方法 return_type instance_method1(); // 实体方法 return_type instance_method2( int p1 ); return_type instance_method3( int p1, int p2 );&#125; Objective-C定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C方法的参数也不必全部都附缀于方法名称的尾端，也可以夹杂于名称中间，提高程序可读性。以一个设置颜色RGB值的方法为例: 123- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法 */[myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法 */ 这个方法的全名是setColorToRed:Green:Blue:。每个冒号后面都带着一个形态为float的参数，分别代表红，绿，蓝三色。 Implementation实现区段则撰写方法实际运行的程序。以关键字@implementation作为区段起头，@end结尾。 1234567891011121314151617@implementation MyObject &#123; int memberVar3; //私有实体变量&#125; +(return_type) class_method &#123; .... //method implementation&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 值得一提的是不只interface区段开头可以声明实体变量，implementation区段开头也可以声明实体变量，两者的差别在于成员访问权限， 声明于interface区段内的实体变量默认权限为protected，声明于implementation区段的实体变量则默认为private，基 于面向对象的封装原则，仅供类型内部使用的变量请尽可能声明于implementation区段(.m档)内，不需要曝露于interface(.h档) 中。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"iOS开发是否应该使用ARC","date":"2025-06-03T08:43:01.000Z","path":"2025/06/03/iOS开发是否应该使用ARC.html","text":"关于ARC的介绍文章网上已经很多，苹果的官方文档也不少。担心使用ARC会带来问题的同学主要的理由有以下5点: 1.担心这个技术方案不靠谱。苹果大多数时候的技术方案都是比较靠谱的，但也有一些技术方案有很多坑，例如storyboard。 2.原有的项目在非ARC环境下运行良好，担心迁移成本或引入新的问题。 3.苹果以前手工管理内存需要非常小心，稍微不注意应用程序就崩溃了。有过这段经历的iOS开发老手，心里上还是觉得自己手工管理内存更踏实一些。 4.使用ARC需要了解ARC的一些细节，还需要引入_bridge等新的关键字，学习成本还是有的。 5.以为ARC只能支持iOS5.0以上（这是非常大的误解）。 对于上面提到5点问题，我认为相应的回答如下: 1.ARC是WWDC2011大会时提出的技术，离现在已经快2年了，而且苹果现在将MacOS上的垃圾回收机制废弃(Deprecated)，采用ARC替代，无疑证明了ARC是成熟的了。 2.确实有一些迁移成本，但苹果在Xcode中专门集成了迁移工具，成本已经非常小了。如下图就是Xcode集成的将非ARC工程转换成ARC工程的工具。另外，为了兼容第三方的非ARC开源库，你也可以在工程中随意使用编译参数：-fno-objc-arc ,这个参数允许对部分文件关闭ARC。 3.手工管理内存虽然踏实，但是泄露很容易发生。常常开发完成后，需要使用Instruments来检测泄露。但用了ARC后，基本不会出现泄露了，我在 开发粉笔网iPhone客户端时，由于使用了ARC，花三个月开发完的应用，用instruments检测后，没有发现任何内存泄漏问题。这在没有使用 ARC的工程中是不可想象的。 4.确实有学习成本。但是非常值得学习，能省不少开发精力。 5.虽然ARC是与iOS5一同推出，但是由于ARC的实现机制是在编译期完成，所以使用ARC之后App仍然可以支持iOS4.3。稍微需要注意的是， 如果要在ARC开启的情况下支持iOS4.3，需要将weak关键字换成 __unsafe_unretained，另外还有一些细节需要处理 所以，希望大家都能在项目中使用ARC，一旦你感受到它带来的好处，你就离不开它了。它也能让你从繁琐的内存管理代码中解放出来，将精力更多关注于代码结构、设计模式而不是底层的内存管理。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.gowhich.com/tags/iOS/"}]},{"title":"Yii Widget的使用","date":"2025-06-03T07:18:28.000Z","path":"2025/06/03/Yii-Widget的使用.html","text":"小插件解决大问题，做网站，最喜欢使用这种东西，不需要重写代码，直接调用，传递参数，就得到想要的模块，yii也有次功能，看代码： 12345678910111213141516$this-&gt;beginWidget(&#x27;CBootStrapPortlet&#x27;, [ &#x27;title&#x27; =&gt; &#x27;博文分类&#x27;, //导航标题 &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;nav nav-pills nav-stacked&#x27;], //样式定义 &#x27;tagName&#x27; =&gt; &#x27;ul&#x27;, // &#x27;decorationCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;titleCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;contentCssClass&#x27; =&gt; &#x27;&#x27;,]);$this-&gt;widget(&#x27;CBootStrapMenu&#x27;, [ &#x27;items&#x27; =&gt; $this-&gt;blogType, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;],]);$this-&gt;endWidget(); 上面的代码是我的列表的小插件，样式我已经定义好了，只要给变量，传递参数就好了s","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Objective-C 信息传递","date":"2025-06-03T07:14:54.000Z","path":"2025/06/03/Objective-C-信息传递.html","text":"Objective-C最大的特色是承自Smalltalk的信息传递模型（message passing），与今日主流的C++差异甚大。Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递信息更为精确。此二种风格的差异主要在于程序如何看待调用方法&#x2F;传送信息这个动作。C++里类型与方法的关系非常严格清楚，一个方法必定属于一个类型，而且在编译时（compile time）就已经紧密绑定，你不可能去调用一个不存在类型里的方法。但在Objective-C，类型与信息的关系比较松散，调用方法视为对对象发送信息，所有方法都被视为对信息的回应。所有信息处理直到运行时（runtime）才会动态决定，并交由类型自行决定如何处理收到的信息。也就是说，一个类型不保证一定会回应收到的信息，如果类型收到了一个无法处理的信息，程序只会抛出一个Exception，不会出错或当掉。 C++里，送一个信息给对象（或者说调用一个方法）的语法如下: 1obj-&gt;method(argument); Objective-C则写成: 1[obj method: argument]; 此二者并不仅仅是语法上的差异，还有基本行为上的不同。 这里以一个汽车类（car class）的简单例子来解释Objective-C的信息传递特性： 1[car fly]; 典型的C++意义解读是“调用car类型的fly方法”。若car类型里头没有定义fly方法，那编译肯定不会通过。但是Objective-C里，我们应当解读为“发提交一个fly的信息给car对象”，fly是信息，而car是信息的接收者。car收到信息后会决定如何回应这个信息，若car类型内定义有fly方法就运行此段程序，若car内不存在fly方法，这里不会产生编译错误，它仅仅是抛出Exception。 此二种风格各有优劣。C++的编译期绑定使得函数调用非常快速，强制要求所有的方法都必须有对应的动作。缺点是不支持动态绑定（除非手动加上 virtual关键字）。Objective-C天生即是动态绑定，运行期才处理信息，允许传送未知信息给对象。可以送信息给整个对象集合而不需要一一检 查每个对象的型态，天生具备消息转送机制。同时空对象nil也可以接受信息，但是默认不做事，所以送信息给nil也不用担心程序崩溃。 Objective-C的方法调用因为运行期才动态解析信息，一开始信息比C++ virtual成员函数调用速度慢上三倍。但经由IMP高速缓存改善，目前已经比C++的virtual function快上50％。","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Objective-C Hello World实例","date":"2025-06-03T07:12:55.000Z","path":"2025/06/03/Objective-C-Hello-World实例.html","text":"这里示范一个基础的Hello World程序。 12345678910#import&lt;Foundation/Foundation.h&gt; int main(int argc, char *argv[])&#123; NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; NSLog(@&quot;Hello World!&quot;); [pool drain]; return 0;&#125; 以上是Xcode的旧版”Hello World”程序代码，在4.3.1 xcode的代码为: 12345678#import &lt;Foundation/Foundation.h&gt; int main(int argc, char *argv[])&#123; @autoreleasepool&#123; NSLog(@&quot;Hello World!&quot;); &#125; return 0;&#125;","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://blog.gowhich.com/tags/Objective-C/"}]},{"title":"Yii CRUD操作","date":"2025-06-03T07:11:26.000Z","path":"2025/06/03/Yii-CRUD操作.html","text":"对于喜欢操作sql语句的人来说和对于sql语句基础不是很好的，能够明白每个CRUD操作是什么意思很重要，简单的介绍个例子，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?phpclass Post extends CActiveRecord&#123; public $fixtures = [ &#x27;posts&#x27; =&gt; &#x27;Post&#x27;, &#x27;tags&#x27; =&gt; &#x27;Tag&#x27;, ]; public function findPost() &#123; //调用find时，我们使用$condition和$params指定查询条件。 //此处$condition可以是SQL语句中的WHERE字符串，$params则是一个参数数组， //其中的值应绑定到$condation中的占位符。 $post = $this-&gt;posts(&#x27;post1&#x27;); $fPost = Post::model()-&gt;find(&#x27;id=:id&#x27;, [&#x27;:id&#x27; =&gt; $post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=1 LIMIT 1 $fPost = Post::model()-&gt;find(&#x27;?&#x27;, [$post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE &#x27;1&#x27; LIMIT 1 //find返回符合条件的第一条记录，而findAll会返回符合条件的所有行。 $fAllPost = Post::model()-&gt;findAll(&#x27;id=:id&#x27;, [&#x27;:id&#x27; =&gt; $post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; $fAllPost = Post::model()-&gt;findAll(&#x27;?&#x27;, [$post-&gt;id]); //SELECT * FROM `tbl_post` `t` WHERE &#x27;1&#x27; $criteria = new CDbCriteria(); $criteria-&gt;condition = &#x27;id=:id AND title=:title&#x27;; $criteria-&gt;params = [&#x27;:id&#x27; =&gt; $post-&gt;id, &#x27;:title&#x27; =&gt; $post-&gt;title]; $fPost = Post::model()-&gt;find($criteria); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; LIMIT 1 $fAllPost = Post::model()-&gt;findAll($criteria); //SELECT * FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; $fPost = Post::model()-&gt;findByPk($post-&gt;id, &#x27;title=:title&#x27;, [&#x27;:title&#x27; =&gt; $post-&gt;title]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=1 AND (title = &#x27;post1&#x27;) LIMIT 1 $fPost = Post::model()-&gt;findByAttributes([&#x27;id&#x27; =&gt; $post-&gt;id, &#x27;title&#x27; =&gt; $post-&gt;title]); //SELECT * FROM `tbl_post` `t` WHERE `t`.`id`=&#x27;1&#x27; AND `t`.`title`=&#x27;post1&#x27; LIMIT 1 $sql = &#x27;SELECT id, title from &#123;&#123;post&#125;&#125; WHERE id = ? AND title = ?&#x27;; //必须设置表前缀 $fPost = Post::model()-&gt;findBySql($sql, [$post-&gt;id, $post-&gt;title]); $sql = &#x27;SELECT id, title from &#123;&#123;post&#125;&#125; WHERE id = :id AND title = :title&#x27;; $fPost = Post::model()-&gt;findBySql($sql, [&#x27;:id&#x27; =&gt; $post-&gt;id, &#x27;:title&#x27; =&gt; $post-&gt;title]); //如果没有找到符合条件的行，find返回null，findAll返回array()。 &#125; public function countPost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $cPost = Post::model()-&gt;count(&#x27;?&#x27;, [$post-&gt;title]); //SELECT COUNT(*) FROM `tbl_post` `t` WHERE &#x27;post1&#x27; 无意义 $cPost = Post::model()-&gt;countByAttributes([&#x27;title&#x27; =&gt; $post-&gt;title, &#x27;content&#x27; =&gt; $post-&gt;content]); //SELECT COUNT(*) FROM `tbl_post` `t` WHERE `t`.`title`=&#x27;post1&#x27; AND `t`.`content`=&#x27;content1&#x27; $sql = &quot;SELECT title from &#123;&#123;post&#125;&#125; WHERE title LIKE &#x27;%&quot; . $post-&gt;title . &quot;%&#x27;&quot;; $cPost = Post::model()-&gt;countBySql($sql); //至少有一条记录符合查询条件 $ePost = Post::model()-&gt;exists(&#x27;id=?ANDtitle=?&#x27;, [$post-&gt;id, $post-&gt;title]); //SELECT 1 FROM `tbl_post` `t` WHERE id = &#x27;1&#x27; AND title = &#x27;post1&#x27; LIMIT 1 &#125; public function updatePost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $post-&gt;title = &#x27;updatepost1&#x27;; if ($post-&gt;isNewRecord) &#123; $post-&gt;create_time = $post-&gt;update_time = new CDbExpression(&#x27;NOW()&#x27;); //UPDATE `tbl_post` SET `id`=1, `title`=&#x27;update post 1&#x27;, `content`=&#x27;content1&#x27;, `tags`=NULL, `status`=1, `create_time`=NULL, `update_time`=1302161123, `author_id`=1 WHERE `tbl_post`.`id`=1 &#125; else &#123; $post-&gt;update_time = time(); &#125; $post-&gt;save(); //updateAll $sql = &quot;SELECT * FROM &#123;&#123;post&#125;&#125; WHERE title LIKE &#x27;%&quot; . &quot;post&quot; . &quot;%&#x27;&quot;; //SELECT * FROM tbl_post WHERE title LIKE &#x27;%post%&#x27; $post = Post::model()-&gt;findBySql($sql); $post-&gt;updateAll([&#x27;update_time&#x27; =&gt; time()], &#x27;id&lt;=?&#x27;, [&#x27;2&#x27;]); //UPDATE `tbl_post` SET `update_time`=1302161123 WHERE id &lt;= &#x27;2&#x27; $post-&gt;updateByPk($post-&gt;id + 2, [&#x27;title&#x27; =&gt; &#x27;updatepost3&#x27;]); $post-&gt;updateByPk($post-&gt;id, [&#x27;title&#x27; =&gt; &#x27;updatepost3&#x27;], &#x27;id=?&#x27;, [&#x27;3&#x27;]); //updateCounter更新某个字段的数值，一般是计数器(+/-)。 $tag = $this-&gt;tags(&#x27;tag1&#x27;); $uTag = Tag::model()-&gt;updateCounters([&#x27;frequency&#x27; =&gt; &#x27;3&#x27;], &#x27;id=?&#x27;, [&#x27;1&#x27;]); &#125; public function deletePost() &#123; $post = $this-&gt;posts(&#x27;post1&#x27;); $post-&gt;delete(); $this-&gt;assertEquals(1, $post-&gt;id); //删除数据库表中的记录，但是post的这个实例还在。 $post2 = Post::model()-&gt;findByPk($post-&gt;id); $this-&gt;assertEquals(null, $post2); //多条记录 $delete = Post::model()-&gt;deleteAll(&#x27;(id = ? AND title = ?) || (id = \\&#x27;4\\&#x27;) &#x27;, [1, &#x27;post1&#x27;]); $this-&gt;assertEquals(0, $delete); $delete = Post::model()-&gt;deleteAllByAttributes([&#x27;id&#x27; =&gt; &#x27;2&#x27;], &#x27;content=?&#x27;, [&#x27;content2&#x27;]); //DELETE FROM `tbl_post` WHERE `tbl_post`.`id`=&#x27;2&#x27; AND (content = &#x27;content2&#x27;) $this-&gt;assertEquals(1, $delete); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii在IIS下的伪静态处理","date":"2025-06-03T07:09:10.000Z","path":"2025/06/03/Yii在IIS下的伪静态处理.html","text":"Yii在IIS下的伪静态处理是，在根目录建立httpd.ini文件，然后使用IIS的伪静态规则，写入自己需要的规则： 我购买的虚拟主机在香港，因为windows的主机比较多，于是我也中招了，于是四处寻求方法，四处尝试，终于找到了适合Yii的伪静态规则： 代码如下： 12345678910111213[ISAPI_Rewrite]# 3600 = 1 hourCacheClockRate 3600RepeatLimit 32RewriteEngine On#伪静态规则RewriteBase /RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)/(.*)$ $1/index.php?$2RewriteRule !\\.(js|ico|gif|jpe?g|bmp|png|css)$ index.php [L]我在虚拟机上测试通过了，哈哈，希望对你也有用","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii-Gii的安装和配置","date":"2025-06-03T07:05:48.000Z","path":"2025/06/03/Yii-Gii的安装和配置.html","text":"Gii 是基于 web 的 Yii framework 代码生成器。 开始配置 可以在你的应用程序配置文件中增加以下代码以使用该模块： 1234567&#x27;modules&#x27; =&gt; [ &#x27;gii&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;system.gii.GiiModule&#x27;, &#x27;username&#x27; =&gt; &#x27;dev&#x27;, &#x27;password&#x27; =&gt; &#x27;yiidev&#x27;, ],], 运行 打开浏览器，输入 http://localhost/yourapp/index.php?r=gii，使用刚才在配置文件中填的 username 和 password 登录。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii分页设置","date":"2025-06-03T07:03:26.000Z","path":"2025/06/03/Yii分页设置.html","text":"yii自己是带有自动分页功能的。只要在对应的controller里面，类似下面这样鞋代码，就会实现的 1234567$dataProvider = new CActiveDataProvider( &#x27;Blog&#x27;, [ &#x27;pagination&#x27; =&gt; [&#x27;pageSize&#x27; =&gt; 10], &#x27;criteria&#x27; =&gt; [&#x27;order&#x27; =&gt; &#x27;create_date DESC&#x27;], ]); 但是样式还是yii中已经写好的，那么对于我，我要改掉这个样式，使用我提供的样式，可以像我下面这样写 1234567891011121314151617181920&lt;?php$this-&gt;widget(&#x27;zii.widgets.CListView&#x27;, [ &#x27;dataProvider&#x27; =&gt; $dataProvider, &#x27;itemView&#x27; =&gt; &#x27;_view&#x27;, &#x27;summaryCssClass&#x27; =&gt; &#x27;hide&#x27;, &#x27;pagerCssClass&#x27; =&gt; &#x27;pagination&#x27;, &#x27;pager&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLinkPager&#x27;, &#x27;nextPageLabel&#x27; =&gt; &#x27;&amp;raquo;&#x27;, &#x27;prevPageLabel&#x27; =&gt; &#x27;&amp;laquo;&#x27;, &#x27;firstPageLabel&#x27; =&gt; &#x27;最前&#x27;, &#x27;lastPageLabel&#x27; =&gt; &#x27;最后&#x27;, &#x27;htmlOptions&#x27; =&gt; [&#x27;class&#x27; =&gt; &#x27;&#x27;], &#x27;header&#x27; =&gt; &#x27;&#x27;, &#x27;hiddenPageCssClass&#x27; =&gt; &#x27;disabled&#x27;, &#x27;selectedPageCssClass&#x27; =&gt; &#x27;active&#x27;, &#x27;previousPageCssClass&#x27; =&gt; &#x27;&#x27;, &#x27;nextPageCssClass&#x27; =&gt; &#x27;&#x27;, ],]); 其实只要添加自己对应的class属性就可以了，因为yii有自己默认的class属性，这个是比较简单。 下次我们可以看看，如何修改侧边下拉框，改为自己的喜欢的样式。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii CDbCriteria常用方法","date":"2025-06-03T07:01:08.000Z","path":"2025/06/03/Yii-CDbCriteria常用方法.html","text":"Yii的Active Recorder包装了很多。 特别是把SQL中 把where,order,limit,IN&#x2F;not IN,like等常用短句都包含进CDbCriteria这个类中去，这样整个代码会比较规范，一目了然。 1234567891011121314151617181920212223$criteria = newCDbCriteria;$criteria-&gt;addCondition(&quot;id=1&quot;); //查询条件，即where id =1$criteria-&gt;addInCondition(&#x27;id&#x27;, [1, 2, 3, 4, 5]); //代表where id IN (1,23,,4,5,);$criteria-&gt;addNotInCondition(&#x27;id&#x27;, [1, 2, 3, 4, 5]); //与上面正好相法，是NOT IN$criteria-&gt;addCondition(&#x27;id=1&#x27;, &#x27;OR&#x27;); //这是OR条件，多个条件的时候，该条件是OR而非AND$criteria-&gt;addSearchCondition(&#x27;name&#x27;, &#x27;分类&#x27;); //搜索条件，其实代表了。。where name like ‘%分类%’$criteria-&gt;addBetweenCondition(&#x27;id&#x27;, 1, 4); //between1 and 4$criteria-&gt;compare(&#x27;id&#x27;, 1); //这个方法比较特殊，他会根据你的参数自动处理成addCondition或者addInCondition，//即如果第二个参数是数组就会调用addInCondition$criteria-&gt;addCondition(&quot;id = :id&quot;);$criteria-&gt;params[&#x27;:id&#x27;] = 1;$criteria-&gt;select = &#x27;id,parentid,name&#x27;; //代表了要查询的字段，默认select=’*&#x27;;$criteria-&gt;join = &#x27;xxx&#x27;; //连接表$criteria-&gt;with = &#x27;xxx&#x27;; //调用relations$criteria-&gt;limit = 10; //取1条数据，如果小于0，则不作处理$criteria-&gt;offset = 1; //两条合并起来，则表示 limit 10 offset1,或者代表了。limit 1,10$criteria-&gt;order = &#x27;xxx DESC,XXX ASC&#x27;; //排序条件$criteria-&gt;group = &#x27;group 条件&#x27;;$criteria-&gt;having = &#x27;having 条件 &#x27;;$criteria-&gt;distinct = false; //是否唯一查询","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii开启错误日志","date":"2025-06-03T06:56:27.000Z","path":"2025/06/03/Yii开启错误日志.html","text":"生产环境中的 Web 应用常需要具有完善的事件日志功能。在我们的博客应用中，我们想记录它在使用时发生的错误。这些错误可能是程序错误或者是用户对系统的不当使用导致的错误。记录这些错误可以帮助我们完善此博客应用。 为启用错误日志功能，我们修改 应用配置 如下, 1234567891011121314151617181920212223242526return [ &#x27;preload&#x27; =&gt; [&#x27;log&#x27;], // ...... &#x27;components&#x27; =&gt; [ &#x27;log&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;CLogRouter&#x27;, &#x27;routes&#x27; =&gt; [ [ &#x27;class&#x27; =&gt; &#x27;CFileLogRoute&#x27;, &#x27;levels&#x27; =&gt; &#x27;error, warning&#x27;, ], [ &#x27;class&#x27; =&gt; &#x27;CProfileLogRoute&#x27;, //显示页面加载的整个流程，包括mysql语句 &#x27;levels&#x27; =&gt; &#x27;profile&#x27;, ], [ &#x27;class&#x27; =&gt; &#x27;CWebLogRoute&#x27;, &#x27;levels&#x27; =&gt; &#x27;profile,trace&#x27;, ], ], ], //...... ],]; 通过上述配置，如果有错误（error）或警告（warning）发生，其详细信息将被记录并保存到位于&#x2F;wwwroot&#x2F;blog&#x2F;protected&#x2F;runtime目录的文件中。 log组件还提供了更多的高级功能，例如将日志信息发送到一个 Email 列表，在 JavaScript 控制台窗口中显示日志信息等。更多详情，请参考指南。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"hexo默认处理heading的标题为id的异常解决方案","date":"2025-05-29T09:08:34.000Z","path":"2025/05/29/hexo默认处理heading的标题为id的异常解决方案.html","text":"hexo在处理markdown文档的时候，默认将heading的内容作为了id来处理锚点，如果是英文是没有问题的。 1## 我的标题 处理后的html内容 1&lt;h2 id=&quot;我的标题&quot;&gt;&lt;a href=&quot;#我的标题&quot; class=&quot;headerlink&quot; title=&quot;我的标题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#我的标题&quot;&gt;我的标题&lt;/a&gt;&lt;/h2&gt; 但是作为标题是中文的话就会有问题，以为在js的代码中，id是中文是不支持的，这会导致很多js库无法正常运行 找了很多资料，其中就有安装hexo-renderer-markdown-it 但是我自己亲自测试下来，还是很复杂，然后也没有解决我的问题，于是我思考这个hexo不会烂到这个程度吧 于是我看到了一种写法 1## [我的标题](#custom-id) 处理后的html内容 1&lt;h2 id=&quot;custom-id&quot;&gt;&lt;a href=&quot;#custom-id&quot; class=&quot;headerlink&quot; title=&quot;我的标题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#custom-id&quot;&gt;我的标题&lt;/a&gt;&lt;/h2&gt; 哎，可以，就这么轻松的解决了，不需要什么卸载安装什么的","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gowhich.com/tags/Hexo/"}]},{"title":"Yii简单的基于角色的访问控制","date":"2025-05-29T07:28:14.000Z","path":"2025/05/29/Yii简单的基于角色的访问控制.html","text":"123456789101112131415161718192021function filters()&#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations ];&#125;function accessRules()&#123; return [ [ &#x27;allow&#x27;, &#x27;action&#x27; =&gt; [&#x27;admin&#x27;], &#x27;roles&#x27; =&gt; [&#x27;staff&#x27;, &#x27;devel&#x27;], ], [ &#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ];&#125; 用户模型在用户表中新增一列，列名 roles。建立相应的模型。在这里它将被命名为 “User”。 当添加用户可以给他们分配角色 “管理员”，“用户”，“员工”等等。 验证在文件 protected&#x2F;components&#x2F;UserIdentity.php 添加如下内容： 123456789101112131415161718192021222324class UserIdentity extends CUserIdentity&#123; private $id; public function authenticate() &#123; $record = User::model()-&gt;findByAttributes([&#x27;email&#x27; =&gt; $this-&gt;username]); if (null === $record) &#123; $this-&gt;errorCode = self::ERROR_USERNAME_INVALID; &#125; else if (md5($this-&gt;password) !== $record-&gt;password) &#123; $this-&gt;errorCode = self::ERROR_PASSWORD_INVALID; &#125; else &#123; $this-&gt;id = $record-&gt;id; $this-&gt;setState(&#x27;roles&#x27;, $record-&gt;roles); $this-&gt;errorCode = self::ERROR_NONE; &#125; return !$this-&gt;errorCode; &#125; public function getId() &#123; return $this-&gt;id; &#125;&#125; 重要的一行是 1$this-&gt;setState(&#x27;roles&#x27;, $record-&gt;roles); 他给会话增加了用户角色。你可以使用如下代码获取用户角色。 1Yii:app()-&gt;user-&gt;getState(&quot;roles&quot;) 或 1Yii::app()-&gt;user-&gt;roles 检查权限:结构在 protected&#x2F;components 文件夹下修改并创建文件 WebUser.php ,然后重写 checkAccess() 方法。 123456789101112131415161718192021222324&lt;?phpclass WebUser extends CWebUser&#123; /** * Overrides a Yii method that is used for roles in controllers (accessRules). * * @param string $operation Name of the operation required (here, a role). * @param mixed $params (opt) Parameters for this operation, usually the object to access. * @return bool Permission granted? */ public function checkAccess($operation, $params = []) &#123; if (empty($this-&gt;id)) &#123; // Not identified =&gt; no rights return false; &#125; $role = $this-&gt;getState(&quot;roles&quot;); if (&#x27;admin&#x27; === $role) &#123; return true; // admin role has access to everything &#125; // allow access if the operation request is the current user&#x27;s role return ($operation === $role); &#125;&#125; 在 checkAccess() 方法中你可以定义自己的逻辑。确保类可以被yii使用配置文件 “protected&#x2F;config&#x2F;main.php” 必须包含以下内容: 123456&#x27;components&#x27; =&gt; [ // ... &#x27;user&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;WebUser&#x27;, ],] 旁注:[CWebUser::checkAccess()] 通常连接yii的验证系统。这里我们使用一个简单的处理角色的系统来替换[CAuthManager] 定义的分级系统。详细教程参加 Role-Based Access Control 检查权限: 使用在你的 PHP 代码中使用 Yii::app()-&gt;user-&gt;checkAccess(&#39;admin&#39;) 来检查当前用户是否有 ‘admin’ 角色。 当用户拥有 “staff” 或 “admin” 角色时，调用 Yii::app()-&gt;user-&gt;checkAccess(&quot;staff&quot;) 将会返回 true。 在控制器中你可以使用 accessRules() 中的 “roles” 属性进行过滤。 见下面的例子。 怎样过滤动作 控制器必须包含以下代码： 123456789101112131415161718192021function filters()&#123; return [ &#x27;accessControl&#x27;, // perform access control for CRUD operations ];&#125;function accessRules()&#123; return [ [ &#x27;allow&#x27;, &#x27;action&#x27; =&gt; [&#x27;admin&#x27;], &#x27;roles&#x27; =&gt; [&#x27;staff&#x27;, &#x27;devel&#x27;], ], [ &#x27;deny&#x27;, // deny all users &#x27;users&#x27; =&gt; [&#x27;*&#x27;], ], ];&#125; 这里对控制器中的 “admin” 动作进行了限制访问: 只有拥有 “staff” 或 “devel” 角色才可以访问。 像API文档中描述的那样 CAccessRule, “roles” 属性实际上调用的是 Yii::app()-&gt;user-&gt;checkAccess() 方法。 怎样根据角色显示不同菜单 你只需使用一个基于用户角色的菜单。例如 12345678910&lt;?php$user = Yii::app()-&gt;user; // just a convenience to shorten expressions$this-&gt;widget(&#x27;zii.widgets.CMenu&#x27;, [ &#x27;items&#x27; =&gt; [ [&#x27;label&#x27; =&gt; &#x27;Users&#x27;, &#x27;url&#x27; =&gt; [&#x27;/manageUser/admin&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;checkAcces(&#x27;staff&#x27;)], [&#x27;label&#x27; =&gt; &#x27;Your Ideas&#x27;, &#x27;url&#x27; =&gt; [&#x27;/userarea/ideaList&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;checkAcces(&#x27;normal&#x27;)], [&#x27;label&#x27; =&gt; &#x27;Login&#x27;, &#x27;url&#x27; =&gt; [&#x27;/site/login&#x27;], &#x27;visible&#x27; =&gt; $user-&gt;isGuest], [&#x27;label&#x27; =&gt; &#x27;Logout (&#x27; . Yii::app()-&gt;user-&gt;name . &#x27;)&#x27;, &#x27;url&#x27; =&gt; [&#x27;/site/logout&#x27;], &#x27;visible&#x27; =&gt; !$user-&gt;isGuest], ],]); 更进一步: 访问上下文一个通常的需求，用户只能够修改自己的数据。在这种情况下，用户的角色是没有任何意义的：将要修改的数据。 这就是为什么 [CWebUser::checkAccess()] 有一个可选的参数 “$param” 。现在假设我们要检查的是一个用户是否有权更新Post记录的权限。我们可以这样写： 123if (Yii::app()-&gt;user-&gt;checkAccess(&#x27;normal&#x27;, $post)) &#123; // .....&#125; 当然 WebUser::checkAccess() 必须被扩展来使用 “$params” 参数。这将取决于你的应用程序的逻辑。比如, 这可能是非常简单的 $post-&gt;userId == $this-&gt;id。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii扩展类可以放在extensions目录下面","date":"2025-05-29T07:25:04.000Z","path":"2025/05/29/Yii扩展类可以放在extensions目录下面.html","text":"下面举个例子： 如果我想写个截取字符串长度的函数功能，可以在extensions目录下面新建一个文件，命名为Helper.php 代码如下： 123456789101112131415161718192021222324252627&lt;?phpclass Helper extends CController&#123; public static function truncate_utf8_string($string, $length, $etc = &#x27;...&#x27;) &#123; $result = &#x27;&#x27;; $string = html_entity_decode(trim(strip_tags($string)), ENT_QUOTES, &#x27;UTF-8&#x27;); $strlen = strlen($string); for ($i = 0; (($i &lt; $strlen) &amp;&amp; ($length &gt; 0)); $i++)&#123; if ($number = strpos(str_pad(decbin(ord(substr($string, $i, 1))), 8, &#x27;0&#x27;, STR_PAD_LEFT), &#x27;0&#x27;))&#123; if ($length &lt; 1.0)&#123; break; &#125; $result .= substr($string, $i, $number); $length -= 1.0; $i += $number - 1; &#125;else&#123; $result .= substr($string, $i, 1); $length -= 0.5; &#125; &#125; $result = htmlspecialchars($result, ENT_QUOTES, &#x27;UTF-8&#x27;); if ($i &lt; $strlen)&#123; $result .= $etc; &#125; return $result; &#125;&#125; 然后就可以在自己的代码中引用了Helper::truncate_utf8_string(&#39;XXXXXXXXXXX&#39;,10,&#39;.......&#39;); 如果出现问题可以在config/main.php中加入在import引入要加载扩展的目录 类似： 123456&#x27;import&#x27;=&gt; array( &#x27;application.models.*&#x27;, &#x27;application.components.*&#x27;, &#x27;application.extensions.*&#x27;, // 新加 &#x27;application.extensions.yii-mail.*&#x27;,),","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"Yii中urlManager的配置","date":"2025-05-29T06:30:29.000Z","path":"2025/05/29/Yii中urlManager的配置.html","text":"第一步： 在main.php配置文件的component域中添加urlManager模块，并加入urlrules. 引入rule文件，代码如下 123456789$urls = include(dirname(__FILE__) . &#x27;/urlrules.php&#x27;);urlManager配置修改如下&#x27;urlManager&#x27;=&gt;array( &#x27;urlFormat&#x27; =&gt; &#x27;path&#x27;, &#x27;showScriptName&#x27; =&gt; false,//隐藏index.php &#x27;urlSuffix&#x27; =&gt; &#x27;.html&#x27;,//后缀 &#x27;rules&#x27; =&gt; $urls,), 第二步:在同级目录下写urlrules.php.如： 12345return array( &#x27;/index.html&#x27; =&gt; &#x27;site/index&#x27;, //首页 &#x27;search&#x27; =&gt; &#x27;search/index&#x27;，); 第三步，当然是配置服务器的rewrite模块，使得入口为index.php 1)apache下，在网站根目录下建立.htaccess如下: 12345678910Options +FollowSymLinks IndexIgnore */* RewriteEngine on # if a directory or a file exists, use it directly RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . index.php nginx下在php配置模块和location模块添加rewrite如下： 123456789101112131415161718location / &#123; root /home/george/workspace/EclipsePHP/webroot; index index.html index.php index.htm; #try_files $uri $uri/ @rewrite; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125;&#125;location ~ \\.php$ &#123; root /home/george/workspace/EclipsePHP/webroot; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/george/workspace/EclipsePHP/webroot$fastcgi_script_name; include fastcgi_params; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125;&#125; 完了，再看看你的网站的url 是不是漂亮了不少，同行努力！","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]},{"title":"ubuntu和centos的时间更新操作","date":"2025-05-29T02:38:04.000Z","path":"2025/05/29/ubuntu和centos的时间更新操作.html","text":"在Ubuntu Server上，设置NTP时间同步非常简单，就如下几步： 第一，可以先进行手动更新一次时间（可选）： sudo ntpdate ntp.ubuntu.com 第二，创建一个定时执行的文件： sudo vim /etc/cron.daily/ntpdate 然后在其中添加一行：ntpdate ntp.ubuntu.com，保存退出。 第三，修改这个定时执行文件的权限，使其变成可执行文件： sudo chmod 755 /etc/cron.daily/ntpdate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 下面解析一下,第一句是把当前时区调整为上海就是+8区,想改其他时区也可以去看看&#x2F;usr&#x2F;share&#x2F;zoneinfo目录; 然后第二句是利用ntpdate同步标准时间. 没有安装ntpdate的可以yum一下: yum install -y ntpdate 加入定时计划任务，每隔10分钟同步一下时钟 crontab -e 0-59/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP 这样，我们就可以来解决在CentOS系统中时间不准确的问题了。 如果执行命令出现一下错误 1.提示：7 Dec 19:24:55 ntpdate[2120]: the NTP socket is in use, exiting 这个是你linux机器上已经存在这个进程，输入：ps -ef | grep ntpd Kill掉ntp的进程 2.提示：No Server suitable for synchronization found 这个是最容易出现的问题，比较常见的是配置好服务器并启动服务器进程后，马上 启动客户进程，那么客户进程就会报错。解决方法是，在大约3-5分钟以后启动进程就行","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"}]},{"title":"Hello World","date":"2025-05-28T08:10:14.000Z","path":"2025/05/28/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.gowhich.com/tags/Hexo/"}]},{"title":"开始第一篇记录","date":"2025-05-28T08:10:14.000Z","path":"2025/05/28/开始第一篇记录.html","text":"这是第一篇记录","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.gowhich.com/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.gowhich.com/tags/PHP/"}]}]